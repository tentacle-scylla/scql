package cqlextract

import (
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"time"
)

const fileHeader = `// Code generated by scql codegen. DO NOT EDIT.
// Source: ScyllaDB source code
// Generated: %s

package cqldata

`

// GenerateKeywordsFile creates gen_keywords.go with extracted keywords.
func GenerateKeywordsFile(data *GrammarData, outputDir string) error {
	outputPath := filepath.Join(outputDir, "gen_keywords.go")

	f, err := os.Create(outputPath)
	if err != nil {
		return fmt.Errorf("creating keywords file: %w", err)
	}
	defer f.Close()

	fmt.Fprintf(f, fileHeader, time.Now().Format(time.RFC3339))

	fmt.Fprintln(f, "// GenAllKeywords contains all CQL keywords extracted from the grammar.")
	fmt.Fprintln(f, "var GenAllKeywords = []string{")
	for _, kw := range data.AllKeywords {
		fmt.Fprintf(f, "\t%q,\n", kw)
	}
	fmt.Fprintln(f, "}")
	fmt.Fprintln(f)

	fmt.Fprintln(f, "// GenUnreservedKeywords are keywords that can be used as identifiers.")
	fmt.Fprintln(f, "var GenUnreservedKeywords = []string{")
	for _, kw := range data.UnreservedKeywords {
		fmt.Fprintf(f, "\t%q,\n", kw)
	}
	fmt.Fprintln(f, "}")
	fmt.Fprintln(f)

	fmt.Fprintln(f, "// GenTypeKeywords are data type names that are also keywords.")
	fmt.Fprintln(f, "var GenTypeKeywords = []string{")
	for _, kw := range data.TypeKeywords {
		fmt.Fprintf(f, "\t%q,\n", kw)
	}
	fmt.Fprintln(f, "}")
	fmt.Fprintln(f)

	fmt.Fprintln(f, "// GenBasicUnreservedKeywords are basic unreserved keywords.")
	fmt.Fprintln(f, "var GenBasicUnreservedKeywords = []string{")
	for _, kw := range data.BasicUnreserved {
		fmt.Fprintf(f, "\t%q,\n", kw)
	}
	fmt.Fprintln(f, "}")
	fmt.Fprintln(f)

	fmt.Fprintln(f, "// GenAfterCreateKeywords are valid after CREATE.")
	fmt.Fprintln(f, "var GenAfterCreateKeywords = []string{")
	for _, kw := range data.AfterCreate {
		fmt.Fprintf(f, "\t%q,\n", kw)
	}
	fmt.Fprintln(f, "}")
	fmt.Fprintln(f)

	fmt.Fprintln(f, "// GenAfterAlterKeywords are valid after ALTER.")
	fmt.Fprintln(f, "var GenAfterAlterKeywords = []string{")
	for _, kw := range data.AfterAlter {
		fmt.Fprintf(f, "\t%q,\n", kw)
	}
	fmt.Fprintln(f, "}")
	fmt.Fprintln(f)

	fmt.Fprintln(f, "// GenAfterDropKeywords are valid after DROP.")
	fmt.Fprintln(f, "var GenAfterDropKeywords = []string{")
	for _, kw := range data.AfterDrop {
		fmt.Fprintf(f, "\t%q,\n", kw)
	}
	fmt.Fprintln(f, "}")
	fmt.Fprintln(f)

	starters, clauses := CategorizeKeywords(data)

	fmt.Fprintln(f, "// GenStatementKeywords are keywords that start statements.")
	fmt.Fprintln(f, "var GenStatementKeywords = []string{")
	for _, kw := range starters {
		fmt.Fprintf(f, "\t%q,\n", kw)
	}
	fmt.Fprintln(f, "}")
	fmt.Fprintln(f)

	fmt.Fprintln(f, "// GenClauseKeywords are keywords used within statements.")
	fmt.Fprintln(f, "var GenClauseKeywords = []string{")
	for _, kw := range clauses {
		fmt.Fprintf(f, "\t%q,\n", kw)
	}
	fmt.Fprintln(f, "}")

	return nil
}

// GenerateFunctionsFile creates gen_functions.go with extracted functions.
func GenerateFunctionsFile(functions []FunctionDef, outputDir string) error {
	outputPath := filepath.Join(outputDir, "gen_functions.go")

	f, err := os.Create(outputPath)
	if err != nil {
		return fmt.Errorf("creating functions file: %w", err)
	}
	defer f.Close()

	fmt.Fprintf(f, fileHeader, time.Now().Format(time.RFC3339))

	fmt.Fprint(f, `// GenFunctionDef represents a generated CQL function definition.
type GenFunctionDef struct {
	Name       string   // Function name
	ReturnType string   // Return type
	Params     []string // Parameter types
	Pure       bool     // Deterministic?
	Aggregate  bool     // Aggregate function?
}
`)

	fmt.Fprintln(f, "// GenFunctions contains all built-in CQL functions.")
	fmt.Fprintln(f, "var GenFunctions = []GenFunctionDef{")

	for _, fn := range functions {
		paramsStr := "nil"
		if len(fn.Params) > 0 {
			quoted := make([]string, len(fn.Params))
			for i, p := range fn.Params {
				quoted[i] = fmt.Sprintf("%q", p)
			}
			paramsStr = fmt.Sprintf("[]string{%s}", strings.Join(quoted, ", "))
		}

		fmt.Fprintf(f, "\t{Name: %q, ReturnType: %q, Params: %s, Pure: %v, Aggregate: %v},\n",
			fn.Name, fn.ReturnType, paramsStr, fn.Pure, fn.Aggregate)
	}
	fmt.Fprintln(f, "}")
	fmt.Fprintln(f)

	byReturnType := make(map[string][]string)
	for _, fn := range functions {
		byReturnType[fn.ReturnType] = append(byReturnType[fn.ReturnType], fn.Name)
	}

	returnTypes := make([]string, 0, len(byReturnType))
	for rt := range byReturnType {
		returnTypes = append(returnTypes, rt)
	}
	sort.Strings(returnTypes)

	fmt.Fprintln(f, "// GenFunctionsByReturnType maps return types to function names.")
	fmt.Fprintln(f, "var GenFunctionsByReturnType = map[string][]string{")
	for _, rt := range returnTypes {
		funcs := byReturnType[rt]
		sort.Strings(funcs)
		quoted := make([]string, len(funcs))
		for i, fn := range funcs {
			quoted[i] = fmt.Sprintf("%q", fn)
		}
		fmt.Fprintf(f, "\t%q: {%s},\n", rt, strings.Join(quoted, ", "))
	}
	fmt.Fprint(f, "}\n")

	return nil
}

// GenerateTypesFile creates gen_types.go with extracted types.
func GenerateTypesFile(data *TypeData, outputDir string) error {
	outputPath := filepath.Join(outputDir, "gen_types.go")

	f, err := os.Create(outputPath)
	if err != nil {
		return fmt.Errorf("creating types file: %w", err)
	}
	defer f.Close()

	fmt.Fprintf(f, fileHeader, time.Now().Format(time.RFC3339))

	fmt.Fprint(f, `// GenTypeDef represents a generated CQL type definition.
type GenTypeDef struct {
	Name    string   // Primary type name
	Aliases []string // Alternative names
	Kind    string   // Type category
}
`)

	fmt.Fprintln(f, "// GenTypes contains all built-in CQL types.")
	fmt.Fprintln(f, "var GenTypes = []GenTypeDef{")

	for _, t := range data.Types {
		aliasesStr := "nil"
		if len(t.Aliases) > 0 {
			quoted := make([]string, len(t.Aliases))
			for i, a := range t.Aliases {
				quoted[i] = fmt.Sprintf("%q", a)
			}
			aliasesStr = fmt.Sprintf("[]string{%s}", strings.Join(quoted, ", "))
		}

		fmt.Fprintf(f, "\t{Name: %q, Aliases: %s, Kind: %q},\n",
			t.Name, aliasesStr, t.Kind)
	}
	fmt.Fprintln(f, "}")
	fmt.Fprintln(f)

	fmt.Fprintln(f, "// GenTypeNames is a list of all type names (including aliases).")
	fmt.Fprintln(f, "var GenTypeNames = []string{")
	names := make(map[string]bool)
	for _, t := range data.Types {
		names[t.Name] = true
		for _, a := range t.Aliases {
			names[a] = true
		}
	}
	sortedNames := make([]string, 0, len(names))
	for n := range names {
		sortedNames = append(sortedNames, n)
	}
	sort.Strings(sortedNames)
	for _, n := range sortedNames {
		fmt.Fprintf(f, "\t%q,\n", n)
	}
	fmt.Fprintln(f, "}")
	fmt.Fprintln(f)

	byKind := GetTypesByKind(data.Types)

	kinds := make([]string, 0, len(byKind))
	for k := range byKind {
		kinds = append(kinds, k)
	}
	sort.Strings(kinds)

	fmt.Fprintln(f, "// GenTypesByKind groups types by their category.")
	fmt.Fprintln(f, "var GenTypesByKind = map[string][]string{")
	for _, kind := range kinds {
		types := byKind[kind]
		typeNames := make([]string, len(types))
		for i, t := range types {
			typeNames[i] = t.Name
		}
		sort.Strings(typeNames)
		quoted := make([]string, len(typeNames))
		for i, tn := range typeNames {
			quoted[i] = fmt.Sprintf("%q", tn)
		}
		fmt.Fprintf(f, "\t%q: {%s},\n", kind, strings.Join(quoted, ", "))
	}
	fmt.Fprintln(f, "}")
	fmt.Fprintln(f)

	fmt.Fprintln(f, "// GenTypeCompatibility maps types to their compatible types.")
	fmt.Fprintln(f, "var GenTypeCompatibility = map[string][]string{")

	compatKeys := make([]string, 0, len(data.Compatibility))
	for k := range data.Compatibility {
		compatKeys = append(compatKeys, k)
	}
	sort.Strings(compatKeys)

	for _, typeName := range compatKeys {
		compatTypes := data.Compatibility[typeName]
		sort.Strings(compatTypes)
		quoted := make([]string, len(compatTypes))
		for i, ct := range compatTypes {
			quoted[i] = fmt.Sprintf("%q", ct)
		}
		fmt.Fprintf(f, "\t%q: {%s},\n", typeName, strings.Join(quoted, ", "))
	}
	fmt.Fprint(f, "}\n")

	return nil
}
