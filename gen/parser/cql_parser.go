// Code generated from /Users/pierre/Documents/Dev/perso/tentacle/libs/scql/generated_parser/build/patched/CqlParser.g4 by ANTLR 4.13.2. DO NOT EDIT.

package generated_parser // CqlParser
import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr4-go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type CqlParser struct {
	*antlr.BaseParser
}

var CqlParserParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	LiteralNames           []string
	SymbolicNames          []string
	RuleNames              []string
	PredictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func cqlparserParserInit() {
	staticData := &CqlParserParserStaticData
	staticData.LiteralNames = []string{
		"", "'('", "')'", "'{'", "'}'", "'['", "']'", "','", "';'", "':'", "'.'",
		"'*'", "'/'", "'%'", "'+'", "'--'", "'-'", "'\"'", "'''", "'='", "'<'",
		"'>'", "'<='", "'>='", "'ADD'", "'AGGREGATE'", "'ALL'", "'ALLOW'", "'ALTER'",
		"'AND'", "'ANY'", "'APPLY'", "'AS'", "'ASC'", "'AUTHORIZE'", "'BATCH'",
		"'BEGIN'", "'BY'", "'CALLED'", "'CLUSTERING'", "'COLUMNFAMILY'", "'COMPACT'",
		"'CONSISTENCY'", "'CONTAINS'", "'CREATE'", "'CUSTOM'", "'DELETE'", "'DESC'",
		"'DESCRIBE'", "'DISTINCT'", "'DROP'", "'DURABLE_WRITES'", "'EACH_QUORUM'",
		"'ENTRIES'", "'EXECUTE'", "'EXISTS'", "'FALSE'", "'FILTERING'", "'FINALFUNC'",
		"'FROM'", "'FULL'", "'FUNCTION'", "'FUNCTIONS'", "'GRANT'", "'IF'",
		"'IN'", "'INDEX'", "'INFINITY'", "'INITCOND'", "'INPUT'", "'INSERT'",
		"'INTO'", "'IS'", "'JSON'", "'KEY'", "'KEYS'", "'KEYSPACE'", "'KEYSPACES'",
		"'LANGUAGE'", "'LEVEL'", "'LIMIT'", "'LOCAL_ONE'", "'LOCAL_QUORUM'",
		"'LOGGED'", "'LOGIN'", "'MATERIALIZED'", "'MODIFY'", "'NAN'", "'NORECURSIVE'",
		"'NOSUPERUSER'", "'NOT'", "'NULL'", "'OF'", "'ON'", "'ONE'", "'OPTIONS'",
		"'OR'", "'ORDER'", "'PARTITION'", "'PASSWORD'", "'PER'", "'PERMISSION'",
		"'PERMISSIONS'", "'PRIMARY'", "'QUORUM'", "'RENAME'", "'REPLACE'", "'REPLICATION'",
		"'RETURNS'", "'REVOKE'", "'ROLE'", "'ROLES'", "'SCHEMA'", "'SELECT'",
		"'SET'", "'SFUNC'", "'STATIC'", "'STORAGE'", "'STYPE'", "'SUPERUSER'",
		"'TABLE'", "'THREE'", "'TIMESTAMP'", "'TO'", "'TOKEN'", "'TRIGGER'",
		"'TRUE'", "'TRUNCATE'", "'TTL'", "'TWO'", "'TYPE'", "'UNLOGGED'", "'UPDATE'",
		"'USE'", "'USER'", "'USING'", "'UUID'", "'VALUES'", "'VIEW'", "'WHERE'",
		"'WITH'", "'WRITETIME'", "'ASCII'", "'BIGINT'", "'BLOB'", "'BOOLEAN'",
		"'COUNTER'", "'DATE'", "'DECIMAL'", "'DOUBLE'", "'FLOAT'", "'FROZEN'",
		"'INET'", "'INT'", "'LIST'", "'MAP'", "'SMALLINT'", "'TEXT'", "'TIMEUUID'",
		"'TIME'", "'TINYINT'", "'TUPLE'", "'VARCHAR'", "'VARINT'", "'BYPASS'",
		"'CACHE'", "'TIMEOUT'", "'PRUNE'", "'GROUP'", "'DURATION'", "'VECTOR'",
		"'LIKE'", "'CAST'", "'VALUE'", "'TABLETS'", "'DEFAULT'", "'UNSET'",
		"'SCYLLA_CLUSTERING_BOUND'", "'CLUSTER'", "'ONLY'", "'INTERNALS'", "'PASSWORDS'",
		"'TABLES'", "'TYPES'", "'AGGREGATES'", "'SERVICE'", "'LEVELS'", "'ATTACH'",
		"'DETACH'", "'ATTACHED'", "'EFFECTIVE'", "'ANN'", "'REDUCEFUNC'", "'NOLOGIN'",
		"'USERS'", "'HASHED'", "'EMPTY'", "'CONCURRENCY'", "'VECTOR_SEARCH_INDEXING'",
		"", "", "", "", "", "", "'?'", "'!='",
	}
	staticData.SymbolicNames = []string{
		"", "LR_BRACKET", "RR_BRACKET", "LC_BRACKET", "RC_BRACKET", "LS_BRACKET",
		"RS_BRACKET", "COMMA", "SEMI", "COLON", "DOT", "STAR", "DIVIDE", "MODULE",
		"PLUS", "MINUSMINUS", "MINUS", "DQUOTE", "SQUOTE", "OPERATOR_EQ", "OPERATOR_LT",
		"OPERATOR_GT", "OPERATOR_LTE", "OPERATOR_GTE", "K_ADD", "K_AGGREGATE",
		"K_ALL", "K_ALLOW", "K_ALTER", "K_AND", "K_ANY", "K_APPLY", "K_AS",
		"K_ASC", "K_AUTHORIZE", "K_BATCH", "K_BEGIN", "K_BY", "K_CALLED", "K_CLUSTERING",
		"K_COLUMNFAMILY", "K_COMPACT", "K_CONSISTENCY", "K_CONTAINS", "K_CREATE",
		"K_CUSTOM", "K_DELETE", "K_DESC", "K_DESCRIBE", "K_DISTINCT", "K_DROP",
		"K_DURABLE_WRITES", "K_EACH_QUORUM", "K_ENTRIES", "K_EXECUTE", "K_EXISTS",
		"K_FALSE", "K_FILTERING", "K_FINALFUNC", "K_FROM", "K_FULL", "K_FUNCTION",
		"K_FUNCTIONS", "K_GRANT", "K_IF", "K_IN", "K_INDEX", "K_INFINITY", "K_INITCOND",
		"K_INPUT", "K_INSERT", "K_INTO", "K_IS", "K_JSON", "K_KEY", "K_KEYS",
		"K_KEYSPACE", "K_KEYSPACES", "K_LANGUAGE", "K_LEVEL", "K_LIMIT", "K_LOCAL_ONE",
		"K_LOCAL_QUORUM", "K_LOGGED", "K_LOGIN", "K_MATERIALIZED", "K_MODIFY",
		"K_NAN", "K_NORECURSIVE", "K_NOSUPERUSER", "K_NOT", "K_NULL", "K_OF",
		"K_ON", "K_ONE", "K_OPTIONS", "K_OR", "K_ORDER", "K_PARTITION", "K_PASSWORD",
		"K_PER", "K_PERMISSION", "K_PERMISSIONS", "K_PRIMARY", "K_QUORUM", "K_RENAME",
		"K_REPLACE", "K_REPLICATION", "K_RETURNS", "K_REVOKE", "K_ROLE", "K_ROLES",
		"K_SCHEMA", "K_SELECT", "K_SET", "K_SFUNC", "K_STATIC", "K_STORAGE",
		"K_STYPE", "K_SUPERUSER", "K_TABLE", "K_THREE", "K_TIMESTAMP", "K_TO",
		"K_TOKEN", "K_TRIGGER", "K_TRUE", "K_TRUNCATE", "K_TTL", "K_TWO", "K_TYPE",
		"K_UNLOGGED", "K_UPDATE", "K_USE", "K_USER", "K_USING", "K_UUID", "K_VALUES",
		"K_VIEW", "K_WHERE", "K_WITH", "K_WRITETIME", "K_ASCII", "K_BIGINT",
		"K_BLOB", "K_BOOLEAN", "K_COUNTER", "K_DATE", "K_DECIMAL", "K_DOUBLE",
		"K_FLOAT", "K_FROZEN", "K_INET", "K_INT", "K_LIST", "K_MAP", "K_SMALLINT",
		"K_TEXT", "K_TIMEUUID", "K_TIME", "K_TINYINT", "K_TUPLE", "K_VARCHAR",
		"K_VARINT", "K_BYPASS", "K_CACHE", "K_TIMEOUT", "K_PRUNE", "K_GROUP",
		"K_DURATION", "K_VECTOR", "K_LIKE", "K_CAST", "K_VALUE", "K_TABLETS",
		"K_DEFAULT", "K_UNSET", "K_SCYLLA_CLUSTERING_BOUND", "K_CLUSTER", "K_ONLY",
		"K_INTERNALS", "K_PASSWORDS", "K_TABLES", "K_TYPES", "K_AGGREGATES",
		"K_SERVICE", "K_LEVELS", "K_ATTACH", "K_DETACH", "K_ATTACHED", "K_EFFECTIVE",
		"K_ANN", "K_REDUCEFUNC", "K_NOLOGIN", "K_USERS", "K_HASHED", "K_EMPTY",
		"K_CONCURRENCY", "K_VECTOR_SEARCH_INDEXING", "CODE_BLOCK", "STRING_LITERAL",
		"DECIMAL_LITERAL", "FLOAT_LITERAL", "HEXADECIMAL_LITERAL", "REAL_LITERAL",
		"QMARK", "OPERATOR_NEQ", "DURATION_LITERAL", "OBJECT_NAME", "UUID",
		"SPACE", "SPEC_MYSQL_COMMENT", "COMMENT_INPUT", "LINE_COMMENT", "K_COLUMNS",
		"K_VIEWS", "K_INDEXES",
	}
	staticData.RuleNames = []string{
		"root", "cqls", "statementSeparator", "empty_", "cql", "revoke", "listRoles",
		"listUsers", "listPermissions", "grant", "priviledge", "resource", "createUser",
		"createRole", "createType", "typeMemberColumnList", "createTrigger",
		"createMaterializedView", "mvWhereSpec", "mvWhereClause", "materializedViewWhere",
		"columnNotNullList", "columnNotNull", "materializedViewOptions", "createKeyspace",
		"createFunction", "codeBlock", "paramList", "returnMode", "createAggregate",
		"initCondDefinition", "initCondHash", "initCondHashItem", "initCondListNested",
		"initCondList", "orReplace", "alterUser", "userPassword", "userSuperUser",
		"alterType", "alterTypeOperation", "alterTypeRename", "alterTypeRenameList",
		"alterTypeRenameItem", "alterTypeAdd", "alterTypeAlterType", "alterTable",
		"alterTableOperation", "alterTableWith", "alterTableRename", "alterTableDropCompactStorage",
		"alterTableDropColumns", "alterTableDropColumnList", "alterTableAdd",
		"alterTableColumnDefinition", "alterRole", "roleWith", "roleWithOptions",
		"alterMaterializedView", "dropUser", "dropType", "dropMaterializedView",
		"dropAggregate", "dropFunction", "dropTrigger", "dropRole", "dropTable",
		"dropKeyspace", "dropIndex", "createTable", "withElement", "tableOptions",
		"clusteringOrder", "tableOptionItem", "tableOptionName", "tableOptionValue",
		"optionHash", "optionHashItem", "optionHashKey", "optionHashValue",
		"columnDefinitionList", "columnDefinition", "primaryKeyColumn", "staticColumn",
		"primaryKeyElement", "primaryKeyDefinition", "singlePrimaryKey", "compoundKey",
		"compositeKey", "partitionKeyList", "clusteringKeyList", "partitionKey",
		"clusteringKey", "applyBatch", "batch", "batchStatementList", "batchStatement",
		"batchInsert", "batchUpdate", "batchDelete", "beginBatch", "batchType",
		"alterKeyspace", "replicationList", "replicationListItem", "durableWrites",
		"tabletsSpec", "tabletsOptions", "tabletsOption", "use_", "truncate",
		"createIndex", "indexUsing", "indexOptions", "indexName", "indexColumnSpec",
		"indexKeysSpec", "indexEntriesSSpec", "indexFullSpec", "delete_", "deleteColumnList",
		"deleteColumnItem", "update", "ifSpec", "ifConditionList", "ifCondition",
		"ifConditionValue", "assignments", "assignmentElement", "assignmentIndexKey",
		"assignmentSet", "assignmentSetElement", "assignmentMap", "assignmentMapEntry",
		"assignmentMapKey", "assignmentMapValue", "assignmentList", "assignmentListElement",
		"assignmentTuple", "insert", "usingTtlTimestamp", "timestamp", "ttl",
		"usingTimestampSpec", "ifNotExist", "ifExist", "insertValuesSpec", "jsonDefault",
		"insertColumnSpec", "columnList", "expressionList", "expression", "select_",
		"allowFilteringSpec", "groupBySpec", "bypassCacheSpec", "perPartitionLimitSpec",
		"usingTimeoutSpec", "pruneMaterializedView", "describeStatement", "describeTarget",
		"describeInternals", "serviceLevelName", "serviceLevel", "serviceLevels",
		"createServiceLevel", "alterServiceLevel", "dropServiceLevel", "attachServiceLevel",
		"detachServiceLevel", "listServiceLevel", "propertyList", "property",
		"propertyName", "propertyValue", "pruneUsingSpec", "limitSpec", "fromSpec",
		"fromSpecElement", "orderSpec", "orderSpecElement", "vectorLiteral",
		"whereSpec", "distinctSpec", "selectElements", "selectElement", "relationElements",
		"relationElement", "relalationContains", "relalationContainsKey", "scyllaClusteringBound",
		"functionCall", "castCall", "qualifiedFunctionCall", "functionArgs",
		"constant", "namedMarker", "durationLiteral", "decimalLiteral", "floatLiteral",
		"stringLiteral", "booleanLiteral", "hexadecimalLiteral", "keyspace",
		"table", "column", "reservedKeywordAsColumn", "columnRef", "reservedKeywordAsTable",
		"reservedTypeAsTable", "dataType", "dataTypeName", "dataTypeDefinition",
		"dataTypeArg", "orderDirection", "role", "trigger", "triggerClass",
		"materializedView", "type_", "aggregate", "function_", "language", "user",
		"password", "hashKey", "param", "paramName", "kwAdd", "kwAggregate",
		"kwAll", "kwAllPermissions", "kwAllow", "kwAlter", "kwAnd", "kwApply",
		"kwAs", "kwAsc", "kwAuthorize", "kwBatch", "kwBegin", "kwBy", "kwCalled",
		"kwClustering", "kwCompact", "kwContains", "kwCreate", "kwDelete", "kwDesc",
		"kwDescibe", "kwDistinct", "kwDrop", "kwDurableWrites", "kwEntries",
		"kwExecute", "kwExists", "kwFiltering", "kwFinalfunc", "kwFrom", "kwFull",
		"kwFunction", "kwFunctions", "kwGrant", "kwIf", "kwIn", "kwIndex", "kwInitcond",
		"kwInput", "kwInsert", "kwInto", "kwIs", "kwJson", "kwKey", "kwKeys",
		"kwKeyspace", "kwKeyspaces", "kwLanguage", "kwLimit", "kwList", "kwLogged",
		"kwLogin", "kwMaterialized", "kwModify", "kwNosuperuser", "kwNorecursive",
		"kwNot", "kwNull", "kwOf", "kwOn", "kwOptions", "kwOr", "kwOrder", "kwPassword",
		"kwPrimary", "kwRename", "kwReplace", "kwReplication", "kwReturns",
		"kwRole", "kwRoles", "kwSelect", "kwSet", "kwSfunc", "kwStorage", "kwStype",
		"kwSuperuser", "kwTable", "kwTimestamp", "kwTo", "kwTrigger", "kwTruncate",
		"kwTtl", "kwType", "kwUnlogged", "kwUpdate", "kwUse", "kwUser", "kwUsing",
		"kwValues", "kwView", "kwWhere", "kwWith", "kwRevoke", "syntaxBracketLr",
		"syntaxBracketRr", "syntaxBracketLc", "syntaxBracketRc", "syntaxBracketLa",
		"syntaxBracketRa", "syntaxBracketLs", "syntaxBracketRs", "syntaxComma",
		"syntaxColon", "kwBypass", "kwCache", "kwTimeout", "kwPrune", "kwPer",
		"kwPartition", "kwGroup", "kwStatic", "kwCast", "kwLike", "kwWritetime",
		"kwToken", "kwTablets", "kwDefault", "kwUnset", "kwCounter", "kwDescribe",
		"kwCluster", "kwOnly", "kwInternals", "kwPasswords", "kwSchema", "kwTables",
		"kwTypes", "kwAggregates", "kwColumnfamily", "kwService", "kwLevel",
		"kwLevels", "kwAttach", "kwDetach", "kwAttached", "kwEffective", "kwCustom",
		"kwAnn", "kwReducefunc", "kwNologin", "kwUsers", "kwHashed", "kwEmpty",
		"kwConcurrency", "kwVectorSearchIndexing",
	}
	staticData.PredictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 216, 3350, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4,
		7, 4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10,
		7, 10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7,
		15, 2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20,
		2, 21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2,
		26, 7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31,
		7, 31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7,
		36, 2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41,
		2, 42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2,
		47, 7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52,
		7, 52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7,
		57, 2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62,
		2, 63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 2,
		68, 7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7, 71, 2, 72, 7, 72, 2, 73,
		7, 73, 2, 74, 7, 74, 2, 75, 7, 75, 2, 76, 7, 76, 2, 77, 7, 77, 2, 78, 7,
		78, 2, 79, 7, 79, 2, 80, 7, 80, 2, 81, 7, 81, 2, 82, 7, 82, 2, 83, 7, 83,
		2, 84, 7, 84, 2, 85, 7, 85, 2, 86, 7, 86, 2, 87, 7, 87, 2, 88, 7, 88, 2,
		89, 7, 89, 2, 90, 7, 90, 2, 91, 7, 91, 2, 92, 7, 92, 2, 93, 7, 93, 2, 94,
		7, 94, 2, 95, 7, 95, 2, 96, 7, 96, 2, 97, 7, 97, 2, 98, 7, 98, 2, 99, 7,
		99, 2, 100, 7, 100, 2, 101, 7, 101, 2, 102, 7, 102, 2, 103, 7, 103, 2,
		104, 7, 104, 2, 105, 7, 105, 2, 106, 7, 106, 2, 107, 7, 107, 2, 108, 7,
		108, 2, 109, 7, 109, 2, 110, 7, 110, 2, 111, 7, 111, 2, 112, 7, 112, 2,
		113, 7, 113, 2, 114, 7, 114, 2, 115, 7, 115, 2, 116, 7, 116, 2, 117, 7,
		117, 2, 118, 7, 118, 2, 119, 7, 119, 2, 120, 7, 120, 2, 121, 7, 121, 2,
		122, 7, 122, 2, 123, 7, 123, 2, 124, 7, 124, 2, 125, 7, 125, 2, 126, 7,
		126, 2, 127, 7, 127, 2, 128, 7, 128, 2, 129, 7, 129, 2, 130, 7, 130, 2,
		131, 7, 131, 2, 132, 7, 132, 2, 133, 7, 133, 2, 134, 7, 134, 2, 135, 7,
		135, 2, 136, 7, 136, 2, 137, 7, 137, 2, 138, 7, 138, 2, 139, 7, 139, 2,
		140, 7, 140, 2, 141, 7, 141, 2, 142, 7, 142, 2, 143, 7, 143, 2, 144, 7,
		144, 2, 145, 7, 145, 2, 146, 7, 146, 2, 147, 7, 147, 2, 148, 7, 148, 2,
		149, 7, 149, 2, 150, 7, 150, 2, 151, 7, 151, 2, 152, 7, 152, 2, 153, 7,
		153, 2, 154, 7, 154, 2, 155, 7, 155, 2, 156, 7, 156, 2, 157, 7, 157, 2,
		158, 7, 158, 2, 159, 7, 159, 2, 160, 7, 160, 2, 161, 7, 161, 2, 162, 7,
		162, 2, 163, 7, 163, 2, 164, 7, 164, 2, 165, 7, 165, 2, 166, 7, 166, 2,
		167, 7, 167, 2, 168, 7, 168, 2, 169, 7, 169, 2, 170, 7, 170, 2, 171, 7,
		171, 2, 172, 7, 172, 2, 173, 7, 173, 2, 174, 7, 174, 2, 175, 7, 175, 2,
		176, 7, 176, 2, 177, 7, 177, 2, 178, 7, 178, 2, 179, 7, 179, 2, 180, 7,
		180, 2, 181, 7, 181, 2, 182, 7, 182, 2, 183, 7, 183, 2, 184, 7, 184, 2,
		185, 7, 185, 2, 186, 7, 186, 2, 187, 7, 187, 2, 188, 7, 188, 2, 189, 7,
		189, 2, 190, 7, 190, 2, 191, 7, 191, 2, 192, 7, 192, 2, 193, 7, 193, 2,
		194, 7, 194, 2, 195, 7, 195, 2, 196, 7, 196, 2, 197, 7, 197, 2, 198, 7,
		198, 2, 199, 7, 199, 2, 200, 7, 200, 2, 201, 7, 201, 2, 202, 7, 202, 2,
		203, 7, 203, 2, 204, 7, 204, 2, 205, 7, 205, 2, 206, 7, 206, 2, 207, 7,
		207, 2, 208, 7, 208, 2, 209, 7, 209, 2, 210, 7, 210, 2, 211, 7, 211, 2,
		212, 7, 212, 2, 213, 7, 213, 2, 214, 7, 214, 2, 215, 7, 215, 2, 216, 7,
		216, 2, 217, 7, 217, 2, 218, 7, 218, 2, 219, 7, 219, 2, 220, 7, 220, 2,
		221, 7, 221, 2, 222, 7, 222, 2, 223, 7, 223, 2, 224, 7, 224, 2, 225, 7,
		225, 2, 226, 7, 226, 2, 227, 7, 227, 2, 228, 7, 228, 2, 229, 7, 229, 2,
		230, 7, 230, 2, 231, 7, 231, 2, 232, 7, 232, 2, 233, 7, 233, 2, 234, 7,
		234, 2, 235, 7, 235, 2, 236, 7, 236, 2, 237, 7, 237, 2, 238, 7, 238, 2,
		239, 7, 239, 2, 240, 7, 240, 2, 241, 7, 241, 2, 242, 7, 242, 2, 243, 7,
		243, 2, 244, 7, 244, 2, 245, 7, 245, 2, 246, 7, 246, 2, 247, 7, 247, 2,
		248, 7, 248, 2, 249, 7, 249, 2, 250, 7, 250, 2, 251, 7, 251, 2, 252, 7,
		252, 2, 253, 7, 253, 2, 254, 7, 254, 2, 255, 7, 255, 2, 256, 7, 256, 2,
		257, 7, 257, 2, 258, 7, 258, 2, 259, 7, 259, 2, 260, 7, 260, 2, 261, 7,
		261, 2, 262, 7, 262, 2, 263, 7, 263, 2, 264, 7, 264, 2, 265, 7, 265, 2,
		266, 7, 266, 2, 267, 7, 267, 2, 268, 7, 268, 2, 269, 7, 269, 2, 270, 7,
		270, 2, 271, 7, 271, 2, 272, 7, 272, 2, 273, 7, 273, 2, 274, 7, 274, 2,
		275, 7, 275, 2, 276, 7, 276, 2, 277, 7, 277, 2, 278, 7, 278, 2, 279, 7,
		279, 2, 280, 7, 280, 2, 281, 7, 281, 2, 282, 7, 282, 2, 283, 7, 283, 2,
		284, 7, 284, 2, 285, 7, 285, 2, 286, 7, 286, 2, 287, 7, 287, 2, 288, 7,
		288, 2, 289, 7, 289, 2, 290, 7, 290, 2, 291, 7, 291, 2, 292, 7, 292, 2,
		293, 7, 293, 2, 294, 7, 294, 2, 295, 7, 295, 2, 296, 7, 296, 2, 297, 7,
		297, 2, 298, 7, 298, 2, 299, 7, 299, 2, 300, 7, 300, 2, 301, 7, 301, 2,
		302, 7, 302, 2, 303, 7, 303, 2, 304, 7, 304, 2, 305, 7, 305, 2, 306, 7,
		306, 2, 307, 7, 307, 2, 308, 7, 308, 2, 309, 7, 309, 2, 310, 7, 310, 2,
		311, 7, 311, 2, 312, 7, 312, 2, 313, 7, 313, 2, 314, 7, 314, 2, 315, 7,
		315, 2, 316, 7, 316, 2, 317, 7, 317, 2, 318, 7, 318, 2, 319, 7, 319, 2,
		320, 7, 320, 2, 321, 7, 321, 2, 322, 7, 322, 2, 323, 7, 323, 2, 324, 7,
		324, 2, 325, 7, 325, 2, 326, 7, 326, 2, 327, 7, 327, 2, 328, 7, 328, 2,
		329, 7, 329, 2, 330, 7, 330, 2, 331, 7, 331, 2, 332, 7, 332, 2, 333, 7,
		333, 2, 334, 7, 334, 2, 335, 7, 335, 2, 336, 7, 336, 2, 337, 7, 337, 2,
		338, 7, 338, 2, 339, 7, 339, 2, 340, 7, 340, 2, 341, 7, 341, 2, 342, 7,
		342, 2, 343, 7, 343, 2, 344, 7, 344, 2, 345, 7, 345, 2, 346, 7, 346, 2,
		347, 7, 347, 2, 348, 7, 348, 2, 349, 7, 349, 2, 350, 7, 350, 2, 351, 7,
		351, 2, 352, 7, 352, 2, 353, 7, 353, 2, 354, 7, 354, 2, 355, 7, 355, 2,
		356, 7, 356, 2, 357, 7, 357, 2, 358, 7, 358, 2, 359, 7, 359, 2, 360, 7,
		360, 2, 361, 7, 361, 2, 362, 7, 362, 2, 363, 7, 363, 2, 364, 7, 364, 2,
		365, 7, 365, 2, 366, 7, 366, 2, 367, 7, 367, 2, 368, 7, 368, 2, 369, 7,
		369, 2, 370, 7, 370, 2, 371, 7, 371, 2, 372, 7, 372, 2, 373, 7, 373, 2,
		374, 7, 374, 1, 0, 3, 0, 752, 8, 0, 1, 0, 3, 0, 755, 8, 0, 1, 0, 1, 0,
		1, 1, 1, 1, 3, 1, 761, 8, 1, 1, 1, 1, 1, 1, 1, 5, 1, 766, 8, 1, 10, 1,
		12, 1, 769, 9, 1, 1, 1, 1, 1, 3, 1, 773, 8, 1, 1, 1, 3, 1, 776, 8, 1, 1,
		1, 3, 1, 779, 8, 1, 1, 2, 1, 2, 1, 3, 1, 3, 1, 4, 1, 4, 1, 4, 1, 4, 1,
		4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1,
		4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1,
		4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1,
		4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 3, 4, 832, 8, 4, 1, 5, 1, 5, 1,
		5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 6, 1, 6, 3, 6, 843, 8, 6, 1, 6, 1, 6, 1,
		6, 1, 6, 3, 6, 849, 8, 6, 1, 6, 3, 6, 852, 8, 6, 1, 7, 1, 7, 1, 7, 1, 8,
		1, 8, 1, 8, 1, 8, 1, 8, 3, 8, 862, 8, 8, 1, 8, 1, 8, 1, 8, 3, 8, 867, 8,
		8, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 10, 1, 10, 3, 10, 878,
		8, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 3,
		10, 889, 8, 10, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11,
		1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 3, 11, 904, 8, 11, 1, 11, 1, 11, 1,
		11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 3, 11, 915, 8, 11, 1, 11,
		1, 11, 1, 11, 3, 11, 920, 8, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1,
		11, 1, 11, 3, 11, 929, 8, 11, 1, 12, 1, 12, 1, 12, 3, 12, 934, 8, 12, 1,
		12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 3, 12, 942, 8, 12, 1, 13, 1, 13,
		1, 13, 3, 13, 947, 8, 13, 1, 13, 1, 13, 3, 13, 951, 8, 13, 1, 14, 1, 14,
		1, 14, 3, 14, 956, 8, 14, 1, 14, 1, 14, 1, 14, 3, 14, 961, 8, 14, 1, 14,
		1, 14, 1, 14, 1, 14, 1, 14, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 5,
		15, 974, 8, 15, 10, 15, 12, 15, 977, 9, 15, 1, 16, 1, 16, 1, 16, 3, 16,
		982, 8, 16, 1, 16, 1, 16, 1, 16, 3, 16, 987, 8, 16, 1, 16, 1, 16, 1, 16,
		1, 16, 1, 17, 1, 17, 1, 17, 1, 17, 3, 17, 997, 8, 17, 1, 17, 1, 17, 1,
		17, 3, 17, 1002, 8, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 3, 17,
		1010, 8, 17, 1, 17, 1, 17, 1, 17, 1, 17, 3, 17, 1016, 8, 17, 1, 18, 1,
		18, 1, 18, 1, 18, 1, 18, 5, 18, 1023, 8, 18, 10, 18, 12, 18, 1026, 9, 18,
		1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 3, 19, 1037,
		8, 19, 1, 20, 1, 20, 1, 20, 1, 20, 1, 20, 3, 20, 1044, 8, 20, 1, 21, 1,
		21, 1, 21, 1, 21, 5, 21, 1050, 8, 21, 10, 21, 12, 21, 1053, 9, 21, 1, 22,
		1, 22, 1, 22, 1, 22, 1, 22, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 3,
		23, 1066, 8, 23, 1, 24, 1, 24, 1, 24, 3, 24, 1071, 8, 24, 1, 24, 1, 24,
		1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 3, 24, 1083, 8,
		24, 1, 24, 1, 24, 1, 24, 3, 24, 1088, 8, 24, 1, 25, 1, 25, 3, 25, 1092,
		8, 25, 1, 25, 1, 25, 3, 25, 1096, 8, 25, 1, 25, 1, 25, 1, 25, 3, 25, 1101,
		8, 25, 1, 25, 1, 25, 1, 25, 3, 25, 1106, 8, 25, 1, 25, 1, 25, 1, 25, 1,
		25, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 1, 26, 1, 26, 1, 27, 1, 27, 1, 27,
		1, 27, 5, 27, 1123, 8, 27, 10, 27, 12, 27, 1126, 9, 27, 1, 28, 1, 28, 1,
		28, 1, 28, 3, 28, 1132, 8, 28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 29, 1, 29,
		3, 29, 1140, 8, 29, 1, 29, 1, 29, 3, 29, 1144, 8, 29, 1, 29, 1, 29, 1,
		29, 3, 29, 1149, 8, 29, 1, 29, 1, 29, 1, 29, 1, 29, 1, 29, 1, 29, 1, 29,
		1, 29, 1, 29, 1, 29, 1, 29, 3, 29, 1162, 8, 29, 1, 29, 1, 29, 1, 29, 3,
		29, 1167, 8, 29, 1, 29, 1, 29, 1, 29, 3, 29, 1172, 8, 29, 1, 30, 1, 30,
		1, 30, 1, 30, 3, 30, 1178, 8, 30, 1, 31, 1, 31, 1, 31, 1, 31, 1, 31, 5,
		31, 1185, 8, 31, 10, 31, 12, 31, 1188, 9, 31, 1, 31, 1, 31, 1, 32, 1, 32,
		1, 32, 1, 32, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 5, 33, 1202, 8,
		33, 10, 33, 12, 33, 1205, 9, 33, 1, 33, 1, 33, 1, 34, 1, 34, 1, 34, 1,
		34, 1, 34, 5, 34, 1214, 8, 34, 10, 34, 12, 34, 1217, 9, 34, 1, 34, 1, 34,
		1, 35, 1, 35, 1, 35, 1, 36, 1, 36, 1, 36, 1, 36, 1, 36, 1, 36, 3, 36, 1230,
		8, 36, 1, 37, 1, 37, 1, 37, 1, 38, 1, 38, 3, 38, 1237, 8, 38, 1, 39, 1,
		39, 1, 39, 1, 39, 1, 39, 3, 39, 1244, 8, 39, 1, 39, 1, 39, 1, 39, 1, 40,
		1, 40, 1, 40, 3, 40, 1252, 8, 40, 1, 41, 1, 41, 1, 41, 1, 42, 1, 42, 1,
		42, 1, 42, 5, 42, 1261, 8, 42, 10, 42, 12, 42, 1264, 9, 42, 1, 43, 1, 43,
		1, 43, 1, 43, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 5, 44, 1277,
		8, 44, 10, 44, 12, 44, 1280, 9, 44, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45,
		1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 3, 46, 1292, 8, 46, 1, 46, 1, 46, 1,
		46, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 3, 47, 1302, 8, 47, 1, 48, 1, 48,
		1, 48, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 50, 1, 50, 1, 50, 1, 50, 1,
		51, 1, 51, 1, 51, 1, 52, 1, 52, 1, 52, 1, 52, 5, 52, 1323, 8, 52, 10, 52,
		12, 52, 1326, 9, 52, 1, 53, 1, 53, 1, 53, 1, 53, 3, 53, 1332, 8, 53, 1,
		53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 5, 53, 1340, 8, 53, 10, 53, 12,
		53, 1343, 9, 53, 1, 53, 1, 53, 3, 53, 1347, 8, 53, 1, 54, 1, 54, 1, 54,
		1, 54, 1, 54, 1, 54, 5, 54, 1355, 8, 54, 10, 54, 12, 54, 1358, 9, 54, 1,
		55, 1, 55, 1, 55, 1, 55, 3, 55, 1364, 8, 55, 1, 56, 1, 56, 1, 56, 1, 56,
		1, 56, 5, 56, 1371, 8, 56, 10, 56, 12, 56, 1374, 9, 56, 1, 57, 1, 57, 1,
		57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57,
		1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1,
		57, 1, 57, 3, 57, 1401, 8, 57, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58,
		3, 58, 1409, 8, 58, 1, 58, 1, 58, 1, 58, 1, 58, 3, 58, 1415, 8, 58, 1,
		59, 1, 59, 1, 59, 3, 59, 1420, 8, 59, 1, 59, 1, 59, 1, 60, 1, 60, 1, 60,
		3, 60, 1427, 8, 60, 1, 60, 1, 60, 1, 60, 3, 60, 1432, 8, 60, 1, 60, 1,
		60, 1, 61, 1, 61, 1, 61, 1, 61, 3, 61, 1440, 8, 61, 1, 61, 1, 61, 1, 61,
		3, 61, 1445, 8, 61, 1, 61, 1, 61, 1, 62, 1, 62, 1, 62, 3, 62, 1452, 8,
		62, 1, 62, 1, 62, 1, 62, 3, 62, 1457, 8, 62, 1, 62, 1, 62, 1, 62, 1, 62,
		1, 62, 3, 62, 1464, 8, 62, 1, 63, 1, 63, 1, 63, 3, 63, 1469, 8, 63, 1,
		63, 1, 63, 1, 63, 3, 63, 1474, 8, 63, 1, 63, 1, 63, 1, 64, 1, 64, 1, 64,
		3, 64, 1481, 8, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 3, 64, 1488, 8,
		64, 1, 64, 1, 64, 1, 65, 1, 65, 1, 65, 3, 65, 1495, 8, 65, 1, 65, 1, 65,
		1, 66, 1, 66, 1, 66, 3, 66, 1502, 8, 66, 1, 66, 1, 66, 1, 66, 3, 66, 1507,
		8, 66, 1, 66, 1, 66, 1, 67, 1, 67, 1, 67, 3, 67, 1514, 8, 67, 1, 67, 1,
		67, 1, 68, 1, 68, 1, 68, 3, 68, 1521, 8, 68, 1, 68, 1, 68, 1, 68, 3, 68,
		1526, 8, 68, 1, 68, 1, 68, 1, 69, 1, 69, 1, 69, 3, 69, 1533, 8, 69, 1,
		69, 1, 69, 1, 69, 3, 69, 1538, 8, 69, 1, 69, 1, 69, 1, 69, 1, 69, 1, 69,
		3, 69, 1545, 8, 69, 1, 70, 1, 70, 1, 70, 1, 71, 1, 71, 1, 71, 1, 71, 1,
		71, 3, 71, 1555, 8, 71, 1, 71, 1, 71, 1, 71, 1, 71, 3, 71, 1561, 8, 71,
		1, 71, 1, 71, 1, 71, 1, 71, 5, 71, 1567, 8, 71, 10, 71, 12, 71, 1570, 9,
		71, 3, 71, 1572, 8, 71, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 3, 72,
		1580, 8, 72, 1, 72, 1, 72, 1, 72, 3, 72, 1585, 8, 72, 5, 72, 1587, 8, 72,
		10, 72, 12, 72, 1590, 9, 72, 1, 72, 1, 72, 1, 73, 1, 73, 1, 73, 1, 73,
		1, 73, 1, 73, 1, 73, 1, 73, 3, 73, 1602, 8, 73, 1, 74, 1, 74, 1, 75, 1,
		75, 3, 75, 1608, 8, 75, 1, 76, 1, 76, 1, 76, 1, 76, 1, 76, 5, 76, 1615,
		8, 76, 10, 76, 12, 76, 1618, 9, 76, 1, 76, 1, 76, 1, 77, 1, 77, 1, 77,
		1, 77, 1, 78, 1, 78, 1, 79, 1, 79, 1, 79, 1, 79, 3, 79, 1632, 8, 79, 1,
		80, 1, 80, 1, 80, 1, 80, 5, 80, 1638, 8, 80, 10, 80, 12, 80, 1641, 9, 80,
		1, 80, 1, 80, 1, 80, 3, 80, 1646, 8, 80, 1, 81, 1, 81, 1, 81, 3, 81, 1651,
		8, 81, 1, 81, 3, 81, 1654, 8, 81, 1, 82, 1, 82, 1, 82, 1, 83, 1, 83, 1,
		84, 1, 84, 1, 84, 1, 84, 1, 84, 1, 84, 1, 85, 1, 85, 1, 85, 3, 85, 1670,
		8, 85, 1, 86, 1, 86, 1, 87, 1, 87, 1, 87, 1, 87, 1, 88, 1, 88, 1, 88, 1,
		88, 1, 88, 1, 88, 1, 89, 1, 89, 1, 89, 1, 89, 5, 89, 1688, 8, 89, 10, 89,
		12, 89, 1691, 9, 89, 1, 90, 1, 90, 1, 90, 1, 90, 5, 90, 1697, 8, 90, 10,
		90, 12, 90, 1700, 9, 90, 1, 91, 1, 91, 1, 92, 1, 92, 1, 93, 1, 93, 1, 93,
		1, 94, 1, 94, 3, 94, 1711, 8, 94, 1, 94, 1, 94, 3, 94, 1715, 8, 94, 1,
		94, 3, 94, 1718, 8, 94, 1, 94, 1, 94, 1, 94, 1, 95, 4, 95, 1724, 8, 95,
		11, 95, 12, 95, 1725, 1, 96, 1, 96, 1, 96, 3, 96, 1731, 8, 96, 1, 97, 1,
		97, 1, 97, 1, 97, 1, 97, 3, 97, 1738, 8, 97, 1, 97, 1, 97, 3, 97, 1742,
		8, 97, 1, 97, 1, 97, 3, 97, 1746, 8, 97, 1, 97, 3, 97, 1749, 8, 97, 1,
		98, 1, 98, 1, 98, 1, 98, 3, 98, 1755, 8, 98, 1, 98, 1, 98, 3, 98, 1759,
		8, 98, 1, 98, 1, 98, 1, 98, 1, 98, 1, 98, 3, 98, 1766, 8, 98, 1, 99, 1,
		99, 3, 99, 1770, 8, 99, 1, 99, 1, 99, 3, 99, 1774, 8, 99, 1, 99, 1, 99,
		1, 99, 3, 99, 1779, 8, 99, 1, 100, 1, 100, 3, 100, 1783, 8, 100, 1, 100,
		1, 100, 3, 100, 1787, 8, 100, 1, 101, 1, 101, 1, 101, 3, 101, 1792, 8,
		101, 1, 102, 1, 102, 1, 102, 1, 102, 1, 102, 1, 102, 1, 102, 1, 102, 1,
		102, 1, 102, 1, 102, 1, 102, 3, 102, 1806, 8, 102, 1, 103, 1, 103, 1, 103,
		1, 103, 5, 103, 1812, 8, 103, 10, 103, 12, 103, 1815, 9, 103, 1, 104, 1,
		104, 1, 104, 1, 104, 1, 104, 1, 104, 3, 104, 1823, 8, 104, 1, 105, 1, 105,
		1, 105, 1, 105, 1, 106, 1, 106, 1, 106, 1, 106, 1, 106, 1, 106, 1, 107,
		1, 107, 1, 107, 1, 107, 5, 107, 1839, 8, 107, 10, 107, 12, 107, 1842, 9,
		107, 1, 108, 1, 108, 1, 108, 1, 108, 1, 108, 3, 108, 1849, 8, 108, 1, 109,
		1, 109, 1, 109, 1, 110, 1, 110, 3, 110, 1856, 8, 110, 1, 110, 1, 110, 1,
		110, 3, 110, 1861, 8, 110, 1, 110, 1, 110, 1, 111, 1, 111, 3, 111, 1867,
		8, 111, 1, 111, 1, 111, 3, 111, 1871, 8, 111, 1, 111, 3, 111, 1874, 8,
		111, 1, 111, 1, 111, 1, 111, 1, 111, 3, 111, 1880, 8, 111, 1, 111, 1, 111,
		1, 111, 1, 111, 1, 111, 3, 111, 1887, 8, 111, 1, 112, 1, 112, 1, 112, 3,
		112, 1892, 8, 112, 1, 113, 1, 113, 1, 113, 1, 113, 1, 113, 1, 114, 1, 114,
		3, 114, 1901, 8, 114, 1, 115, 1, 115, 1, 115, 1, 115, 3, 115, 1907, 8,
		115, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 117, 1, 117, 1, 117, 1,
		117, 1, 117, 1, 118, 1, 118, 1, 118, 1, 118, 1, 118, 1, 119, 3, 119, 1925,
		8, 119, 1, 119, 1, 119, 3, 119, 1929, 8, 119, 1, 119, 1, 119, 3, 119, 1933,
		8, 119, 1, 119, 1, 119, 1, 119, 3, 119, 1938, 8, 119, 1, 120, 1, 120, 1,
		120, 1, 120, 5, 120, 1944, 8, 120, 10, 120, 12, 120, 1947, 9, 120, 1, 121,
		1, 121, 1, 121, 1, 121, 1, 121, 3, 121, 1954, 8, 121, 1, 121, 1, 121, 3,
		121, 1958, 8, 121, 1, 122, 3, 122, 1961, 8, 122, 1, 122, 1, 122, 1, 122,
		1, 122, 3, 122, 1967, 8, 122, 1, 122, 1, 122, 3, 122, 1971, 8, 122, 1,
		122, 1, 122, 1, 122, 1, 122, 1, 122, 3, 122, 1978, 8, 122, 1, 123, 1, 123,
		1, 123, 1, 123, 1, 123, 1, 123, 1, 123, 3, 123, 1987, 8, 123, 1, 124, 1,
		124, 1, 124, 1, 124, 5, 124, 1993, 8, 124, 10, 124, 12, 124, 1996, 9, 124,
		1, 124, 1, 124, 1, 124, 5, 124, 2001, 8, 124, 10, 124, 12, 124, 2004, 9,
		124, 1, 125, 1, 125, 1, 125, 1, 125, 1, 125, 1, 125, 1, 125, 1, 125, 1,
		125, 1, 125, 1, 125, 1, 125, 1, 125, 1, 125, 1, 125, 5, 125, 2021, 8, 125,
		10, 125, 12, 125, 2024, 9, 125, 3, 125, 2026, 8, 125, 1, 125, 1, 125, 1,
		125, 1, 125, 1, 125, 1, 125, 1, 125, 1, 125, 1, 125, 1, 125, 1, 125, 1,
		125, 1, 125, 1, 125, 1, 125, 1, 125, 1, 125, 1, 125, 1, 125, 1, 125, 1,
		125, 1, 125, 1, 125, 1, 125, 1, 125, 1, 125, 1, 125, 1, 125, 1, 125, 1,
		125, 1, 125, 1, 125, 1, 125, 1, 125, 1, 125, 3, 125, 2063, 8, 125, 1, 126,
		1, 126, 1, 126, 1, 126, 1, 126, 1, 126, 3, 126, 2071, 8, 126, 1, 127, 1,
		127, 1, 127, 1, 127, 5, 127, 2077, 8, 127, 10, 127, 12, 127, 2080, 9, 127,
		1, 128, 1, 128, 1, 128, 1, 128, 1, 128, 1, 128, 1, 128, 3, 128, 2089, 8,
		128, 1, 128, 1, 128, 1, 128, 1, 128, 1, 128, 1, 128, 1, 128, 1, 128, 1,
		128, 1, 128, 1, 128, 1, 128, 1, 128, 1, 128, 1, 128, 1, 128, 1, 128, 1,
		128, 1, 128, 1, 128, 1, 128, 1, 128, 1, 128, 1, 128, 1, 128, 1, 128, 1,
		128, 1, 128, 1, 128, 1, 128, 1, 128, 1, 128, 1, 128, 1, 128, 1, 128, 1,
		128, 1, 128, 1, 128, 1, 128, 1, 128, 1, 128, 1, 128, 1, 128, 1, 128, 1,
		128, 1, 128, 1, 128, 1, 128, 1, 128, 3, 128, 2140, 8, 128, 1, 129, 1, 129,
		1, 129, 1, 129, 3, 129, 2146, 8, 129, 1, 130, 1, 130, 1, 130, 1, 130, 1,
		130, 5, 130, 2153, 8, 130, 10, 130, 12, 130, 2156, 9, 130, 3, 130, 2158,
		8, 130, 1, 130, 1, 130, 1, 131, 1, 131, 1, 131, 3, 131, 2165, 8, 131, 1,
		132, 1, 132, 1, 132, 1, 132, 1, 132, 5, 132, 2172, 8, 132, 10, 132, 12,
		132, 2175, 9, 132, 3, 132, 2177, 8, 132, 1, 132, 1, 132, 1, 133, 1, 133,
		1, 133, 1, 133, 1, 134, 1, 134, 1, 134, 3, 134, 2188, 8, 134, 1, 135, 1,
		135, 1, 135, 1, 135, 3, 135, 2194, 8, 135, 1, 136, 1, 136, 1, 136, 1, 136,
		1, 136, 5, 136, 2201, 8, 136, 10, 136, 12, 136, 2204, 9, 136, 3, 136, 2206,
		8, 136, 1, 136, 1, 136, 1, 137, 1, 137, 1, 137, 1, 137, 3, 137, 2214, 8,
		137, 1, 138, 1, 138, 1, 138, 1, 138, 1, 138, 5, 138, 2221, 8, 138, 10,
		138, 12, 138, 2224, 9, 138, 1, 138, 1, 138, 1, 139, 3, 139, 2229, 8, 139,
		1, 139, 1, 139, 1, 139, 1, 139, 1, 139, 3, 139, 2236, 8, 139, 1, 139, 1,
		139, 3, 139, 2240, 8, 139, 1, 139, 1, 139, 3, 139, 2244, 8, 139, 1, 139,
		3, 139, 2247, 8, 139, 1, 140, 1, 140, 1, 140, 1, 140, 1, 140, 1, 140, 1,
		140, 1, 140, 1, 140, 1, 140, 1, 140, 1, 140, 1, 140, 1, 140, 1, 140, 1,
		140, 1, 140, 1, 140, 1, 140, 1, 140, 1, 140, 1, 140, 1, 140, 1, 140, 1,
		140, 1, 140, 1, 140, 1, 140, 1, 140, 1, 140, 1, 140, 1, 140, 1, 140, 1,
		140, 1, 140, 1, 140, 1, 140, 1, 140, 1, 140, 1, 140, 1, 140, 1, 140, 1,
		140, 1, 140, 3, 140, 2293, 8, 140, 1, 141, 1, 141, 1, 141, 1, 142, 1, 142,
		1, 142, 1, 143, 1, 143, 1, 143, 1, 143, 1, 143, 1, 143, 1, 143, 1, 143,
		1, 143, 1, 143, 1, 143, 1, 143, 1, 143, 1, 143, 1, 143, 1, 143, 1, 143,
		1, 143, 1, 143, 3, 143, 2320, 8, 143, 1, 144, 1, 144, 1, 144, 1, 144, 1,
		145, 1, 145, 1, 145, 1, 146, 1, 146, 1, 146, 1, 146, 1, 146, 1, 146, 1,
		146, 1, 146, 3, 146, 2337, 8, 146, 3, 146, 2339, 8, 146, 1, 147, 1, 147,
		1, 147, 1, 147, 1, 147, 1, 147, 3, 147, 2347, 8, 147, 1, 148, 1, 148, 1,
		148, 1, 148, 1, 149, 1, 149, 1, 149, 1, 149, 5, 149, 2357, 8, 149, 10,
		149, 12, 149, 2360, 9, 149, 1, 150, 1, 150, 1, 150, 1, 150, 5, 150, 2366,
		8, 150, 10, 150, 12, 150, 2369, 9, 150, 1, 151, 1, 151, 1, 151, 1, 151,
		1, 151, 1, 151, 3, 151, 2377, 8, 151, 1, 152, 1, 152, 3, 152, 2381, 8,
		152, 1, 152, 3, 152, 2384, 8, 152, 1, 152, 1, 152, 1, 152, 3, 152, 2389,
		8, 152, 1, 152, 3, 152, 2392, 8, 152, 1, 152, 3, 152, 2395, 8, 152, 1,
		152, 3, 152, 2398, 8, 152, 1, 152, 3, 152, 2401, 8, 152, 1, 152, 3, 152,
		2404, 8, 152, 1, 152, 3, 152, 2407, 8, 152, 1, 152, 3, 152, 2410, 8, 152,
		1, 153, 1, 153, 1, 153, 1, 154, 1, 154, 1, 154, 1, 154, 1, 155, 1, 155,
		1, 155, 1, 156, 1, 156, 1, 156, 1, 156, 1, 156, 1, 157, 1, 157, 1, 157,
		1, 157, 1, 158, 1, 158, 1, 158, 1, 158, 1, 158, 1, 158, 3, 158, 2437, 8,
		158, 1, 158, 1, 158, 3, 158, 2441, 8, 158, 1, 158, 3, 158, 2444, 8, 158,
		1, 159, 1, 159, 3, 159, 2448, 8, 159, 1, 159, 1, 159, 3, 159, 2452, 8,
		159, 1, 160, 1, 160, 3, 160, 2456, 8, 160, 1, 160, 1, 160, 1, 160, 3, 160,
		2461, 8, 160, 1, 160, 1, 160, 3, 160, 2465, 8, 160, 1, 160, 1, 160, 3,
		160, 2469, 8, 160, 1, 160, 1, 160, 1, 160, 3, 160, 2474, 8, 160, 1, 160,
		1, 160, 1, 160, 1, 160, 1, 160, 3, 160, 2481, 8, 160, 1, 160, 1, 160, 1,
		160, 1, 160, 1, 160, 1, 160, 3, 160, 2489, 8, 160, 1, 160, 1, 160, 1, 160,
		1, 160, 1, 160, 1, 160, 1, 160, 3, 160, 2498, 8, 160, 1, 160, 1, 160, 1,
		160, 1, 160, 1, 160, 1, 160, 1, 160, 3, 160, 2507, 8, 160, 1, 160, 1, 160,
		1, 160, 1, 160, 1, 160, 1, 160, 1, 160, 3, 160, 2516, 8, 160, 1, 160, 1,
		160, 1, 160, 1, 160, 1, 160, 1, 160, 1, 160, 3, 160, 2525, 8, 160, 1, 160,
		1, 160, 3, 160, 2529, 8, 160, 1, 161, 1, 161, 1, 161, 1, 161, 1, 161, 3,
		161, 2536, 8, 161, 1, 162, 1, 162, 3, 162, 2540, 8, 162, 1, 163, 1, 163,
		1, 163, 1, 164, 1, 164, 1, 164, 1, 165, 1, 165, 1, 165, 3, 165, 2551, 8,
		165, 1, 165, 1, 165, 1, 165, 1, 165, 3, 165, 2557, 8, 165, 1, 166, 1, 166,
		1, 166, 1, 166, 1, 166, 1, 166, 1, 167, 1, 167, 1, 167, 3, 167, 2568, 8,
		167, 1, 167, 1, 167, 1, 168, 1, 168, 1, 168, 1, 168, 1, 168, 1, 168, 1,
		169, 1, 169, 1, 169, 1, 169, 1, 169, 1, 170, 1, 170, 1, 170, 1, 170, 1,
		170, 1, 170, 1, 170, 1, 170, 1, 170, 1, 170, 1, 170, 1, 170, 1, 170, 1,
		170, 1, 170, 1, 170, 1, 170, 1, 170, 1, 170, 1, 170, 3, 170, 2603, 8, 170,
		1, 171, 1, 171, 1, 171, 1, 171, 5, 171, 2609, 8, 171, 10, 171, 12, 171,
		2612, 9, 171, 1, 172, 1, 172, 1, 172, 1, 172, 1, 173, 1, 173, 1, 173, 3,
		173, 2621, 8, 173, 1, 174, 1, 174, 3, 174, 2625, 8, 174, 1, 175, 1, 175,
		1, 175, 1, 175, 1, 175, 1, 175, 1, 175, 1, 175, 1, 175, 1, 175, 1, 175,
		1, 175, 1, 175, 1, 175, 1, 175, 1, 175, 1, 175, 1, 175, 1, 175, 1, 175,
		1, 175, 1, 175, 3, 175, 2649, 8, 175, 1, 176, 1, 176, 1, 176, 1, 177, 1,
		177, 1, 177, 1, 178, 1, 178, 1, 178, 1, 178, 1, 178, 1, 178, 1, 178, 1,
		178, 1, 178, 1, 178, 1, 178, 1, 178, 3, 178, 2669, 8, 178, 1, 179, 1, 179,
		1, 179, 1, 179, 1, 180, 1, 180, 1, 180, 3, 180, 2678, 8, 180, 1, 180, 1,
		180, 1, 180, 1, 180, 1, 180, 3, 180, 2685, 8, 180, 1, 181, 1, 181, 1, 181,
		3, 181, 2690, 8, 181, 1, 181, 1, 181, 1, 181, 3, 181, 2695, 8, 181, 5,
		181, 2697, 8, 181, 10, 181, 12, 181, 2700, 9, 181, 1, 181, 1, 181, 1, 182,
		1, 182, 1, 182, 1, 183, 1, 183, 1, 184, 1, 184, 3, 184, 2711, 8, 184, 1,
		184, 1, 184, 1, 184, 5, 184, 2716, 8, 184, 10, 184, 12, 184, 2719, 9, 184,
		1, 185, 1, 185, 1, 185, 1, 185, 1, 185, 1, 185, 1, 185, 3, 185, 2728, 8,
		185, 1, 185, 1, 185, 1, 185, 1, 185, 3, 185, 2734, 8, 185, 1, 185, 1, 185,
		1, 185, 1, 185, 3, 185, 2740, 8, 185, 1, 185, 1, 185, 1, 185, 1, 185, 3,
		185, 2746, 8, 185, 3, 185, 2748, 8, 185, 1, 186, 1, 186, 1, 186, 1, 186,
		5, 186, 2754, 8, 186, 10, 186, 12, 186, 2757, 9, 186, 1, 187, 1, 187, 1,
		187, 1, 187, 1, 187, 1, 187, 1, 187, 1, 187, 1, 187, 1, 187, 1, 187, 1,
		187, 1, 187, 1, 187, 1, 187, 1, 187, 1, 187, 1, 187, 1, 187, 1, 187, 1,
		187, 1, 187, 1, 187, 1, 187, 1, 187, 1, 187, 3, 187, 2785, 8, 187, 1, 187,
		1, 187, 1, 187, 1, 187, 1, 187, 1, 187, 1, 187, 5, 187, 2794, 8, 187, 10,
		187, 12, 187, 2797, 9, 187, 1, 187, 1, 187, 1, 187, 1, 187, 1, 187, 1,
		187, 1, 187, 5, 187, 2806, 8, 187, 10, 187, 12, 187, 2809, 9, 187, 1, 187,
		1, 187, 1, 187, 1, 187, 1, 187, 1, 187, 1, 187, 5, 187, 2818, 8, 187, 10,
		187, 12, 187, 2821, 9, 187, 1, 187, 1, 187, 1, 187, 1, 187, 1, 187, 1,
		187, 5, 187, 2829, 8, 187, 10, 187, 12, 187, 2832, 9, 187, 1, 187, 1, 187,
		1, 187, 1, 187, 1, 187, 5, 187, 2839, 8, 187, 10, 187, 12, 187, 2842, 9,
		187, 1, 187, 1, 187, 1, 187, 1, 187, 1, 187, 1, 187, 1, 187, 1, 187, 1,
		187, 1, 187, 1, 187, 1, 187, 1, 187, 1, 187, 1, 187, 1, 187, 3, 187, 2860,
		8, 187, 1, 188, 1, 188, 1, 188, 1, 188, 1, 189, 1, 189, 1, 189, 1, 189,
		1, 189, 1, 189, 1, 190, 1, 190, 1, 190, 3, 190, 2875, 8, 190, 1, 190, 1,
		190, 3, 190, 2879, 8, 190, 1, 191, 1, 191, 1, 191, 1, 191, 1, 191, 1, 191,
		1, 191, 3, 191, 2888, 8, 191, 1, 191, 1, 191, 1, 191, 1, 191, 1, 191, 1,
		191, 1, 191, 1, 191, 1, 191, 1, 191, 1, 191, 1, 191, 1, 191, 1, 191, 1,
		191, 1, 191, 1, 191, 1, 191, 1, 191, 3, 191, 2909, 8, 191, 1, 192, 1, 192,
		1, 192, 1, 192, 1, 192, 1, 192, 1, 192, 1, 193, 1, 193, 1, 193, 1, 193,
		1, 193, 3, 193, 2923, 8, 193, 1, 193, 1, 193, 1, 194, 1, 194, 1, 194, 1,
		194, 3, 194, 2931, 8, 194, 1, 194, 1, 194, 1, 194, 1, 194, 1, 194, 3, 194,
		2938, 8, 194, 5, 194, 2940, 8, 194, 10, 194, 12, 194, 2943, 9, 194, 1,
		195, 1, 195, 1, 195, 1, 195, 1, 195, 1, 195, 1, 195, 1, 195, 1, 195, 1,
		195, 1, 195, 1, 195, 3, 195, 2957, 8, 195, 1, 196, 1, 196, 1, 196, 1, 197,
		1, 197, 1, 198, 1, 198, 1, 199, 1, 199, 1, 200, 1, 200, 1, 201, 1, 201,
		1, 202, 1, 202, 1, 203, 1, 203, 1, 203, 1, 203, 3, 203, 2978, 8, 203, 1,
		204, 1, 204, 1, 204, 3, 204, 2983, 8, 204, 1, 205, 1, 205, 1, 205, 1, 205,
		1, 205, 3, 205, 2990, 8, 205, 1, 206, 1, 206, 1, 207, 1, 207, 3, 207, 2996,
		8, 207, 1, 208, 1, 208, 1, 209, 1, 209, 1, 210, 1, 210, 3, 210, 3004, 8,
		210, 1, 211, 1, 211, 1, 212, 1, 212, 1, 212, 1, 212, 1, 212, 5, 212, 3013,
		8, 212, 10, 212, 12, 212, 3016, 9, 212, 1, 212, 1, 212, 1, 213, 1, 213,
		3, 213, 3022, 8, 213, 1, 214, 1, 214, 3, 214, 3026, 8, 214, 1, 215, 1,
		215, 1, 216, 1, 216, 1, 217, 1, 217, 1, 218, 1, 218, 1, 219, 1, 219, 1,
		220, 1, 220, 1, 221, 1, 221, 1, 222, 1, 222, 1, 223, 1, 223, 1, 224, 1,
		224, 1, 225, 1, 225, 1, 226, 1, 226, 1, 226, 1, 227, 1, 227, 1, 228, 1,
		228, 1, 229, 1, 229, 1, 230, 1, 230, 1, 231, 1, 231, 1, 231, 1, 232, 1,
		232, 1, 233, 1, 233, 1, 234, 1, 234, 1, 235, 1, 235, 1, 236, 1, 236, 1,
		237, 1, 237, 1, 238, 1, 238, 1, 239, 1, 239, 1, 240, 1, 240, 1, 241, 1,
		241, 1, 242, 1, 242, 1, 243, 1, 243, 1, 244, 1, 244, 1, 245, 1, 245, 1,
		246, 1, 246, 1, 247, 1, 247, 1, 248, 1, 248, 1, 249, 1, 249, 1, 250, 1,
		250, 1, 251, 1, 251, 1, 252, 1, 252, 1, 253, 1, 253, 1, 254, 1, 254, 1,
		255, 1, 255, 1, 256, 1, 256, 1, 257, 1, 257, 1, 258, 1, 258, 1, 259, 1,
		259, 1, 260, 1, 260, 1, 261, 1, 261, 1, 262, 1, 262, 1, 263, 1, 263, 1,
		264, 1, 264, 1, 265, 1, 265, 1, 266, 1, 266, 1, 267, 1, 267, 1, 268, 1,
		268, 1, 269, 1, 269, 1, 270, 1, 270, 1, 271, 1, 271, 1, 272, 1, 272, 1,
		273, 1, 273, 1, 274, 1, 274, 1, 275, 1, 275, 1, 276, 1, 276, 1, 277, 1,
		277, 1, 278, 1, 278, 1, 279, 1, 279, 1, 280, 1, 280, 1, 281, 1, 281, 1,
		282, 1, 282, 1, 283, 1, 283, 1, 284, 1, 284, 1, 285, 1, 285, 1, 286, 1,
		286, 1, 287, 1, 287, 1, 288, 1, 288, 1, 289, 1, 289, 1, 290, 1, 290, 1,
		291, 1, 291, 1, 292, 1, 292, 1, 293, 1, 293, 1, 294, 1, 294, 1, 295, 1,
		295, 1, 296, 1, 296, 1, 297, 1, 297, 1, 298, 1, 298, 1, 299, 1, 299, 1,
		300, 1, 300, 1, 301, 1, 301, 1, 302, 1, 302, 1, 303, 1, 303, 1, 304, 1,
		304, 1, 305, 1, 305, 1, 306, 1, 306, 1, 307, 1, 307, 1, 308, 1, 308, 1,
		309, 1, 309, 1, 310, 1, 310, 1, 311, 1, 311, 1, 312, 1, 312, 1, 313, 1,
		313, 1, 314, 1, 314, 1, 315, 1, 315, 1, 316, 1, 316, 1, 317, 1, 317, 1,
		318, 1, 318, 1, 319, 1, 319, 1, 320, 1, 320, 1, 321, 1, 321, 1, 322, 1,
		322, 1, 323, 1, 323, 1, 324, 1, 324, 1, 325, 1, 325, 1, 326, 1, 326, 1,
		327, 1, 327, 1, 328, 1, 328, 1, 329, 1, 329, 1, 330, 1, 330, 1, 331, 1,
		331, 1, 332, 1, 332, 1, 333, 1, 333, 1, 334, 1, 334, 1, 335, 1, 335, 1,
		336, 1, 336, 1, 337, 1, 337, 1, 338, 1, 338, 1, 339, 1, 339, 1, 340, 1,
		340, 1, 341, 1, 341, 1, 342, 1, 342, 1, 343, 1, 343, 1, 344, 1, 344, 1,
		345, 1, 345, 1, 346, 1, 346, 1, 347, 1, 347, 1, 348, 1, 348, 1, 349, 1,
		349, 1, 350, 1, 350, 1, 351, 1, 351, 1, 352, 1, 352, 1, 353, 1, 353, 1,
		354, 1, 354, 1, 355, 1, 355, 1, 356, 1, 356, 1, 357, 1, 357, 1, 358, 1,
		358, 1, 359, 1, 359, 1, 360, 1, 360, 1, 361, 1, 361, 1, 362, 1, 362, 1,
		363, 1, 363, 1, 364, 1, 364, 1, 365, 1, 365, 1, 366, 1, 366, 1, 367, 1,
		367, 1, 368, 1, 368, 1, 369, 1, 369, 1, 370, 1, 370, 1, 371, 1, 371, 1,
		372, 1, 372, 1, 373, 1, 373, 1, 374, 1, 374, 1, 374, 0, 0, 375, 0, 2, 4,
		6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42,
		44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78,
		80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112,
		114, 116, 118, 120, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 142,
		144, 146, 148, 150, 152, 154, 156, 158, 160, 162, 164, 166, 168, 170, 172,
		174, 176, 178, 180, 182, 184, 186, 188, 190, 192, 194, 196, 198, 200, 202,
		204, 206, 208, 210, 212, 214, 216, 218, 220, 222, 224, 226, 228, 230, 232,
		234, 236, 238, 240, 242, 244, 246, 248, 250, 252, 254, 256, 258, 260, 262,
		264, 266, 268, 270, 272, 274, 276, 278, 280, 282, 284, 286, 288, 290, 292,
		294, 296, 298, 300, 302, 304, 306, 308, 310, 312, 314, 316, 318, 320, 322,
		324, 326, 328, 330, 332, 334, 336, 338, 340, 342, 344, 346, 348, 350, 352,
		354, 356, 358, 360, 362, 364, 366, 368, 370, 372, 374, 376, 378, 380, 382,
		384, 386, 388, 390, 392, 394, 396, 398, 400, 402, 404, 406, 408, 410, 412,
		414, 416, 418, 420, 422, 424, 426, 428, 430, 432, 434, 436, 438, 440, 442,
		444, 446, 448, 450, 452, 454, 456, 458, 460, 462, 464, 466, 468, 470, 472,
		474, 476, 478, 480, 482, 484, 486, 488, 490, 492, 494, 496, 498, 500, 502,
		504, 506, 508, 510, 512, 514, 516, 518, 520, 522, 524, 526, 528, 530, 532,
		534, 536, 538, 540, 542, 544, 546, 548, 550, 552, 554, 556, 558, 560, 562,
		564, 566, 568, 570, 572, 574, 576, 578, 580, 582, 584, 586, 588, 590, 592,
		594, 596, 598, 600, 602, 604, 606, 608, 610, 612, 614, 616, 618, 620, 622,
		624, 626, 628, 630, 632, 634, 636, 638, 640, 642, 644, 646, 648, 650, 652,
		654, 656, 658, 660, 662, 664, 666, 668, 670, 672, 674, 676, 678, 680, 682,
		684, 686, 688, 690, 692, 694, 696, 698, 700, 702, 704, 706, 708, 710, 712,
		714, 716, 718, 720, 722, 724, 726, 728, 730, 732, 734, 736, 738, 740, 742,
		744, 746, 748, 0, 12, 1, 0, 19, 23, 1, 0, 199, 200, 2, 0, 19, 23, 206,
		206, 2, 0, 19, 19, 206, 206, 2, 0, 14, 14, 16, 16, 1, 0, 201, 202, 2, 0,
		56, 56, 126, 126, 11, 0, 74, 74, 99, 99, 110, 110, 116, 116, 122, 122,
		129, 130, 134, 134, 136, 137, 157, 157, 159, 159, 173, 173, 5, 0, 62, 62,
		77, 77, 182, 184, 194, 194, 214, 216, 9, 0, 94, 94, 121, 121, 129, 129,
		143, 143, 145, 145, 149, 150, 153, 153, 157, 157, 162, 162, 6, 0, 114,
		114, 122, 122, 136, 136, 142, 163, 169, 170, 208, 208, 2, 0, 69, 69, 208,
		208, 3427, 0, 751, 1, 0, 0, 0, 2, 767, 1, 0, 0, 0, 4, 780, 1, 0, 0, 0,
		6, 782, 1, 0, 0, 0, 8, 831, 1, 0, 0, 0, 10, 833, 1, 0, 0, 0, 12, 840, 1,
		0, 0, 0, 14, 853, 1, 0, 0, 0, 16, 856, 1, 0, 0, 0, 18, 868, 1, 0, 0, 0,
		20, 888, 1, 0, 0, 0, 22, 928, 1, 0, 0, 0, 24, 930, 1, 0, 0, 0, 26, 943,
		1, 0, 0, 0, 28, 952, 1, 0, 0, 0, 30, 967, 1, 0, 0, 0, 32, 978, 1, 0, 0,
		0, 34, 992, 1, 0, 0, 0, 36, 1017, 1, 0, 0, 0, 38, 1036, 1, 0, 0, 0, 40,
		1038, 1, 0, 0, 0, 42, 1045, 1, 0, 0, 0, 44, 1054, 1, 0, 0, 0, 46, 1065,
		1, 0, 0, 0, 48, 1067, 1, 0, 0, 0, 50, 1089, 1, 0, 0, 0, 52, 1116, 1, 0,
		0, 0, 54, 1118, 1, 0, 0, 0, 56, 1131, 1, 0, 0, 0, 58, 1137, 1, 0, 0, 0,
		60, 1177, 1, 0, 0, 0, 62, 1179, 1, 0, 0, 0, 64, 1191, 1, 0, 0, 0, 66, 1195,
		1, 0, 0, 0, 68, 1208, 1, 0, 0, 0, 70, 1220, 1, 0, 0, 0, 72, 1223, 1, 0,
		0, 0, 74, 1231, 1, 0, 0, 0, 76, 1236, 1, 0, 0, 0, 78, 1238, 1, 0, 0, 0,
		80, 1251, 1, 0, 0, 0, 82, 1253, 1, 0, 0, 0, 84, 1256, 1, 0, 0, 0, 86, 1265,
		1, 0, 0, 0, 88, 1269, 1, 0, 0, 0, 90, 1281, 1, 0, 0, 0, 92, 1286, 1, 0,
		0, 0, 94, 1301, 1, 0, 0, 0, 96, 1303, 1, 0, 0, 0, 98, 1306, 1, 0, 0, 0,
		100, 1311, 1, 0, 0, 0, 102, 1315, 1, 0, 0, 0, 104, 1318, 1, 0, 0, 0, 106,
		1346, 1, 0, 0, 0, 108, 1348, 1, 0, 0, 0, 110, 1359, 1, 0, 0, 0, 112, 1365,
		1, 0, 0, 0, 114, 1400, 1, 0, 0, 0, 116, 1402, 1, 0, 0, 0, 118, 1416, 1,
		0, 0, 0, 120, 1423, 1, 0, 0, 0, 122, 1435, 1, 0, 0, 0, 124, 1448, 1, 0,
		0, 0, 126, 1465, 1, 0, 0, 0, 128, 1477, 1, 0, 0, 0, 130, 1491, 1, 0, 0,
		0, 132, 1498, 1, 0, 0, 0, 134, 1510, 1, 0, 0, 0, 136, 1517, 1, 0, 0, 0,
		138, 1529, 1, 0, 0, 0, 140, 1546, 1, 0, 0, 0, 142, 1571, 1, 0, 0, 0, 144,
		1573, 1, 0, 0, 0, 146, 1601, 1, 0, 0, 0, 148, 1603, 1, 0, 0, 0, 150, 1607,
		1, 0, 0, 0, 152, 1609, 1, 0, 0, 0, 154, 1621, 1, 0, 0, 0, 156, 1625, 1,
		0, 0, 0, 158, 1631, 1, 0, 0, 0, 160, 1633, 1, 0, 0, 0, 162, 1647, 1, 0,
		0, 0, 164, 1655, 1, 0, 0, 0, 166, 1658, 1, 0, 0, 0, 168, 1660, 1, 0, 0,
		0, 170, 1669, 1, 0, 0, 0, 172, 1671, 1, 0, 0, 0, 174, 1673, 1, 0, 0, 0,
		176, 1677, 1, 0, 0, 0, 178, 1683, 1, 0, 0, 0, 180, 1692, 1, 0, 0, 0, 182,
		1701, 1, 0, 0, 0, 184, 1703, 1, 0, 0, 0, 186, 1705, 1, 0, 0, 0, 188, 1708,
		1, 0, 0, 0, 190, 1723, 1, 0, 0, 0, 192, 1730, 1, 0, 0, 0, 194, 1732, 1,
		0, 0, 0, 196, 1750, 1, 0, 0, 0, 198, 1767, 1, 0, 0, 0, 200, 1780, 1, 0,
		0, 0, 202, 1791, 1, 0, 0, 0, 204, 1793, 1, 0, 0, 0, 206, 1807, 1, 0, 0,
		0, 208, 1822, 1, 0, 0, 0, 210, 1824, 1, 0, 0, 0, 212, 1828, 1, 0, 0, 0,
		214, 1834, 1, 0, 0, 0, 216, 1843, 1, 0, 0, 0, 218, 1850, 1, 0, 0, 0, 220,
		1853, 1, 0, 0, 0, 222, 1864, 1, 0, 0, 0, 224, 1888, 1, 0, 0, 0, 226, 1893,
		1, 0, 0, 0, 228, 1900, 1, 0, 0, 0, 230, 1906, 1, 0, 0, 0, 232, 1908, 1,
		0, 0, 0, 234, 1913, 1, 0, 0, 0, 236, 1918, 1, 0, 0, 0, 238, 1924, 1, 0,
		0, 0, 240, 1939, 1, 0, 0, 0, 242, 1957, 1, 0, 0, 0, 244, 1960, 1, 0, 0,
		0, 246, 1986, 1, 0, 0, 0, 248, 1988, 1, 0, 0, 0, 250, 2062, 1, 0, 0, 0,
		252, 2070, 1, 0, 0, 0, 254, 2072, 1, 0, 0, 0, 256, 2139, 1, 0, 0, 0, 258,
		2145, 1, 0, 0, 0, 260, 2147, 1, 0, 0, 0, 262, 2164, 1, 0, 0, 0, 264, 2166,
		1, 0, 0, 0, 266, 2180, 1, 0, 0, 0, 268, 2187, 1, 0, 0, 0, 270, 2193, 1,
		0, 0, 0, 272, 2195, 1, 0, 0, 0, 274, 2213, 1, 0, 0, 0, 276, 2215, 1, 0,
		0, 0, 278, 2228, 1, 0, 0, 0, 280, 2292, 1, 0, 0, 0, 282, 2294, 1, 0, 0,
		0, 284, 2297, 1, 0, 0, 0, 286, 2319, 1, 0, 0, 0, 288, 2321, 1, 0, 0, 0,
		290, 2325, 1, 0, 0, 0, 292, 2338, 1, 0, 0, 0, 294, 2346, 1, 0, 0, 0, 296,
		2348, 1, 0, 0, 0, 298, 2352, 1, 0, 0, 0, 300, 2361, 1, 0, 0, 0, 302, 2376,
		1, 0, 0, 0, 304, 2378, 1, 0, 0, 0, 306, 2411, 1, 0, 0, 0, 308, 2414, 1,
		0, 0, 0, 310, 2418, 1, 0, 0, 0, 312, 2421, 1, 0, 0, 0, 314, 2426, 1, 0,
		0, 0, 316, 2430, 1, 0, 0, 0, 318, 2447, 1, 0, 0, 0, 320, 2528, 1, 0, 0,
		0, 322, 2530, 1, 0, 0, 0, 324, 2539, 1, 0, 0, 0, 326, 2541, 1, 0, 0, 0,
		328, 2544, 1, 0, 0, 0, 330, 2547, 1, 0, 0, 0, 332, 2558, 1, 0, 0, 0, 334,
		2564, 1, 0, 0, 0, 336, 2571, 1, 0, 0, 0, 338, 2577, 1, 0, 0, 0, 340, 2602,
		1, 0, 0, 0, 342, 2604, 1, 0, 0, 0, 344, 2613, 1, 0, 0, 0, 346, 2620, 1,
		0, 0, 0, 348, 2624, 1, 0, 0, 0, 350, 2648, 1, 0, 0, 0, 352, 2650, 1, 0,
		0, 0, 354, 2653, 1, 0, 0, 0, 356, 2668, 1, 0, 0, 0, 358, 2670, 1, 0, 0,
		0, 360, 2684, 1, 0, 0, 0, 362, 2686, 1, 0, 0, 0, 364, 2703, 1, 0, 0, 0,
		366, 2706, 1, 0, 0, 0, 368, 2710, 1, 0, 0, 0, 370, 2747, 1, 0, 0, 0, 372,
		2749, 1, 0, 0, 0, 374, 2859, 1, 0, 0, 0, 376, 2861, 1, 0, 0, 0, 378, 2865,
		1, 0, 0, 0, 380, 2878, 1, 0, 0, 0, 382, 2908, 1, 0, 0, 0, 384, 2910, 1,
		0, 0, 0, 386, 2917, 1, 0, 0, 0, 388, 2930, 1, 0, 0, 0, 390, 2956, 1, 0,
		0, 0, 392, 2958, 1, 0, 0, 0, 394, 2961, 1, 0, 0, 0, 396, 2963, 1, 0, 0,
		0, 398, 2965, 1, 0, 0, 0, 400, 2967, 1, 0, 0, 0, 402, 2969, 1, 0, 0, 0,
		404, 2971, 1, 0, 0, 0, 406, 2977, 1, 0, 0, 0, 408, 2982, 1, 0, 0, 0, 410,
		2989, 1, 0, 0, 0, 412, 2991, 1, 0, 0, 0, 414, 2995, 1, 0, 0, 0, 416, 2997,
		1, 0, 0, 0, 418, 2999, 1, 0, 0, 0, 420, 3001, 1, 0, 0, 0, 422, 3005, 1,
		0, 0, 0, 424, 3007, 1, 0, 0, 0, 426, 3021, 1, 0, 0, 0, 428, 3025, 1, 0,
		0, 0, 430, 3027, 1, 0, 0, 0, 432, 3029, 1, 0, 0, 0, 434, 3031, 1, 0, 0,
		0, 436, 3033, 1, 0, 0, 0, 438, 3035, 1, 0, 0, 0, 440, 3037, 1, 0, 0, 0,
		442, 3039, 1, 0, 0, 0, 444, 3041, 1, 0, 0, 0, 446, 3043, 1, 0, 0, 0, 448,
		3045, 1, 0, 0, 0, 450, 3047, 1, 0, 0, 0, 452, 3049, 1, 0, 0, 0, 454, 3052,
		1, 0, 0, 0, 456, 3054, 1, 0, 0, 0, 458, 3056, 1, 0, 0, 0, 460, 3058, 1,
		0, 0, 0, 462, 3060, 1, 0, 0, 0, 464, 3063, 1, 0, 0, 0, 466, 3065, 1, 0,
		0, 0, 468, 3067, 1, 0, 0, 0, 470, 3069, 1, 0, 0, 0, 472, 3071, 1, 0, 0,
		0, 474, 3073, 1, 0, 0, 0, 476, 3075, 1, 0, 0, 0, 478, 3077, 1, 0, 0, 0,
		480, 3079, 1, 0, 0, 0, 482, 3081, 1, 0, 0, 0, 484, 3083, 1, 0, 0, 0, 486,
		3085, 1, 0, 0, 0, 488, 3087, 1, 0, 0, 0, 490, 3089, 1, 0, 0, 0, 492, 3091,
		1, 0, 0, 0, 494, 3093, 1, 0, 0, 0, 496, 3095, 1, 0, 0, 0, 498, 3097, 1,
		0, 0, 0, 500, 3099, 1, 0, 0, 0, 502, 3101, 1, 0, 0, 0, 504, 3103, 1, 0,
		0, 0, 506, 3105, 1, 0, 0, 0, 508, 3107, 1, 0, 0, 0, 510, 3109, 1, 0, 0,
		0, 512, 3111, 1, 0, 0, 0, 514, 3113, 1, 0, 0, 0, 516, 3115, 1, 0, 0, 0,
		518, 3117, 1, 0, 0, 0, 520, 3119, 1, 0, 0, 0, 522, 3121, 1, 0, 0, 0, 524,
		3123, 1, 0, 0, 0, 526, 3125, 1, 0, 0, 0, 528, 3127, 1, 0, 0, 0, 530, 3129,
		1, 0, 0, 0, 532, 3131, 1, 0, 0, 0, 534, 3133, 1, 0, 0, 0, 536, 3135, 1,
		0, 0, 0, 538, 3137, 1, 0, 0, 0, 540, 3139, 1, 0, 0, 0, 542, 3141, 1, 0,
		0, 0, 544, 3143, 1, 0, 0, 0, 546, 3145, 1, 0, 0, 0, 548, 3147, 1, 0, 0,
		0, 550, 3149, 1, 0, 0, 0, 552, 3151, 1, 0, 0, 0, 554, 3153, 1, 0, 0, 0,
		556, 3155, 1, 0, 0, 0, 558, 3157, 1, 0, 0, 0, 560, 3159, 1, 0, 0, 0, 562,
		3161, 1, 0, 0, 0, 564, 3163, 1, 0, 0, 0, 566, 3165, 1, 0, 0, 0, 568, 3167,
		1, 0, 0, 0, 570, 3169, 1, 0, 0, 0, 572, 3171, 1, 0, 0, 0, 574, 3173, 1,
		0, 0, 0, 576, 3175, 1, 0, 0, 0, 578, 3177, 1, 0, 0, 0, 580, 3179, 1, 0,
		0, 0, 582, 3181, 1, 0, 0, 0, 584, 3183, 1, 0, 0, 0, 586, 3185, 1, 0, 0,
		0, 588, 3187, 1, 0, 0, 0, 590, 3189, 1, 0, 0, 0, 592, 3191, 1, 0, 0, 0,
		594, 3193, 1, 0, 0, 0, 596, 3195, 1, 0, 0, 0, 598, 3197, 1, 0, 0, 0, 600,
		3199, 1, 0, 0, 0, 602, 3201, 1, 0, 0, 0, 604, 3203, 1, 0, 0, 0, 606, 3205,
		1, 0, 0, 0, 608, 3207, 1, 0, 0, 0, 610, 3209, 1, 0, 0, 0, 612, 3211, 1,
		0, 0, 0, 614, 3213, 1, 0, 0, 0, 616, 3215, 1, 0, 0, 0, 618, 3217, 1, 0,
		0, 0, 620, 3219, 1, 0, 0, 0, 622, 3221, 1, 0, 0, 0, 624, 3223, 1, 0, 0,
		0, 626, 3225, 1, 0, 0, 0, 628, 3227, 1, 0, 0, 0, 630, 3229, 1, 0, 0, 0,
		632, 3231, 1, 0, 0, 0, 634, 3233, 1, 0, 0, 0, 636, 3235, 1, 0, 0, 0, 638,
		3237, 1, 0, 0, 0, 640, 3239, 1, 0, 0, 0, 642, 3241, 1, 0, 0, 0, 644, 3243,
		1, 0, 0, 0, 646, 3245, 1, 0, 0, 0, 648, 3247, 1, 0, 0, 0, 650, 3249, 1,
		0, 0, 0, 652, 3251, 1, 0, 0, 0, 654, 3253, 1, 0, 0, 0, 656, 3255, 1, 0,
		0, 0, 658, 3257, 1, 0, 0, 0, 660, 3259, 1, 0, 0, 0, 662, 3261, 1, 0, 0,
		0, 664, 3263, 1, 0, 0, 0, 666, 3265, 1, 0, 0, 0, 668, 3267, 1, 0, 0, 0,
		670, 3269, 1, 0, 0, 0, 672, 3271, 1, 0, 0, 0, 674, 3273, 1, 0, 0, 0, 676,
		3275, 1, 0, 0, 0, 678, 3277, 1, 0, 0, 0, 680, 3279, 1, 0, 0, 0, 682, 3281,
		1, 0, 0, 0, 684, 3283, 1, 0, 0, 0, 686, 3285, 1, 0, 0, 0, 688, 3287, 1,
		0, 0, 0, 690, 3289, 1, 0, 0, 0, 692, 3291, 1, 0, 0, 0, 694, 3293, 1, 0,
		0, 0, 696, 3295, 1, 0, 0, 0, 698, 3297, 1, 0, 0, 0, 700, 3299, 1, 0, 0,
		0, 702, 3301, 1, 0, 0, 0, 704, 3303, 1, 0, 0, 0, 706, 3305, 1, 0, 0, 0,
		708, 3307, 1, 0, 0, 0, 710, 3309, 1, 0, 0, 0, 712, 3311, 1, 0, 0, 0, 714,
		3313, 1, 0, 0, 0, 716, 3315, 1, 0, 0, 0, 718, 3317, 1, 0, 0, 0, 720, 3319,
		1, 0, 0, 0, 722, 3321, 1, 0, 0, 0, 724, 3323, 1, 0, 0, 0, 726, 3325, 1,
		0, 0, 0, 728, 3327, 1, 0, 0, 0, 730, 3329, 1, 0, 0, 0, 732, 3331, 1, 0,
		0, 0, 734, 3333, 1, 0, 0, 0, 736, 3335, 1, 0, 0, 0, 738, 3337, 1, 0, 0,
		0, 740, 3339, 1, 0, 0, 0, 742, 3341, 1, 0, 0, 0, 744, 3343, 1, 0, 0, 0,
		746, 3345, 1, 0, 0, 0, 748, 3347, 1, 0, 0, 0, 750, 752, 3, 2, 1, 0, 751,
		750, 1, 0, 0, 0, 751, 752, 1, 0, 0, 0, 752, 754, 1, 0, 0, 0, 753, 755,
		5, 15, 0, 0, 754, 753, 1, 0, 0, 0, 754, 755, 1, 0, 0, 0, 755, 756, 1, 0,
		0, 0, 756, 757, 5, 0, 0, 1, 757, 1, 1, 0, 0, 0, 758, 760, 3, 8, 4, 0, 759,
		761, 5, 15, 0, 0, 760, 759, 1, 0, 0, 0, 760, 761, 1, 0, 0, 0, 761, 762,
		1, 0, 0, 0, 762, 763, 3, 4, 2, 0, 763, 766, 1, 0, 0, 0, 764, 766, 3, 6,
		3, 0, 765, 758, 1, 0, 0, 0, 765, 764, 1, 0, 0, 0, 766, 769, 1, 0, 0, 0,
		767, 765, 1, 0, 0, 0, 767, 768, 1, 0, 0, 0, 768, 778, 1, 0, 0, 0, 769,
		767, 1, 0, 0, 0, 770, 775, 3, 8, 4, 0, 771, 773, 5, 15, 0, 0, 772, 771,
		1, 0, 0, 0, 772, 773, 1, 0, 0, 0, 773, 774, 1, 0, 0, 0, 774, 776, 3, 4,
		2, 0, 775, 772, 1, 0, 0, 0, 775, 776, 1, 0, 0, 0, 776, 779, 1, 0, 0, 0,
		777, 779, 3, 6, 3, 0, 778, 770, 1, 0, 0, 0, 778, 777, 1, 0, 0, 0, 779,
		3, 1, 0, 0, 0, 780, 781, 5, 8, 0, 0, 781, 5, 1, 0, 0, 0, 782, 783, 3, 4,
		2, 0, 783, 7, 1, 0, 0, 0, 784, 832, 3, 204, 102, 0, 785, 832, 3, 116, 58,
		0, 786, 832, 3, 110, 55, 0, 787, 832, 3, 92, 46, 0, 788, 832, 3, 78, 39,
		0, 789, 832, 3, 72, 36, 0, 790, 832, 3, 186, 93, 0, 791, 832, 3, 58, 29,
		0, 792, 832, 3, 50, 25, 0, 793, 832, 3, 222, 111, 0, 794, 832, 3, 48, 24,
		0, 795, 832, 3, 34, 17, 0, 796, 832, 3, 26, 13, 0, 797, 832, 3, 138, 69,
		0, 798, 832, 3, 32, 16, 0, 799, 832, 3, 28, 14, 0, 800, 832, 3, 24, 12,
		0, 801, 832, 3, 238, 119, 0, 802, 832, 3, 124, 62, 0, 803, 832, 3, 126,
		63, 0, 804, 832, 3, 136, 68, 0, 805, 832, 3, 134, 67, 0, 806, 832, 3, 122,
		61, 0, 807, 832, 3, 130, 65, 0, 808, 832, 3, 132, 66, 0, 809, 832, 3, 128,
		64, 0, 810, 832, 3, 120, 60, 0, 811, 832, 3, 118, 59, 0, 812, 832, 3, 18,
		9, 0, 813, 832, 3, 278, 139, 0, 814, 832, 3, 16, 8, 0, 815, 832, 3, 12,
		6, 0, 816, 832, 3, 10, 5, 0, 817, 832, 3, 304, 152, 0, 818, 832, 3, 220,
		110, 0, 819, 832, 3, 244, 122, 0, 820, 832, 3, 218, 109, 0, 821, 832, 3,
		316, 158, 0, 822, 832, 3, 188, 94, 0, 823, 832, 3, 318, 159, 0, 824, 832,
		3, 330, 165, 0, 825, 832, 3, 332, 166, 0, 826, 832, 3, 334, 167, 0, 827,
		832, 3, 336, 168, 0, 828, 832, 3, 338, 169, 0, 829, 832, 3, 340, 170, 0,
		830, 832, 3, 14, 7, 0, 831, 784, 1, 0, 0, 0, 831, 785, 1, 0, 0, 0, 831,
		786, 1, 0, 0, 0, 831, 787, 1, 0, 0, 0, 831, 788, 1, 0, 0, 0, 831, 789,
		1, 0, 0, 0, 831, 790, 1, 0, 0, 0, 831, 791, 1, 0, 0, 0, 831, 792, 1, 0,
		0, 0, 831, 793, 1, 0, 0, 0, 831, 794, 1, 0, 0, 0, 831, 795, 1, 0, 0, 0,
		831, 796, 1, 0, 0, 0, 831, 797, 1, 0, 0, 0, 831, 798, 1, 0, 0, 0, 831,
		799, 1, 0, 0, 0, 831, 800, 1, 0, 0, 0, 831, 801, 1, 0, 0, 0, 831, 802,
		1, 0, 0, 0, 831, 803, 1, 0, 0, 0, 831, 804, 1, 0, 0, 0, 831, 805, 1, 0,
		0, 0, 831, 806, 1, 0, 0, 0, 831, 807, 1, 0, 0, 0, 831, 808, 1, 0, 0, 0,
		831, 809, 1, 0, 0, 0, 831, 810, 1, 0, 0, 0, 831, 811, 1, 0, 0, 0, 831,
		812, 1, 0, 0, 0, 831, 813, 1, 0, 0, 0, 831, 814, 1, 0, 0, 0, 831, 815,
		1, 0, 0, 0, 831, 816, 1, 0, 0, 0, 831, 817, 1, 0, 0, 0, 831, 818, 1, 0,
		0, 0, 831, 819, 1, 0, 0, 0, 831, 820, 1, 0, 0, 0, 831, 821, 1, 0, 0, 0,
		831, 822, 1, 0, 0, 0, 831, 823, 1, 0, 0, 0, 831, 824, 1, 0, 0, 0, 831,
		825, 1, 0, 0, 0, 831, 826, 1, 0, 0, 0, 831, 827, 1, 0, 0, 0, 831, 828,
		1, 0, 0, 0, 831, 829, 1, 0, 0, 0, 831, 830, 1, 0, 0, 0, 832, 9, 1, 0, 0,
		0, 833, 834, 3, 644, 322, 0, 834, 835, 3, 20, 10, 0, 835, 836, 3, 576,
		288, 0, 836, 837, 3, 22, 11, 0, 837, 838, 3, 516, 258, 0, 838, 839, 3,
		430, 215, 0, 839, 11, 1, 0, 0, 0, 840, 842, 3, 556, 278, 0, 841, 843, 3,
		460, 230, 0, 842, 841, 1, 0, 0, 0, 842, 843, 1, 0, 0, 0, 843, 844, 1, 0,
		0, 0, 844, 848, 3, 598, 299, 0, 845, 846, 3, 574, 287, 0, 846, 847, 3,
		430, 215, 0, 847, 849, 1, 0, 0, 0, 848, 845, 1, 0, 0, 0, 848, 849, 1, 0,
		0, 0, 849, 851, 1, 0, 0, 0, 850, 852, 3, 568, 284, 0, 851, 850, 1, 0, 0,
		0, 851, 852, 1, 0, 0, 0, 852, 13, 1, 0, 0, 0, 853, 854, 3, 556, 278, 0,
		854, 855, 3, 740, 370, 0, 855, 15, 1, 0, 0, 0, 856, 857, 3, 556, 278, 0,
		857, 861, 3, 20, 10, 0, 858, 859, 3, 576, 288, 0, 859, 860, 3, 22, 11,
		0, 860, 862, 1, 0, 0, 0, 861, 858, 1, 0, 0, 0, 861, 862, 1, 0, 0, 0, 862,
		866, 1, 0, 0, 0, 863, 864, 3, 574, 287, 0, 864, 865, 3, 430, 215, 0, 865,
		867, 1, 0, 0, 0, 866, 863, 1, 0, 0, 0, 866, 867, 1, 0, 0, 0, 867, 17, 1,
		0, 0, 0, 868, 869, 3, 524, 262, 0, 869, 870, 3, 20, 10, 0, 870, 871, 3,
		576, 288, 0, 871, 872, 3, 22, 11, 0, 872, 873, 3, 616, 308, 0, 873, 874,
		3, 430, 215, 0, 874, 19, 1, 0, 0, 0, 875, 878, 3, 460, 230, 0, 876, 878,
		3, 462, 231, 0, 877, 875, 1, 0, 0, 0, 877, 876, 1, 0, 0, 0, 878, 889, 1,
		0, 0, 0, 879, 889, 3, 466, 233, 0, 880, 889, 3, 476, 238, 0, 881, 889,
		3, 498, 249, 0, 882, 889, 3, 508, 254, 0, 883, 889, 3, 492, 246, 0, 884,
		889, 3, 502, 251, 0, 885, 889, 3, 564, 282, 0, 886, 889, 3, 600, 300, 0,
		887, 889, 3, 748, 374, 0, 888, 877, 1, 0, 0, 0, 888, 879, 1, 0, 0, 0, 888,
		880, 1, 0, 0, 0, 888, 881, 1, 0, 0, 0, 888, 882, 1, 0, 0, 0, 888, 883,
		1, 0, 0, 0, 888, 884, 1, 0, 0, 0, 888, 885, 1, 0, 0, 0, 888, 886, 1, 0,
		0, 0, 888, 887, 1, 0, 0, 0, 889, 21, 1, 0, 0, 0, 890, 891, 3, 460, 230,
		0, 891, 892, 3, 522, 261, 0, 892, 929, 1, 0, 0, 0, 893, 894, 3, 460, 230,
		0, 894, 895, 3, 522, 261, 0, 895, 896, 3, 528, 264, 0, 896, 897, 3, 548,
		274, 0, 897, 898, 3, 406, 203, 0, 898, 929, 1, 0, 0, 0, 899, 903, 3, 520,
		260, 0, 900, 901, 3, 406, 203, 0, 901, 902, 5, 10, 0, 0, 902, 904, 1, 0,
		0, 0, 903, 900, 1, 0, 0, 0, 903, 904, 1, 0, 0, 0, 904, 905, 1, 0, 0, 0,
		905, 906, 3, 442, 221, 0, 906, 929, 1, 0, 0, 0, 907, 908, 3, 460, 230,
		0, 908, 909, 3, 550, 275, 0, 909, 929, 1, 0, 0, 0, 910, 911, 3, 548, 274,
		0, 911, 912, 3, 406, 203, 0, 912, 929, 1, 0, 0, 0, 913, 915, 3, 612, 306,
		0, 914, 913, 1, 0, 0, 0, 914, 915, 1, 0, 0, 0, 915, 919, 1, 0, 0, 0, 916,
		917, 3, 406, 203, 0, 917, 918, 5, 10, 0, 0, 918, 920, 1, 0, 0, 0, 919,
		916, 1, 0, 0, 0, 919, 920, 1, 0, 0, 0, 920, 921, 1, 0, 0, 0, 921, 929,
		3, 408, 204, 0, 922, 923, 3, 460, 230, 0, 923, 924, 3, 598, 299, 0, 924,
		929, 1, 0, 0, 0, 925, 926, 3, 596, 298, 0, 926, 927, 3, 430, 215, 0, 927,
		929, 1, 0, 0, 0, 928, 890, 1, 0, 0, 0, 928, 893, 1, 0, 0, 0, 928, 899,
		1, 0, 0, 0, 928, 907, 1, 0, 0, 0, 928, 910, 1, 0, 0, 0, 928, 914, 1, 0,
		0, 0, 928, 922, 1, 0, 0, 0, 928, 925, 1, 0, 0, 0, 929, 23, 1, 0, 0, 0,
		930, 931, 3, 492, 246, 0, 931, 933, 3, 632, 316, 0, 932, 934, 3, 288, 144,
		0, 933, 932, 1, 0, 0, 0, 933, 934, 1, 0, 0, 0, 934, 935, 1, 0, 0, 0, 935,
		936, 3, 446, 223, 0, 936, 937, 3, 642, 321, 0, 937, 938, 3, 584, 292, 0,
		938, 941, 3, 400, 200, 0, 939, 942, 3, 610, 305, 0, 940, 942, 3, 566, 283,
		0, 941, 939, 1, 0, 0, 0, 941, 940, 1, 0, 0, 0, 941, 942, 1, 0, 0, 0, 942,
		25, 1, 0, 0, 0, 943, 944, 3, 492, 246, 0, 944, 946, 3, 596, 298, 0, 945,
		947, 3, 288, 144, 0, 946, 945, 1, 0, 0, 0, 946, 947, 1, 0, 0, 0, 947, 948,
		1, 0, 0, 0, 948, 950, 3, 430, 215, 0, 949, 951, 3, 112, 56, 0, 950, 949,
		1, 0, 0, 0, 950, 951, 1, 0, 0, 0, 951, 27, 1, 0, 0, 0, 952, 953, 3, 492,
		246, 0, 953, 955, 3, 624, 312, 0, 954, 956, 3, 288, 144, 0, 955, 954, 1,
		0, 0, 0, 955, 956, 1, 0, 0, 0, 956, 960, 1, 0, 0, 0, 957, 958, 3, 406,
		203, 0, 958, 959, 5, 10, 0, 0, 959, 961, 1, 0, 0, 0, 960, 957, 1, 0, 0,
		0, 960, 961, 1, 0, 0, 0, 961, 962, 1, 0, 0, 0, 962, 963, 3, 438, 219, 0,
		963, 964, 3, 646, 323, 0, 964, 965, 3, 30, 15, 0, 965, 966, 3, 648, 324,
		0, 966, 29, 1, 0, 0, 0, 967, 968, 3, 410, 205, 0, 968, 975, 3, 420, 210,
		0, 969, 970, 3, 662, 331, 0, 970, 971, 3, 410, 205, 0, 971, 972, 3, 420,
		210, 0, 972, 974, 1, 0, 0, 0, 973, 969, 1, 0, 0, 0, 974, 977, 1, 0, 0,
		0, 975, 973, 1, 0, 0, 0, 975, 976, 1, 0, 0, 0, 976, 31, 1, 0, 0, 0, 977,
		975, 1, 0, 0, 0, 978, 979, 3, 492, 246, 0, 979, 981, 3, 618, 309, 0, 980,
		982, 3, 288, 144, 0, 981, 980, 1, 0, 0, 0, 981, 982, 1, 0, 0, 0, 982, 986,
		1, 0, 0, 0, 983, 984, 3, 406, 203, 0, 984, 985, 5, 10, 0, 0, 985, 987,
		1, 0, 0, 0, 986, 983, 1, 0, 0, 0, 986, 987, 1, 0, 0, 0, 987, 988, 1, 0,
		0, 0, 988, 989, 3, 432, 216, 0, 989, 990, 3, 634, 317, 0, 990, 991, 3,
		434, 217, 0, 991, 33, 1, 0, 0, 0, 992, 993, 3, 492, 246, 0, 993, 994, 3,
		562, 281, 0, 994, 996, 3, 638, 319, 0, 995, 997, 3, 288, 144, 0, 996, 995,
		1, 0, 0, 0, 996, 997, 1, 0, 0, 0, 997, 1001, 1, 0, 0, 0, 998, 999, 3, 406,
		203, 0, 999, 1000, 5, 10, 0, 0, 1000, 1002, 1, 0, 0, 0, 1001, 998, 1, 0,
		0, 0, 1001, 1002, 1, 0, 0, 0, 1002, 1003, 1, 0, 0, 0, 1003, 1004, 3, 436,
		218, 0, 1004, 1005, 3, 472, 236, 0, 1005, 1006, 3, 600, 300, 0, 1006, 1007,
		3, 368, 184, 0, 1007, 1009, 3, 354, 177, 0, 1008, 1010, 3, 36, 18, 0, 1009,
		1008, 1, 0, 0, 0, 1009, 1010, 1, 0, 0, 0, 1010, 1011, 1, 0, 0, 0, 1011,
		1015, 3, 168, 84, 0, 1012, 1013, 3, 642, 321, 0, 1013, 1014, 3, 46, 23,
		0, 1014, 1016, 1, 0, 0, 0, 1015, 1012, 1, 0, 0, 0, 1015, 1016, 1, 0, 0,
		0, 1016, 35, 1, 0, 0, 0, 1017, 1018, 3, 640, 320, 0, 1018, 1024, 3, 38,
		19, 0, 1019, 1020, 3, 468, 234, 0, 1020, 1021, 3, 38, 19, 0, 1021, 1023,
		1, 0, 0, 0, 1022, 1019, 1, 0, 0, 0, 1023, 1026, 1, 0, 0, 0, 1024, 1022,
		1, 0, 0, 0, 1024, 1025, 1, 0, 0, 0, 1025, 37, 1, 0, 0, 0, 1026, 1024, 1,
		0, 0, 0, 1027, 1028, 3, 414, 207, 0, 1028, 1029, 3, 540, 270, 0, 1029,
		1030, 3, 570, 285, 0, 1030, 1031, 3, 572, 286, 0, 1031, 1037, 1, 0, 0,
		0, 1032, 1033, 3, 414, 207, 0, 1033, 1034, 7, 0, 0, 0, 1034, 1035, 3, 390,
		195, 0, 1035, 1037, 1, 0, 0, 0, 1036, 1027, 1, 0, 0, 0, 1036, 1032, 1,
		0, 0, 0, 1037, 39, 1, 0, 0, 0, 1038, 1039, 3, 640, 320, 0, 1039, 1043,
		3, 42, 21, 0, 1040, 1041, 3, 468, 234, 0, 1041, 1042, 3, 372, 186, 0, 1042,
		1044, 1, 0, 0, 0, 1043, 1040, 1, 0, 0, 0, 1043, 1044, 1, 0, 0, 0, 1044,
		41, 1, 0, 0, 0, 1045, 1051, 3, 44, 22, 0, 1046, 1047, 3, 468, 234, 0, 1047,
		1048, 3, 44, 22, 0, 1048, 1050, 1, 0, 0, 0, 1049, 1046, 1, 0, 0, 0, 1050,
		1053, 1, 0, 0, 0, 1051, 1049, 1, 0, 0, 0, 1051, 1052, 1, 0, 0, 0, 1052,
		43, 1, 0, 0, 0, 1053, 1051, 1, 0, 0, 0, 1054, 1055, 3, 410, 205, 0, 1055,
		1056, 3, 540, 270, 0, 1056, 1057, 3, 570, 285, 0, 1057, 1058, 3, 572, 286,
		0, 1058, 45, 1, 0, 0, 0, 1059, 1066, 3, 142, 71, 0, 1060, 1061, 3, 142,
		71, 0, 1061, 1062, 3, 468, 234, 0, 1062, 1063, 3, 144, 72, 0, 1063, 1066,
		1, 0, 0, 0, 1064, 1066, 3, 144, 72, 0, 1065, 1059, 1, 0, 0, 0, 1065, 1060,
		1, 0, 0, 0, 1065, 1064, 1, 0, 0, 0, 1066, 47, 1, 0, 0, 0, 1067, 1068, 3,
		492, 246, 0, 1068, 1070, 3, 548, 274, 0, 1069, 1071, 3, 288, 144, 0, 1070,
		1069, 1, 0, 0, 0, 1070, 1071, 1, 0, 0, 0, 1071, 1072, 1, 0, 0, 0, 1072,
		1073, 3, 406, 203, 0, 1073, 1074, 3, 642, 321, 0, 1074, 1075, 3, 592, 296,
		0, 1075, 1076, 5, 19, 0, 0, 1076, 1077, 3, 650, 325, 0, 1077, 1078, 3,
		206, 103, 0, 1078, 1082, 3, 652, 326, 0, 1079, 1080, 3, 468, 234, 0, 1080,
		1081, 3, 210, 105, 0, 1081, 1083, 1, 0, 0, 0, 1082, 1079, 1, 0, 0, 0, 1082,
		1083, 1, 0, 0, 0, 1083, 1087, 1, 0, 0, 0, 1084, 1085, 3, 468, 234, 0, 1085,
		1086, 3, 212, 106, 0, 1086, 1088, 1, 0, 0, 0, 1087, 1084, 1, 0, 0, 0, 1087,
		1088, 1, 0, 0, 0, 1088, 49, 1, 0, 0, 0, 1089, 1091, 3, 492, 246, 0, 1090,
		1092, 3, 70, 35, 0, 1091, 1090, 1, 0, 0, 0, 1091, 1092, 1, 0, 0, 0, 1092,
		1093, 1, 0, 0, 0, 1093, 1095, 3, 520, 260, 0, 1094, 1096, 3, 288, 144,
		0, 1095, 1094, 1, 0, 0, 0, 1095, 1096, 1, 0, 0, 0, 1096, 1100, 1, 0, 0,
		0, 1097, 1098, 3, 406, 203, 0, 1098, 1099, 5, 10, 0, 0, 1099, 1101, 1,
		0, 0, 0, 1100, 1097, 1, 0, 0, 0, 1100, 1101, 1, 0, 0, 0, 1101, 1102, 1,
		0, 0, 0, 1102, 1103, 3, 442, 221, 0, 1103, 1105, 3, 646, 323, 0, 1104,
		1106, 3, 54, 27, 0, 1105, 1104, 1, 0, 0, 0, 1105, 1106, 1, 0, 0, 0, 1106,
		1107, 1, 0, 0, 0, 1107, 1108, 3, 648, 324, 0, 1108, 1109, 3, 56, 28, 0,
		1109, 1110, 3, 594, 297, 0, 1110, 1111, 3, 420, 210, 0, 1111, 1112, 3,
		552, 276, 0, 1112, 1113, 3, 444, 222, 0, 1113, 1114, 3, 472, 236, 0, 1114,
		1115, 3, 52, 26, 0, 1115, 51, 1, 0, 0, 0, 1116, 1117, 7, 1, 0, 0, 1117,
		53, 1, 0, 0, 0, 1118, 1124, 3, 452, 226, 0, 1119, 1120, 3, 662, 331, 0,
		1120, 1121, 3, 452, 226, 0, 1121, 1123, 1, 0, 0, 0, 1122, 1119, 1, 0, 0,
		0, 1123, 1126, 1, 0, 0, 0, 1124, 1122, 1, 0, 0, 0, 1124, 1125, 1, 0, 0,
		0, 1125, 55, 1, 0, 0, 0, 1126, 1124, 1, 0, 0, 0, 1127, 1132, 3, 484, 242,
		0, 1128, 1129, 3, 594, 297, 0, 1129, 1130, 3, 572, 286, 0, 1130, 1132,
		1, 0, 0, 0, 1131, 1127, 1, 0, 0, 0, 1131, 1128, 1, 0, 0, 0, 1132, 1133,
		1, 0, 0, 0, 1133, 1134, 3, 576, 288, 0, 1134, 1135, 3, 572, 286, 0, 1135,
		1136, 3, 534, 267, 0, 1136, 57, 1, 0, 0, 0, 1137, 1139, 3, 492, 246, 0,
		1138, 1140, 3, 70, 35, 0, 1139, 1138, 1, 0, 0, 0, 1139, 1140, 1, 0, 0,
		0, 1140, 1141, 1, 0, 0, 0, 1141, 1143, 3, 458, 229, 0, 1142, 1144, 3, 288,
		144, 0, 1143, 1142, 1, 0, 0, 0, 1143, 1144, 1, 0, 0, 0, 1144, 1148, 1,
		0, 0, 0, 1145, 1146, 3, 406, 203, 0, 1146, 1147, 5, 10, 0, 0, 1147, 1149,
		1, 0, 0, 0, 1148, 1145, 1, 0, 0, 0, 1148, 1149, 1, 0, 0, 0, 1149, 1150,
		1, 0, 0, 0, 1150, 1151, 3, 440, 220, 0, 1151, 1152, 3, 646, 323, 0, 1152,
		1153, 3, 420, 210, 0, 1153, 1154, 3, 648, 324, 0, 1154, 1155, 3, 604, 302,
		0, 1155, 1156, 3, 442, 221, 0, 1156, 1157, 3, 608, 304, 0, 1157, 1161,
		3, 420, 210, 0, 1158, 1159, 3, 736, 368, 0, 1159, 1160, 3, 442, 221, 0,
		1160, 1162, 1, 0, 0, 0, 1161, 1158, 1, 0, 0, 0, 1161, 1162, 1, 0, 0, 0,
		1162, 1166, 1, 0, 0, 0, 1163, 1164, 3, 514, 257, 0, 1164, 1165, 3, 442,
		221, 0, 1165, 1167, 1, 0, 0, 0, 1166, 1163, 1, 0, 0, 0, 1166, 1167, 1,
		0, 0, 0, 1167, 1171, 1, 0, 0, 0, 1168, 1169, 3, 532, 266, 0, 1169, 1170,
		3, 60, 30, 0, 1170, 1172, 1, 0, 0, 0, 1171, 1168, 1, 0, 0, 0, 1171, 1172,
		1, 0, 0, 0, 1172, 59, 1, 0, 0, 0, 1173, 1178, 3, 390, 195, 0, 1174, 1178,
		3, 68, 34, 0, 1175, 1178, 3, 66, 33, 0, 1176, 1178, 3, 62, 31, 0, 1177,
		1173, 1, 0, 0, 0, 1177, 1174, 1, 0, 0, 0, 1177, 1175, 1, 0, 0, 0, 1177,
		1176, 1, 0, 0, 0, 1178, 61, 1, 0, 0, 0, 1179, 1180, 3, 650, 325, 0, 1180,
		1186, 3, 64, 32, 0, 1181, 1182, 3, 662, 331, 0, 1182, 1183, 3, 64, 32,
		0, 1183, 1185, 1, 0, 0, 0, 1184, 1181, 1, 0, 0, 0, 1185, 1188, 1, 0, 0,
		0, 1186, 1184, 1, 0, 0, 0, 1186, 1187, 1, 0, 0, 0, 1187, 1189, 1, 0, 0,
		0, 1188, 1186, 1, 0, 0, 0, 1189, 1190, 3, 652, 326, 0, 1190, 63, 1, 0,
		0, 0, 1191, 1192, 3, 450, 225, 0, 1192, 1193, 5, 9, 0, 0, 1193, 1194, 3,
		60, 30, 0, 1194, 65, 1, 0, 0, 0, 1195, 1196, 3, 646, 323, 0, 1196, 1203,
		3, 68, 34, 0, 1197, 1198, 3, 662, 331, 0, 1198, 1199, 3, 390, 195, 0, 1199,
		1202, 1, 0, 0, 0, 1200, 1202, 3, 68, 34, 0, 1201, 1197, 1, 0, 0, 0, 1201,
		1200, 1, 0, 0, 0, 1202, 1205, 1, 0, 0, 0, 1203, 1201, 1, 0, 0, 0, 1203,
		1204, 1, 0, 0, 0, 1204, 1206, 1, 0, 0, 0, 1205, 1203, 1, 0, 0, 0, 1206,
		1207, 3, 648, 324, 0, 1207, 67, 1, 0, 0, 0, 1208, 1209, 3, 646, 323, 0,
		1209, 1215, 3, 390, 195, 0, 1210, 1211, 3, 662, 331, 0, 1211, 1212, 3,
		390, 195, 0, 1212, 1214, 1, 0, 0, 0, 1213, 1210, 1, 0, 0, 0, 1214, 1217,
		1, 0, 0, 0, 1215, 1213, 1, 0, 0, 0, 1215, 1216, 1, 0, 0, 0, 1216, 1218,
		1, 0, 0, 0, 1217, 1215, 1, 0, 0, 0, 1218, 1219, 3, 648, 324, 0, 1219, 69,
		1, 0, 0, 0, 1220, 1221, 3, 580, 290, 0, 1221, 1222, 3, 590, 295, 0, 1222,
		71, 1, 0, 0, 0, 1223, 1224, 3, 466, 233, 0, 1224, 1225, 3, 632, 316, 0,
		1225, 1226, 3, 446, 223, 0, 1226, 1227, 3, 642, 321, 0, 1227, 1229, 3,
		74, 37, 0, 1228, 1230, 3, 76, 38, 0, 1229, 1228, 1, 0, 0, 0, 1229, 1230,
		1, 0, 0, 0, 1230, 73, 1, 0, 0, 0, 1231, 1232, 3, 584, 292, 0, 1232, 1233,
		3, 400, 200, 0, 1233, 75, 1, 0, 0, 0, 1234, 1237, 3, 610, 305, 0, 1235,
		1237, 3, 566, 283, 0, 1236, 1234, 1, 0, 0, 0, 1236, 1235, 1, 0, 0, 0, 1237,
		77, 1, 0, 0, 0, 1238, 1239, 3, 466, 233, 0, 1239, 1243, 3, 624, 312, 0,
		1240, 1241, 3, 406, 203, 0, 1241, 1242, 5, 10, 0, 0, 1242, 1244, 1, 0,
		0, 0, 1243, 1240, 1, 0, 0, 0, 1243, 1244, 1, 0, 0, 0, 1244, 1245, 1, 0,
		0, 0, 1245, 1246, 3, 438, 219, 0, 1246, 1247, 3, 80, 40, 0, 1247, 79, 1,
		0, 0, 0, 1248, 1252, 3, 90, 45, 0, 1249, 1252, 3, 88, 44, 0, 1250, 1252,
		3, 82, 41, 0, 1251, 1248, 1, 0, 0, 0, 1251, 1249, 1, 0, 0, 0, 1251, 1250,
		1, 0, 0, 0, 1252, 81, 1, 0, 0, 0, 1253, 1254, 3, 588, 294, 0, 1254, 1255,
		3, 84, 42, 0, 1255, 83, 1, 0, 0, 0, 1256, 1262, 3, 86, 43, 0, 1257, 1258,
		3, 468, 234, 0, 1258, 1259, 3, 86, 43, 0, 1259, 1261, 1, 0, 0, 0, 1260,
		1257, 1, 0, 0, 0, 1261, 1264, 1, 0, 0, 0, 1262, 1260, 1, 0, 0, 0, 1262,
		1263, 1, 0, 0, 0, 1263, 85, 1, 0, 0, 0, 1264, 1262, 1, 0, 0, 0, 1265, 1266,
		3, 410, 205, 0, 1266, 1267, 3, 616, 308, 0, 1267, 1268, 3, 410, 205, 0,
		1268, 87, 1, 0, 0, 0, 1269, 1270, 3, 456, 228, 0, 1270, 1271, 3, 410, 205,
		0, 1271, 1278, 3, 420, 210, 0, 1272, 1273, 3, 662, 331, 0, 1273, 1274,
		3, 410, 205, 0, 1274, 1275, 3, 420, 210, 0, 1275, 1277, 1, 0, 0, 0, 1276,
		1272, 1, 0, 0, 0, 1277, 1280, 1, 0, 0, 0, 1278, 1276, 1, 0, 0, 0, 1278,
		1279, 1, 0, 0, 0, 1279, 89, 1, 0, 0, 0, 1280, 1278, 1, 0, 0, 0, 1281, 1282,
		3, 466, 233, 0, 1282, 1283, 3, 410, 205, 0, 1283, 1284, 3, 624, 312, 0,
		1284, 1285, 3, 420, 210, 0, 1285, 91, 1, 0, 0, 0, 1286, 1287, 3, 466, 233,
		0, 1287, 1291, 3, 612, 306, 0, 1288, 1289, 3, 406, 203, 0, 1289, 1290,
		5, 10, 0, 0, 1290, 1292, 1, 0, 0, 0, 1291, 1288, 1, 0, 0, 0, 1291, 1292,
		1, 0, 0, 0, 1292, 1293, 1, 0, 0, 0, 1293, 1294, 3, 408, 204, 0, 1294, 1295,
		3, 94, 47, 0, 1295, 93, 1, 0, 0, 0, 1296, 1302, 3, 106, 53, 0, 1297, 1302,
		3, 102, 51, 0, 1298, 1302, 3, 100, 50, 0, 1299, 1302, 3, 98, 49, 0, 1300,
		1302, 3, 96, 48, 0, 1301, 1296, 1, 0, 0, 0, 1301, 1297, 1, 0, 0, 0, 1301,
		1298, 1, 0, 0, 0, 1301, 1299, 1, 0, 0, 0, 1301, 1300, 1, 0, 0, 0, 1302,
		95, 1, 0, 0, 0, 1303, 1304, 3, 642, 321, 0, 1304, 1305, 3, 142, 71, 0,
		1305, 97, 1, 0, 0, 0, 1306, 1307, 3, 588, 294, 0, 1307, 1308, 3, 410, 205,
		0, 1308, 1309, 3, 616, 308, 0, 1309, 1310, 3, 410, 205, 0, 1310, 99, 1,
		0, 0, 0, 1311, 1312, 3, 502, 251, 0, 1312, 1313, 3, 488, 244, 0, 1313,
		1314, 3, 606, 303, 0, 1314, 101, 1, 0, 0, 0, 1315, 1316, 3, 502, 251, 0,
		1316, 1317, 3, 104, 52, 0, 1317, 103, 1, 0, 0, 0, 1318, 1324, 3, 410, 205,
		0, 1319, 1320, 3, 662, 331, 0, 1320, 1321, 3, 410, 205, 0, 1321, 1323,
		1, 0, 0, 0, 1322, 1319, 1, 0, 0, 0, 1323, 1326, 1, 0, 0, 0, 1324, 1322,
		1, 0, 0, 0, 1324, 1325, 1, 0, 0, 0, 1325, 105, 1, 0, 0, 0, 1326, 1324,
		1, 0, 0, 0, 1327, 1328, 3, 456, 228, 0, 1328, 1329, 3, 410, 205, 0, 1329,
		1331, 3, 420, 210, 0, 1330, 1332, 3, 166, 83, 0, 1331, 1330, 1, 0, 0, 0,
		1331, 1332, 1, 0, 0, 0, 1332, 1347, 1, 0, 0, 0, 1333, 1334, 3, 456, 228,
		0, 1334, 1335, 3, 646, 323, 0, 1335, 1341, 3, 162, 81, 0, 1336, 1337, 3,
		662, 331, 0, 1337, 1338, 3, 162, 81, 0, 1338, 1340, 1, 0, 0, 0, 1339, 1336,
		1, 0, 0, 0, 1340, 1343, 1, 0, 0, 0, 1341, 1339, 1, 0, 0, 0, 1341, 1342,
		1, 0, 0, 0, 1342, 1344, 1, 0, 0, 0, 1343, 1341, 1, 0, 0, 0, 1344, 1345,
		3, 648, 324, 0, 1345, 1347, 1, 0, 0, 0, 1346, 1327, 1, 0, 0, 0, 1346, 1333,
		1, 0, 0, 0, 1347, 107, 1, 0, 0, 0, 1348, 1349, 3, 410, 205, 0, 1349, 1356,
		3, 420, 210, 0, 1350, 1351, 3, 662, 331, 0, 1351, 1352, 3, 410, 205, 0,
		1352, 1353, 3, 420, 210, 0, 1353, 1355, 1, 0, 0, 0, 1354, 1350, 1, 0, 0,
		0, 1355, 1358, 1, 0, 0, 0, 1356, 1354, 1, 0, 0, 0, 1356, 1357, 1, 0, 0,
		0, 1357, 109, 1, 0, 0, 0, 1358, 1356, 1, 0, 0, 0, 1359, 1360, 3, 466, 233,
		0, 1360, 1361, 3, 596, 298, 0, 1361, 1363, 3, 430, 215, 0, 1362, 1364,
		3, 112, 56, 0, 1363, 1362, 1, 0, 0, 0, 1363, 1364, 1, 0, 0, 0, 1364, 111,
		1, 0, 0, 0, 1365, 1366, 3, 642, 321, 0, 1366, 1372, 3, 114, 57, 0, 1367,
		1368, 3, 468, 234, 0, 1368, 1369, 3, 114, 57, 0, 1369, 1371, 1, 0, 0, 0,
		1370, 1367, 1, 0, 0, 0, 1371, 1374, 1, 0, 0, 0, 1372, 1370, 1, 0, 0, 0,
		1372, 1373, 1, 0, 0, 0, 1373, 113, 1, 0, 0, 0, 1374, 1372, 1, 0, 0, 0,
		1375, 1376, 3, 584, 292, 0, 1376, 1377, 5, 19, 0, 0, 1377, 1378, 3, 400,
		200, 0, 1378, 1401, 1, 0, 0, 0, 1379, 1380, 3, 742, 371, 0, 1380, 1381,
		3, 584, 292, 0, 1381, 1382, 5, 19, 0, 0, 1382, 1383, 3, 400, 200, 0, 1383,
		1401, 1, 0, 0, 0, 1384, 1385, 3, 560, 280, 0, 1385, 1386, 5, 19, 0, 0,
		1386, 1387, 3, 402, 201, 0, 1387, 1401, 1, 0, 0, 0, 1388, 1389, 3, 610,
		305, 0, 1389, 1390, 5, 19, 0, 0, 1390, 1391, 3, 402, 201, 0, 1391, 1401,
		1, 0, 0, 0, 1392, 1393, 3, 578, 289, 0, 1393, 1394, 5, 19, 0, 0, 1394,
		1395, 3, 152, 76, 0, 1395, 1401, 1, 0, 0, 0, 1396, 1397, 3, 738, 369, 0,
		1397, 1398, 5, 19, 0, 0, 1398, 1399, 3, 402, 201, 0, 1399, 1401, 1, 0,
		0, 0, 1400, 1375, 1, 0, 0, 0, 1400, 1379, 1, 0, 0, 0, 1400, 1384, 1, 0,
		0, 0, 1400, 1388, 1, 0, 0, 0, 1400, 1392, 1, 0, 0, 0, 1400, 1396, 1, 0,
		0, 0, 1401, 115, 1, 0, 0, 0, 1402, 1403, 3, 466, 233, 0, 1403, 1404, 3,
		562, 281, 0, 1404, 1408, 3, 638, 319, 0, 1405, 1406, 3, 406, 203, 0, 1406,
		1407, 5, 10, 0, 0, 1407, 1409, 1, 0, 0, 0, 1408, 1405, 1, 0, 0, 0, 1408,
		1409, 1, 0, 0, 0, 1409, 1410, 1, 0, 0, 0, 1410, 1414, 3, 436, 218, 0, 1411,
		1412, 3, 642, 321, 0, 1412, 1413, 3, 142, 71, 0, 1413, 1415, 1, 0, 0, 0,
		1414, 1411, 1, 0, 0, 0, 1414, 1415, 1, 0, 0, 0, 1415, 117, 1, 0, 0, 0,
		1416, 1417, 3, 502, 251, 0, 1417, 1419, 3, 632, 316, 0, 1418, 1420, 3,
		290, 145, 0, 1419, 1418, 1, 0, 0, 0, 1419, 1420, 1, 0, 0, 0, 1420, 1421,
		1, 0, 0, 0, 1421, 1422, 3, 446, 223, 0, 1422, 119, 1, 0, 0, 0, 1423, 1424,
		3, 502, 251, 0, 1424, 1426, 3, 624, 312, 0, 1425, 1427, 3, 290, 145, 0,
		1426, 1425, 1, 0, 0, 0, 1426, 1427, 1, 0, 0, 0, 1427, 1431, 1, 0, 0, 0,
		1428, 1429, 3, 406, 203, 0, 1429, 1430, 5, 10, 0, 0, 1430, 1432, 1, 0,
		0, 0, 1431, 1428, 1, 0, 0, 0, 1431, 1432, 1, 0, 0, 0, 1432, 1433, 1, 0,
		0, 0, 1433, 1434, 3, 438, 219, 0, 1434, 121, 1, 0, 0, 0, 1435, 1436, 3,
		502, 251, 0, 1436, 1437, 3, 562, 281, 0, 1437, 1439, 3, 638, 319, 0, 1438,
		1440, 3, 290, 145, 0, 1439, 1438, 1, 0, 0, 0, 1439, 1440, 1, 0, 0, 0, 1440,
		1444, 1, 0, 0, 0, 1441, 1442, 3, 406, 203, 0, 1442, 1443, 5, 10, 0, 0,
		1443, 1445, 1, 0, 0, 0, 1444, 1441, 1, 0, 0, 0, 1444, 1445, 1, 0, 0, 0,
		1445, 1446, 1, 0, 0, 0, 1446, 1447, 3, 436, 218, 0, 1447, 123, 1, 0, 0,
		0, 1448, 1449, 3, 502, 251, 0, 1449, 1451, 3, 458, 229, 0, 1450, 1452,
		3, 290, 145, 0, 1451, 1450, 1, 0, 0, 0, 1451, 1452, 1, 0, 0, 0, 1452, 1456,
		1, 0, 0, 0, 1453, 1454, 3, 406, 203, 0, 1454, 1455, 5, 10, 0, 0, 1455,
		1457, 1, 0, 0, 0, 1456, 1453, 1, 0, 0, 0, 1456, 1457, 1, 0, 0, 0, 1457,
		1458, 1, 0, 0, 0, 1458, 1463, 3, 440, 220, 0, 1459, 1460, 3, 646, 323,
		0, 1460, 1461, 3, 420, 210, 0, 1461, 1462, 3, 648, 324, 0, 1462, 1464,
		1, 0, 0, 0, 1463, 1459, 1, 0, 0, 0, 1463, 1464, 1, 0, 0, 0, 1464, 125,
		1, 0, 0, 0, 1465, 1466, 3, 502, 251, 0, 1466, 1468, 3, 520, 260, 0, 1467,
		1469, 3, 290, 145, 0, 1468, 1467, 1, 0, 0, 0, 1468, 1469, 1, 0, 0, 0, 1469,
		1473, 1, 0, 0, 0, 1470, 1471, 3, 406, 203, 0, 1471, 1472, 5, 10, 0, 0,
		1472, 1474, 1, 0, 0, 0, 1473, 1470, 1, 0, 0, 0, 1473, 1474, 1, 0, 0, 0,
		1474, 1475, 1, 0, 0, 0, 1475, 1476, 3, 442, 221, 0, 1476, 127, 1, 0, 0,
		0, 1477, 1478, 3, 502, 251, 0, 1478, 1480, 3, 618, 309, 0, 1479, 1481,
		3, 290, 145, 0, 1480, 1479, 1, 0, 0, 0, 1480, 1481, 1, 0, 0, 0, 1481, 1482,
		1, 0, 0, 0, 1482, 1483, 3, 432, 216, 0, 1483, 1487, 3, 576, 288, 0, 1484,
		1485, 3, 406, 203, 0, 1485, 1486, 5, 10, 0, 0, 1486, 1488, 1, 0, 0, 0,
		1487, 1484, 1, 0, 0, 0, 1487, 1488, 1, 0, 0, 0, 1488, 1489, 1, 0, 0, 0,
		1489, 1490, 3, 408, 204, 0, 1490, 129, 1, 0, 0, 0, 1491, 1492, 3, 502,
		251, 0, 1492, 1494, 3, 596, 298, 0, 1493, 1495, 3, 290, 145, 0, 1494, 1493,
		1, 0, 0, 0, 1494, 1495, 1, 0, 0, 0, 1495, 1496, 1, 0, 0, 0, 1496, 1497,
		3, 430, 215, 0, 1497, 131, 1, 0, 0, 0, 1498, 1499, 3, 502, 251, 0, 1499,
		1501, 3, 612, 306, 0, 1500, 1502, 3, 290, 145, 0, 1501, 1500, 1, 0, 0,
		0, 1501, 1502, 1, 0, 0, 0, 1502, 1506, 1, 0, 0, 0, 1503, 1504, 3, 406,
		203, 0, 1504, 1505, 5, 10, 0, 0, 1505, 1507, 1, 0, 0, 0, 1506, 1503, 1,
		0, 0, 0, 1506, 1507, 1, 0, 0, 0, 1507, 1508, 1, 0, 0, 0, 1508, 1509, 3,
		408, 204, 0, 1509, 133, 1, 0, 0, 0, 1510, 1511, 3, 502, 251, 0, 1511, 1513,
		3, 548, 274, 0, 1512, 1514, 3, 290, 145, 0, 1513, 1512, 1, 0, 0, 0, 1513,
		1514, 1, 0, 0, 0, 1514, 1515, 1, 0, 0, 0, 1515, 1516, 3, 406, 203, 0, 1516,
		135, 1, 0, 0, 0, 1517, 1518, 3, 502, 251, 0, 1518, 1520, 3, 530, 265, 0,
		1519, 1521, 3, 290, 145, 0, 1520, 1519, 1, 0, 0, 0, 1520, 1521, 1, 0, 0,
		0, 1521, 1525, 1, 0, 0, 0, 1522, 1523, 3, 406, 203, 0, 1523, 1524, 5, 10,
		0, 0, 1524, 1526, 1, 0, 0, 0, 1525, 1522, 1, 0, 0, 0, 1525, 1526, 1, 0,
		0, 0, 1526, 1527, 1, 0, 0, 0, 1527, 1528, 3, 228, 114, 0, 1528, 137, 1,
		0, 0, 0, 1529, 1530, 3, 492, 246, 0, 1530, 1532, 3, 612, 306, 0, 1531,
		1533, 3, 288, 144, 0, 1532, 1531, 1, 0, 0, 0, 1532, 1533, 1, 0, 0, 0, 1533,
		1537, 1, 0, 0, 0, 1534, 1535, 3, 406, 203, 0, 1535, 1536, 5, 10, 0, 0,
		1536, 1538, 1, 0, 0, 0, 1537, 1534, 1, 0, 0, 0, 1537, 1538, 1, 0, 0, 0,
		1538, 1539, 1, 0, 0, 0, 1539, 1540, 3, 408, 204, 0, 1540, 1541, 3, 646,
		323, 0, 1541, 1542, 3, 160, 80, 0, 1542, 1544, 3, 648, 324, 0, 1543, 1545,
		3, 140, 70, 0, 1544, 1543, 1, 0, 0, 0, 1544, 1545, 1, 0, 0, 0, 1545, 139,
		1, 0, 0, 0, 1546, 1547, 3, 642, 321, 0, 1547, 1548, 3, 142, 71, 0, 1548,
		141, 1, 0, 0, 0, 1549, 1550, 3, 488, 244, 0, 1550, 1554, 3, 606, 303, 0,
		1551, 1552, 3, 468, 234, 0, 1552, 1553, 3, 142, 71, 0, 1553, 1555, 1, 0,
		0, 0, 1554, 1551, 1, 0, 0, 0, 1554, 1555, 1, 0, 0, 0, 1555, 1572, 1, 0,
		0, 0, 1556, 1560, 3, 144, 72, 0, 1557, 1558, 3, 468, 234, 0, 1558, 1559,
		3, 142, 71, 0, 1559, 1561, 1, 0, 0, 0, 1560, 1557, 1, 0, 0, 0, 1560, 1561,
		1, 0, 0, 0, 1561, 1572, 1, 0, 0, 0, 1562, 1568, 3, 146, 73, 0, 1563, 1564,
		3, 468, 234, 0, 1564, 1565, 3, 146, 73, 0, 1565, 1567, 1, 0, 0, 0, 1566,
		1563, 1, 0, 0, 0, 1567, 1570, 1, 0, 0, 0, 1568, 1566, 1, 0, 0, 0, 1568,
		1569, 1, 0, 0, 0, 1569, 1572, 1, 0, 0, 0, 1570, 1568, 1, 0, 0, 0, 1571,
		1549, 1, 0, 0, 0, 1571, 1556, 1, 0, 0, 0, 1571, 1562, 1, 0, 0, 0, 1572,
		143, 1, 0, 0, 0, 1573, 1574, 3, 486, 243, 0, 1574, 1575, 3, 582, 291, 0,
		1575, 1576, 3, 482, 241, 0, 1576, 1577, 3, 646, 323, 0, 1577, 1579, 3,
		410, 205, 0, 1578, 1580, 3, 428, 214, 0, 1579, 1578, 1, 0, 0, 0, 1579,
		1580, 1, 0, 0, 0, 1580, 1588, 1, 0, 0, 0, 1581, 1582, 3, 662, 331, 0, 1582,
		1584, 3, 410, 205, 0, 1583, 1585, 3, 428, 214, 0, 1584, 1583, 1, 0, 0,
		0, 1584, 1585, 1, 0, 0, 0, 1585, 1587, 1, 0, 0, 0, 1586, 1581, 1, 0, 0,
		0, 1587, 1590, 1, 0, 0, 0, 1588, 1586, 1, 0, 0, 0, 1588, 1589, 1, 0, 0,
		0, 1589, 1591, 1, 0, 0, 0, 1590, 1588, 1, 0, 0, 0, 1591, 1592, 3, 648,
		324, 0, 1592, 145, 1, 0, 0, 0, 1593, 1594, 3, 148, 74, 0, 1594, 1595, 5,
		19, 0, 0, 1595, 1596, 3, 150, 75, 0, 1596, 1602, 1, 0, 0, 0, 1597, 1598,
		3, 148, 74, 0, 1598, 1599, 5, 19, 0, 0, 1599, 1600, 3, 152, 76, 0, 1600,
		1602, 1, 0, 0, 0, 1601, 1593, 1, 0, 0, 0, 1601, 1597, 1, 0, 0, 0, 1602,
		147, 1, 0, 0, 0, 1603, 1604, 5, 208, 0, 0, 1604, 149, 1, 0, 0, 0, 1605,
		1608, 3, 400, 200, 0, 1606, 1608, 3, 398, 199, 0, 1607, 1605, 1, 0, 0,
		0, 1607, 1606, 1, 0, 0, 0, 1608, 151, 1, 0, 0, 0, 1609, 1610, 3, 650, 325,
		0, 1610, 1616, 3, 154, 77, 0, 1611, 1612, 3, 662, 331, 0, 1612, 1613, 3,
		154, 77, 0, 1613, 1615, 1, 0, 0, 0, 1614, 1611, 1, 0, 0, 0, 1615, 1618,
		1, 0, 0, 0, 1616, 1614, 1, 0, 0, 0, 1616, 1617, 1, 0, 0, 0, 1617, 1619,
		1, 0, 0, 0, 1618, 1616, 1, 0, 0, 0, 1619, 1620, 3, 652, 326, 0, 1620, 153,
		1, 0, 0, 0, 1621, 1622, 3, 156, 78, 0, 1622, 1623, 5, 9, 0, 0, 1623, 1624,
		3, 158, 79, 0, 1624, 155, 1, 0, 0, 0, 1625, 1626, 3, 400, 200, 0, 1626,
		157, 1, 0, 0, 0, 1627, 1632, 3, 400, 200, 0, 1628, 1632, 3, 398, 199, 0,
		1629, 1632, 3, 402, 201, 0, 1630, 1632, 3, 396, 198, 0, 1631, 1627, 1,
		0, 0, 0, 1631, 1628, 1, 0, 0, 0, 1631, 1629, 1, 0, 0, 0, 1631, 1630, 1,
		0, 0, 0, 1632, 159, 1, 0, 0, 0, 1633, 1639, 3, 162, 81, 0, 1634, 1635,
		3, 662, 331, 0, 1635, 1636, 3, 162, 81, 0, 1636, 1638, 1, 0, 0, 0, 1637,
		1634, 1, 0, 0, 0, 1638, 1641, 1, 0, 0, 0, 1639, 1637, 1, 0, 0, 0, 1639,
		1640, 1, 0, 0, 0, 1640, 1645, 1, 0, 0, 0, 1641, 1639, 1, 0, 0, 0, 1642,
		1643, 3, 662, 331, 0, 1643, 1644, 3, 168, 84, 0, 1644, 1646, 1, 0, 0, 0,
		1645, 1642, 1, 0, 0, 0, 1645, 1646, 1, 0, 0, 0, 1646, 161, 1, 0, 0, 0,
		1647, 1648, 3, 410, 205, 0, 1648, 1650, 3, 420, 210, 0, 1649, 1651, 3,
		166, 83, 0, 1650, 1649, 1, 0, 0, 0, 1650, 1651, 1, 0, 0, 0, 1651, 1653,
		1, 0, 0, 0, 1652, 1654, 3, 164, 82, 0, 1653, 1652, 1, 0, 0, 0, 1653, 1654,
		1, 0, 0, 0, 1654, 163, 1, 0, 0, 0, 1655, 1656, 3, 586, 293, 0, 1656, 1657,
		3, 544, 272, 0, 1657, 165, 1, 0, 0, 0, 1658, 1659, 3, 680, 340, 0, 1659,
		167, 1, 0, 0, 0, 1660, 1661, 3, 586, 293, 0, 1661, 1662, 3, 544, 272, 0,
		1662, 1663, 3, 646, 323, 0, 1663, 1664, 3, 170, 85, 0, 1664, 1665, 3, 648,
		324, 0, 1665, 169, 1, 0, 0, 0, 1666, 1670, 3, 172, 86, 0, 1667, 1670, 3,
		174, 87, 0, 1668, 1670, 3, 176, 88, 0, 1669, 1666, 1, 0, 0, 0, 1669, 1667,
		1, 0, 0, 0, 1669, 1668, 1, 0, 0, 0, 1670, 171, 1, 0, 0, 0, 1671, 1672,
		3, 410, 205, 0, 1672, 173, 1, 0, 0, 0, 1673, 1674, 3, 182, 91, 0, 1674,
		1675, 3, 662, 331, 0, 1675, 1676, 3, 180, 90, 0, 1676, 175, 1, 0, 0, 0,
		1677, 1678, 3, 646, 323, 0, 1678, 1679, 3, 178, 89, 0, 1679, 1680, 3, 648,
		324, 0, 1680, 1681, 3, 662, 331, 0, 1681, 1682, 3, 180, 90, 0, 1682, 177,
		1, 0, 0, 0, 1683, 1689, 3, 182, 91, 0, 1684, 1685, 3, 662, 331, 0, 1685,
		1686, 3, 182, 91, 0, 1686, 1688, 1, 0, 0, 0, 1687, 1684, 1, 0, 0, 0, 1688,
		1691, 1, 0, 0, 0, 1689, 1687, 1, 0, 0, 0, 1689, 1690, 1, 0, 0, 0, 1690,
		179, 1, 0, 0, 0, 1691, 1689, 1, 0, 0, 0, 1692, 1698, 3, 184, 92, 0, 1693,
		1694, 3, 662, 331, 0, 1694, 1695, 3, 184, 92, 0, 1695, 1697, 1, 0, 0, 0,
		1696, 1693, 1, 0, 0, 0, 1697, 1700, 1, 0, 0, 0, 1698, 1696, 1, 0, 0, 0,
		1698, 1699, 1, 0, 0, 0, 1699, 181, 1, 0, 0, 0, 1700, 1698, 1, 0, 0, 0,
		1701, 1702, 3, 410, 205, 0, 1702, 183, 1, 0, 0, 0, 1703, 1704, 3, 410,
		205, 0, 1704, 185, 1, 0, 0, 0, 1705, 1706, 3, 470, 235, 0, 1706, 1707,
		3, 478, 239, 0, 1707, 187, 1, 0, 0, 0, 1708, 1710, 3, 480, 240, 0, 1709,
		1711, 3, 202, 101, 0, 1710, 1709, 1, 0, 0, 0, 1710, 1711, 1, 0, 0, 0, 1711,
		1712, 1, 0, 0, 0, 1712, 1714, 3, 478, 239, 0, 1713, 1715, 3, 286, 143,
		0, 1714, 1713, 1, 0, 0, 0, 1714, 1715, 1, 0, 0, 0, 1715, 1717, 1, 0, 0,
		0, 1716, 1718, 3, 190, 95, 0, 1717, 1716, 1, 0, 0, 0, 1717, 1718, 1, 0,
		0, 0, 1718, 1719, 1, 0, 0, 0, 1719, 1720, 3, 470, 235, 0, 1720, 1721, 3,
		478, 239, 0, 1721, 189, 1, 0, 0, 0, 1722, 1724, 3, 192, 96, 0, 1723, 1722,
		1, 0, 0, 0, 1724, 1725, 1, 0, 0, 0, 1725, 1723, 1, 0, 0, 0, 1725, 1726,
		1, 0, 0, 0, 1726, 191, 1, 0, 0, 0, 1727, 1731, 3, 194, 97, 0, 1728, 1731,
		3, 196, 98, 0, 1729, 1731, 3, 198, 99, 0, 1730, 1727, 1, 0, 0, 0, 1730,
		1728, 1, 0, 0, 0, 1730, 1729, 1, 0, 0, 0, 1731, 193, 1, 0, 0, 0, 1732,
		1733, 3, 536, 268, 0, 1733, 1737, 3, 538, 269, 0, 1734, 1735, 3, 406, 203,
		0, 1735, 1736, 5, 10, 0, 0, 1736, 1738, 1, 0, 0, 0, 1737, 1734, 1, 0, 0,
		0, 1737, 1738, 1, 0, 0, 0, 1738, 1739, 1, 0, 0, 0, 1739, 1741, 3, 408,
		204, 0, 1740, 1742, 3, 296, 148, 0, 1741, 1740, 1, 0, 0, 0, 1741, 1742,
		1, 0, 0, 0, 1742, 1743, 1, 0, 0, 0, 1743, 1745, 3, 292, 146, 0, 1744, 1746,
		3, 288, 144, 0, 1745, 1744, 1, 0, 0, 0, 1745, 1746, 1, 0, 0, 0, 1746, 1748,
		1, 0, 0, 0, 1747, 1749, 3, 280, 140, 0, 1748, 1747, 1, 0, 0, 0, 1748, 1749,
		1, 0, 0, 0, 1749, 195, 1, 0, 0, 0, 1750, 1754, 3, 628, 314, 0, 1751, 1752,
		3, 406, 203, 0, 1752, 1753, 5, 10, 0, 0, 1753, 1755, 1, 0, 0, 0, 1754,
		1751, 1, 0, 0, 0, 1754, 1755, 1, 0, 0, 0, 1755, 1756, 1, 0, 0, 0, 1756,
		1758, 3, 408, 204, 0, 1757, 1759, 3, 280, 140, 0, 1758, 1757, 1, 0, 0,
		0, 1758, 1759, 1, 0, 0, 0, 1759, 1760, 1, 0, 0, 0, 1760, 1761, 3, 602,
		301, 0, 1761, 1762, 3, 254, 127, 0, 1762, 1765, 3, 364, 182, 0, 1763, 1766,
		3, 290, 145, 0, 1764, 1766, 3, 246, 123, 0, 1765, 1763, 1, 0, 0, 0, 1765,
		1764, 1, 0, 0, 0, 1765, 1766, 1, 0, 0, 0, 1766, 197, 1, 0, 0, 0, 1767,
		1769, 3, 494, 247, 0, 1768, 1770, 3, 240, 120, 0, 1769, 1768, 1, 0, 0,
		0, 1769, 1770, 1, 0, 0, 0, 1770, 1771, 1, 0, 0, 0, 1771, 1773, 3, 354,
		177, 0, 1772, 1774, 3, 286, 143, 0, 1773, 1772, 1, 0, 0, 0, 1773, 1774,
		1, 0, 0, 0, 1774, 1775, 1, 0, 0, 0, 1775, 1778, 3, 364, 182, 0, 1776, 1779,
		3, 290, 145, 0, 1777, 1779, 3, 246, 123, 0, 1778, 1776, 1, 0, 0, 0, 1778,
		1777, 1, 0, 0, 0, 1778, 1779, 1, 0, 0, 0, 1779, 199, 1, 0, 0, 0, 1780,
		1782, 3, 480, 240, 0, 1781, 1783, 3, 202, 101, 0, 1782, 1781, 1, 0, 0,
		0, 1782, 1783, 1, 0, 0, 0, 1783, 1784, 1, 0, 0, 0, 1784, 1786, 3, 478,
		239, 0, 1785, 1787, 3, 286, 143, 0, 1786, 1785, 1, 0, 0, 0, 1786, 1787,
		1, 0, 0, 0, 1787, 201, 1, 0, 0, 0, 1788, 1792, 3, 558, 279, 0, 1789, 1792,
		3, 626, 313, 0, 1790, 1792, 3, 696, 348, 0, 1791, 1788, 1, 0, 0, 0, 1791,
		1789, 1, 0, 0, 0, 1791, 1790, 1, 0, 0, 0, 1792, 203, 1, 0, 0, 0, 1793,
		1794, 3, 466, 233, 0, 1794, 1795, 3, 548, 274, 0, 1795, 1796, 3, 406, 203,
		0, 1796, 1797, 3, 642, 321, 0, 1797, 1798, 3, 592, 296, 0, 1798, 1799,
		5, 19, 0, 0, 1799, 1800, 3, 650, 325, 0, 1800, 1801, 3, 206, 103, 0, 1801,
		1805, 3, 652, 326, 0, 1802, 1803, 3, 468, 234, 0, 1803, 1804, 3, 210, 105,
		0, 1804, 1806, 1, 0, 0, 0, 1805, 1802, 1, 0, 0, 0, 1805, 1806, 1, 0, 0,
		0, 1806, 205, 1, 0, 0, 0, 1807, 1813, 3, 208, 104, 0, 1808, 1809, 3, 662,
		331, 0, 1809, 1810, 3, 208, 104, 0, 1810, 1812, 1, 0, 0, 0, 1811, 1808,
		1, 0, 0, 0, 1812, 1815, 1, 0, 0, 0, 1813, 1811, 1, 0, 0, 0, 1813, 1814,
		1, 0, 0, 0, 1814, 207, 1, 0, 0, 0, 1815, 1813, 1, 0, 0, 0, 1816, 1817,
		5, 200, 0, 0, 1817, 1818, 5, 9, 0, 0, 1818, 1823, 5, 200, 0, 0, 1819, 1820,
		5, 200, 0, 0, 1820, 1821, 5, 9, 0, 0, 1821, 1823, 5, 201, 0, 0, 1822, 1816,
		1, 0, 0, 0, 1822, 1819, 1, 0, 0, 0, 1823, 209, 1, 0, 0, 0, 1824, 1825,
		3, 504, 252, 0, 1825, 1826, 5, 19, 0, 0, 1826, 1827, 3, 402, 201, 0, 1827,
		211, 1, 0, 0, 0, 1828, 1829, 3, 690, 345, 0, 1829, 1830, 5, 19, 0, 0, 1830,
		1831, 3, 650, 325, 0, 1831, 1832, 3, 214, 107, 0, 1832, 1833, 3, 652, 326,
		0, 1833, 213, 1, 0, 0, 0, 1834, 1840, 3, 216, 108, 0, 1835, 1836, 3, 662,
		331, 0, 1836, 1837, 3, 216, 108, 0, 1837, 1839, 1, 0, 0, 0, 1838, 1835,
		1, 0, 0, 0, 1839, 1842, 1, 0, 0, 0, 1840, 1838, 1, 0, 0, 0, 1840, 1841,
		1, 0, 0, 0, 1841, 215, 1, 0, 0, 0, 1842, 1840, 1, 0, 0, 0, 1843, 1844,
		3, 400, 200, 0, 1844, 1848, 5, 9, 0, 0, 1845, 1849, 3, 400, 200, 0, 1846,
		1849, 3, 402, 201, 0, 1847, 1849, 3, 396, 198, 0, 1848, 1845, 1, 0, 0,
		0, 1848, 1846, 1, 0, 0, 0, 1848, 1847, 1, 0, 0, 0, 1849, 217, 1, 0, 0,
		0, 1850, 1851, 3, 630, 315, 0, 1851, 1852, 3, 406, 203, 0, 1852, 219, 1,
		0, 0, 0, 1853, 1855, 3, 620, 310, 0, 1854, 1856, 3, 612, 306, 0, 1855,
		1854, 1, 0, 0, 0, 1855, 1856, 1, 0, 0, 0, 1856, 1860, 1, 0, 0, 0, 1857,
		1858, 3, 406, 203, 0, 1858, 1859, 5, 10, 0, 0, 1859, 1861, 1, 0, 0, 0,
		1860, 1857, 1, 0, 0, 0, 1860, 1861, 1, 0, 0, 0, 1861, 1862, 1, 0, 0, 0,
		1862, 1863, 3, 408, 204, 0, 1863, 221, 1, 0, 0, 0, 1864, 1866, 3, 492,
		246, 0, 1865, 1867, 3, 732, 366, 0, 1866, 1865, 1, 0, 0, 0, 1866, 1867,
		1, 0, 0, 0, 1867, 1868, 1, 0, 0, 0, 1868, 1870, 3, 530, 265, 0, 1869, 1871,
		3, 288, 144, 0, 1870, 1869, 1, 0, 0, 0, 1870, 1871, 1, 0, 0, 0, 1871, 1873,
		1, 0, 0, 0, 1872, 1874, 5, 208, 0, 0, 1873, 1872, 1, 0, 0, 0, 1873, 1874,
		1, 0, 0, 0, 1874, 1875, 1, 0, 0, 0, 1875, 1879, 3, 576, 288, 0, 1876, 1877,
		3, 406, 203, 0, 1877, 1878, 5, 10, 0, 0, 1878, 1880, 1, 0, 0, 0, 1879,
		1876, 1, 0, 0, 0, 1879, 1880, 1, 0, 0, 0, 1880, 1881, 1, 0, 0, 0, 1881,
		1882, 3, 408, 204, 0, 1882, 1883, 3, 646, 323, 0, 1883, 1884, 3, 230, 115,
		0, 1884, 1886, 3, 648, 324, 0, 1885, 1887, 3, 224, 112, 0, 1886, 1885,
		1, 0, 0, 0, 1886, 1887, 1, 0, 0, 0, 1887, 223, 1, 0, 0, 0, 1888, 1889,
		3, 634, 317, 0, 1889, 1891, 3, 400, 200, 0, 1890, 1892, 3, 226, 113, 0,
		1891, 1890, 1, 0, 0, 0, 1891, 1892, 1, 0, 0, 0, 1892, 225, 1, 0, 0, 0,
		1893, 1894, 3, 642, 321, 0, 1894, 1895, 3, 578, 289, 0, 1895, 1896, 5,
		19, 0, 0, 1896, 1897, 3, 152, 76, 0, 1897, 227, 1, 0, 0, 0, 1898, 1901,
		5, 208, 0, 0, 1899, 1901, 3, 400, 200, 0, 1900, 1898, 1, 0, 0, 0, 1900,
		1899, 1, 0, 0, 0, 1901, 229, 1, 0, 0, 0, 1902, 1907, 3, 410, 205, 0, 1903,
		1907, 3, 232, 116, 0, 1904, 1907, 3, 234, 117, 0, 1905, 1907, 3, 236, 118,
		0, 1906, 1902, 1, 0, 0, 0, 1906, 1903, 1, 0, 0, 0, 1906, 1904, 1, 0, 0,
		0, 1906, 1905, 1, 0, 0, 0, 1907, 231, 1, 0, 0, 0, 1908, 1909, 3, 546, 273,
		0, 1909, 1910, 3, 646, 323, 0, 1910, 1911, 5, 208, 0, 0, 1911, 1912, 3,
		648, 324, 0, 1912, 233, 1, 0, 0, 0, 1913, 1914, 3, 506, 253, 0, 1914, 1915,
		3, 646, 323, 0, 1915, 1916, 5, 208, 0, 0, 1916, 1917, 3, 648, 324, 0, 1917,
		235, 1, 0, 0, 0, 1918, 1919, 3, 518, 259, 0, 1919, 1920, 3, 646, 323, 0,
		1920, 1921, 5, 208, 0, 0, 1921, 1922, 3, 648, 324, 0, 1922, 237, 1, 0,
		0, 0, 1923, 1925, 3, 200, 100, 0, 1924, 1923, 1, 0, 0, 0, 1924, 1925, 1,
		0, 0, 0, 1925, 1926, 1, 0, 0, 0, 1926, 1928, 3, 494, 247, 0, 1927, 1929,
		3, 240, 120, 0, 1928, 1927, 1, 0, 0, 0, 1928, 1929, 1, 0, 0, 0, 1929, 1930,
		1, 0, 0, 0, 1930, 1932, 3, 354, 177, 0, 1931, 1933, 3, 286, 143, 0, 1932,
		1931, 1, 0, 0, 0, 1932, 1933, 1, 0, 0, 0, 1933, 1934, 1, 0, 0, 0, 1934,
		1937, 3, 364, 182, 0, 1935, 1938, 3, 290, 145, 0, 1936, 1938, 3, 246, 123,
		0, 1937, 1935, 1, 0, 0, 0, 1937, 1936, 1, 0, 0, 0, 1937, 1938, 1, 0, 0,
		0, 1938, 239, 1, 0, 0, 0, 1939, 1945, 3, 242, 121, 0, 1940, 1941, 3, 662,
		331, 0, 1941, 1942, 3, 242, 121, 0, 1942, 1944, 1, 0, 0, 0, 1943, 1940,
		1, 0, 0, 0, 1944, 1947, 1, 0, 0, 0, 1945, 1943, 1, 0, 0, 0, 1945, 1946,
		1, 0, 0, 0, 1946, 241, 1, 0, 0, 0, 1947, 1945, 1, 0, 0, 0, 1948, 1958,
		5, 208, 0, 0, 1949, 1950, 5, 208, 0, 0, 1950, 1953, 5, 5, 0, 0, 1951, 1954,
		3, 400, 200, 0, 1952, 1954, 3, 396, 198, 0, 1953, 1951, 1, 0, 0, 0, 1953,
		1952, 1, 0, 0, 0, 1954, 1955, 1, 0, 0, 0, 1955, 1956, 5, 6, 0, 0, 1956,
		1958, 1, 0, 0, 0, 1957, 1948, 1, 0, 0, 0, 1957, 1949, 1, 0, 0, 0, 1958,
		243, 1, 0, 0, 0, 1959, 1961, 3, 200, 100, 0, 1960, 1959, 1, 0, 0, 0, 1960,
		1961, 1, 0, 0, 0, 1961, 1962, 1, 0, 0, 0, 1962, 1966, 3, 628, 314, 0, 1963,
		1964, 3, 406, 203, 0, 1964, 1965, 5, 10, 0, 0, 1965, 1967, 1, 0, 0, 0,
		1966, 1963, 1, 0, 0, 0, 1966, 1967, 1, 0, 0, 0, 1967, 1968, 1, 0, 0, 0,
		1968, 1970, 3, 408, 204, 0, 1969, 1971, 3, 280, 140, 0, 1970, 1969, 1,
		0, 0, 0, 1970, 1971, 1, 0, 0, 0, 1971, 1972, 1, 0, 0, 0, 1972, 1973, 3,
		602, 301, 0, 1973, 1974, 3, 254, 127, 0, 1974, 1977, 3, 364, 182, 0, 1975,
		1978, 3, 290, 145, 0, 1976, 1978, 3, 246, 123, 0, 1977, 1975, 1, 0, 0,
		0, 1977, 1976, 1, 0, 0, 0, 1977, 1978, 1, 0, 0, 0, 1978, 245, 1, 0, 0,
		0, 1979, 1980, 3, 526, 263, 0, 1980, 1981, 3, 248, 124, 0, 1981, 1987,
		1, 0, 0, 0, 1982, 1983, 3, 526, 263, 0, 1983, 1984, 3, 570, 285, 0, 1984,
		1985, 3, 510, 255, 0, 1985, 1987, 1, 0, 0, 0, 1986, 1979, 1, 0, 0, 0, 1986,
		1982, 1, 0, 0, 0, 1987, 247, 1, 0, 0, 0, 1988, 1994, 3, 250, 125, 0, 1989,
		1990, 3, 468, 234, 0, 1990, 1991, 3, 250, 125, 0, 1991, 1993, 1, 0, 0,
		0, 1992, 1989, 1, 0, 0, 0, 1993, 1996, 1, 0, 0, 0, 1994, 1992, 1, 0, 0,
		0, 1994, 1995, 1, 0, 0, 0, 1995, 2002, 1, 0, 0, 0, 1996, 1994, 1, 0, 0,
		0, 1997, 1998, 3, 580, 290, 0, 1998, 1999, 3, 250, 125, 0, 1999, 2001,
		1, 0, 0, 0, 2000, 1997, 1, 0, 0, 0, 2001, 2004, 1, 0, 0, 0, 2002, 2000,
		1, 0, 0, 0, 2002, 2003, 1, 0, 0, 0, 2003, 249, 1, 0, 0, 0, 2004, 2002,
		1, 0, 0, 0, 2005, 2006, 3, 414, 207, 0, 2006, 2007, 7, 2, 0, 0, 2007, 2008,
		3, 252, 126, 0, 2008, 2063, 1, 0, 0, 0, 2009, 2010, 3, 252, 126, 0, 2010,
		2011, 7, 2, 0, 0, 2011, 2012, 3, 414, 207, 0, 2012, 2063, 1, 0, 0, 0, 2013,
		2014, 3, 414, 207, 0, 2014, 2015, 3, 528, 264, 0, 2015, 2025, 3, 646, 323,
		0, 2016, 2022, 3, 252, 126, 0, 2017, 2018, 3, 662, 331, 0, 2018, 2019,
		3, 252, 126, 0, 2019, 2021, 1, 0, 0, 0, 2020, 2017, 1, 0, 0, 0, 2021, 2024,
		1, 0, 0, 0, 2022, 2020, 1, 0, 0, 0, 2022, 2023, 1, 0, 0, 0, 2023, 2026,
		1, 0, 0, 0, 2024, 2022, 1, 0, 0, 0, 2025, 2016, 1, 0, 0, 0, 2025, 2026,
		1, 0, 0, 0, 2026, 2027, 1, 0, 0, 0, 2027, 2028, 3, 648, 324, 0, 2028, 2063,
		1, 0, 0, 0, 2029, 2030, 3, 414, 207, 0, 2030, 2031, 3, 658, 329, 0, 2031,
		2032, 3, 252, 126, 0, 2032, 2033, 3, 660, 330, 0, 2033, 2034, 7, 2, 0,
		0, 2034, 2035, 3, 252, 126, 0, 2035, 2063, 1, 0, 0, 0, 2036, 2037, 3, 414,
		207, 0, 2037, 2038, 3, 490, 245, 0, 2038, 2039, 3, 252, 126, 0, 2039, 2063,
		1, 0, 0, 0, 2040, 2041, 3, 414, 207, 0, 2041, 2042, 3, 490, 245, 0, 2042,
		2043, 3, 544, 272, 0, 2043, 2044, 3, 252, 126, 0, 2044, 2063, 1, 0, 0,
		0, 2045, 2046, 3, 414, 207, 0, 2046, 2047, 3, 650, 325, 0, 2047, 2048,
		3, 252, 126, 0, 2048, 2049, 3, 652, 326, 0, 2049, 2050, 7, 3, 0, 0, 2050,
		2051, 3, 252, 126, 0, 2051, 2063, 1, 0, 0, 0, 2052, 2053, 3, 414, 207,
		0, 2053, 2054, 3, 684, 342, 0, 2054, 2055, 3, 252, 126, 0, 2055, 2063,
		1, 0, 0, 0, 2056, 2063, 3, 414, 207, 0, 2057, 2058, 3, 414, 207, 0, 2058,
		2059, 3, 658, 329, 0, 2059, 2060, 3, 252, 126, 0, 2060, 2061, 3, 660, 330,
		0, 2061, 2063, 1, 0, 0, 0, 2062, 2005, 1, 0, 0, 0, 2062, 2009, 1, 0, 0,
		0, 2062, 2013, 1, 0, 0, 0, 2062, 2029, 1, 0, 0, 0, 2062, 2036, 1, 0, 0,
		0, 2062, 2040, 1, 0, 0, 0, 2062, 2045, 1, 0, 0, 0, 2062, 2052, 1, 0, 0,
		0, 2062, 2056, 1, 0, 0, 0, 2062, 2057, 1, 0, 0, 0, 2063, 251, 1, 0, 0,
		0, 2064, 2071, 3, 390, 195, 0, 2065, 2071, 5, 208, 0, 0, 2066, 2071, 3,
		382, 191, 0, 2067, 2071, 3, 260, 130, 0, 2068, 2071, 3, 272, 136, 0, 2069,
		2071, 3, 264, 132, 0, 2070, 2064, 1, 0, 0, 0, 2070, 2065, 1, 0, 0, 0, 2070,
		2066, 1, 0, 0, 0, 2070, 2067, 1, 0, 0, 0, 2070, 2068, 1, 0, 0, 0, 2070,
		2069, 1, 0, 0, 0, 2071, 253, 1, 0, 0, 0, 2072, 2078, 3, 256, 128, 0, 2073,
		2074, 3, 662, 331, 0, 2074, 2075, 3, 256, 128, 0, 2075, 2077, 1, 0, 0,
		0, 2076, 2073, 1, 0, 0, 0, 2077, 2080, 1, 0, 0, 0, 2078, 2076, 1, 0, 0,
		0, 2078, 2079, 1, 0, 0, 0, 2079, 255, 1, 0, 0, 0, 2080, 2078, 1, 0, 0,
		0, 2081, 2082, 3, 414, 207, 0, 2082, 2088, 5, 19, 0, 0, 2083, 2089, 3,
		390, 195, 0, 2084, 2089, 3, 264, 132, 0, 2085, 2089, 3, 260, 130, 0, 2086,
		2089, 3, 272, 136, 0, 2087, 2089, 3, 382, 191, 0, 2088, 2083, 1, 0, 0,
		0, 2088, 2084, 1, 0, 0, 0, 2088, 2085, 1, 0, 0, 0, 2088, 2086, 1, 0, 0,
		0, 2088, 2087, 1, 0, 0, 0, 2089, 2140, 1, 0, 0, 0, 2090, 2091, 3, 414,
		207, 0, 2091, 2092, 5, 19, 0, 0, 2092, 2093, 3, 414, 207, 0, 2093, 2094,
		7, 4, 0, 0, 2094, 2095, 3, 396, 198, 0, 2095, 2140, 1, 0, 0, 0, 2096, 2097,
		3, 414, 207, 0, 2097, 2098, 5, 19, 0, 0, 2098, 2099, 3, 414, 207, 0, 2099,
		2100, 7, 4, 0, 0, 2100, 2101, 3, 260, 130, 0, 2101, 2140, 1, 0, 0, 0, 2102,
		2103, 3, 414, 207, 0, 2103, 2104, 5, 19, 0, 0, 2104, 2105, 3, 260, 130,
		0, 2105, 2106, 7, 4, 0, 0, 2106, 2107, 3, 414, 207, 0, 2107, 2140, 1, 0,
		0, 0, 2108, 2109, 3, 414, 207, 0, 2109, 2110, 5, 19, 0, 0, 2110, 2111,
		3, 414, 207, 0, 2111, 2112, 7, 4, 0, 0, 2112, 2113, 3, 264, 132, 0, 2113,
		2140, 1, 0, 0, 0, 2114, 2115, 3, 414, 207, 0, 2115, 2116, 5, 19, 0, 0,
		2116, 2117, 3, 264, 132, 0, 2117, 2118, 7, 4, 0, 0, 2118, 2119, 3, 414,
		207, 0, 2119, 2140, 1, 0, 0, 0, 2120, 2121, 3, 414, 207, 0, 2121, 2122,
		5, 19, 0, 0, 2122, 2123, 3, 414, 207, 0, 2123, 2124, 7, 4, 0, 0, 2124,
		2125, 3, 272, 136, 0, 2125, 2140, 1, 0, 0, 0, 2126, 2127, 3, 414, 207,
		0, 2127, 2128, 5, 19, 0, 0, 2128, 2129, 3, 272, 136, 0, 2129, 2130, 7,
		4, 0, 0, 2130, 2131, 3, 414, 207, 0, 2131, 2140, 1, 0, 0, 0, 2132, 2133,
		3, 414, 207, 0, 2133, 2134, 3, 658, 329, 0, 2134, 2135, 3, 258, 129, 0,
		2135, 2136, 3, 660, 330, 0, 2136, 2137, 5, 19, 0, 0, 2137, 2138, 3, 390,
		195, 0, 2138, 2140, 1, 0, 0, 0, 2139, 2081, 1, 0, 0, 0, 2139, 2090, 1,
		0, 0, 0, 2139, 2096, 1, 0, 0, 0, 2139, 2102, 1, 0, 0, 0, 2139, 2108, 1,
		0, 0, 0, 2139, 2114, 1, 0, 0, 0, 2139, 2120, 1, 0, 0, 0, 2139, 2126, 1,
		0, 0, 0, 2139, 2132, 1, 0, 0, 0, 2140, 257, 1, 0, 0, 0, 2141, 2146, 3,
		396, 198, 0, 2142, 2146, 3, 400, 200, 0, 2143, 2146, 3, 402, 201, 0, 2144,
		2146, 3, 572, 286, 0, 2145, 2141, 1, 0, 0, 0, 2145, 2142, 1, 0, 0, 0, 2145,
		2143, 1, 0, 0, 0, 2145, 2144, 1, 0, 0, 0, 2146, 259, 1, 0, 0, 0, 2147,
		2157, 3, 650, 325, 0, 2148, 2154, 3, 262, 131, 0, 2149, 2150, 3, 662, 331,
		0, 2150, 2151, 3, 262, 131, 0, 2151, 2153, 1, 0, 0, 0, 2152, 2149, 1, 0,
		0, 0, 2153, 2156, 1, 0, 0, 0, 2154, 2152, 1, 0, 0, 0, 2154, 2155, 1, 0,
		0, 0, 2155, 2158, 1, 0, 0, 0, 2156, 2154, 1, 0, 0, 0, 2157, 2148, 1, 0,
		0, 0, 2157, 2158, 1, 0, 0, 0, 2158, 2159, 1, 0, 0, 0, 2159, 2160, 3, 652,
		326, 0, 2160, 261, 1, 0, 0, 0, 2161, 2165, 3, 390, 195, 0, 2162, 2165,
		3, 260, 130, 0, 2163, 2165, 3, 272, 136, 0, 2164, 2161, 1, 0, 0, 0, 2164,
		2162, 1, 0, 0, 0, 2164, 2163, 1, 0, 0, 0, 2165, 263, 1, 0, 0, 0, 2166,
		2176, 3, 650, 325, 0, 2167, 2173, 3, 266, 133, 0, 2168, 2169, 3, 662, 331,
		0, 2169, 2170, 3, 266, 133, 0, 2170, 2172, 1, 0, 0, 0, 2171, 2168, 1, 0,
		0, 0, 2172, 2175, 1, 0, 0, 0, 2173, 2171, 1, 0, 0, 0, 2173, 2174, 1, 0,
		0, 0, 2174, 2177, 1, 0, 0, 0, 2175, 2173, 1, 0, 0, 0, 2176, 2167, 1, 0,
		0, 0, 2176, 2177, 1, 0, 0, 0, 2177, 2178, 1, 0, 0, 0, 2178, 2179, 3, 652,
		326, 0, 2179, 265, 1, 0, 0, 0, 2180, 2181, 3, 268, 134, 0, 2181, 2182,
		3, 664, 332, 0, 2182, 2183, 3, 270, 135, 0, 2183, 267, 1, 0, 0, 0, 2184,
		2188, 3, 390, 195, 0, 2185, 2188, 3, 272, 136, 0, 2186, 2188, 3, 260, 130,
		0, 2187, 2184, 1, 0, 0, 0, 2187, 2185, 1, 0, 0, 0, 2187, 2186, 1, 0, 0,
		0, 2188, 269, 1, 0, 0, 0, 2189, 2194, 3, 390, 195, 0, 2190, 2194, 3, 260,
		130, 0, 2191, 2194, 3, 272, 136, 0, 2192, 2194, 3, 264, 132, 0, 2193, 2189,
		1, 0, 0, 0, 2193, 2190, 1, 0, 0, 0, 2193, 2191, 1, 0, 0, 0, 2193, 2192,
		1, 0, 0, 0, 2194, 271, 1, 0, 0, 0, 2195, 2205, 3, 658, 329, 0, 2196, 2202,
		3, 274, 137, 0, 2197, 2198, 3, 662, 331, 0, 2198, 2199, 3, 274, 137, 0,
		2199, 2201, 1, 0, 0, 0, 2200, 2197, 1, 0, 0, 0, 2201, 2204, 1, 0, 0, 0,
		2202, 2200, 1, 0, 0, 0, 2202, 2203, 1, 0, 0, 0, 2203, 2206, 1, 0, 0, 0,
		2204, 2202, 1, 0, 0, 0, 2205, 2196, 1, 0, 0, 0, 2205, 2206, 1, 0, 0, 0,
		2206, 2207, 1, 0, 0, 0, 2207, 2208, 3, 660, 330, 0, 2208, 273, 1, 0, 0,
		0, 2209, 2214, 3, 390, 195, 0, 2210, 2214, 3, 260, 130, 0, 2211, 2214,
		3, 272, 136, 0, 2212, 2214, 3, 264, 132, 0, 2213, 2209, 1, 0, 0, 0, 2213,
		2210, 1, 0, 0, 0, 2213, 2211, 1, 0, 0, 0, 2213, 2212, 1, 0, 0, 0, 2214,
		275, 1, 0, 0, 0, 2215, 2216, 3, 646, 323, 0, 2216, 2222, 3, 302, 151, 0,
		2217, 2218, 3, 662, 331, 0, 2218, 2219, 3, 302, 151, 0, 2219, 2221, 1,
		0, 0, 0, 2220, 2217, 1, 0, 0, 0, 2221, 2224, 1, 0, 0, 0, 2222, 2220, 1,
		0, 0, 0, 2222, 2223, 1, 0, 0, 0, 2223, 2225, 1, 0, 0, 0, 2224, 2222, 1,
		0, 0, 0, 2225, 2226, 3, 648, 324, 0, 2226, 277, 1, 0, 0, 0, 2227, 2229,
		3, 200, 100, 0, 2228, 2227, 1, 0, 0, 0, 2228, 2229, 1, 0, 0, 0, 2229, 2230,
		1, 0, 0, 0, 2230, 2231, 3, 536, 268, 0, 2231, 2235, 3, 538, 269, 0, 2232,
		2233, 3, 406, 203, 0, 2233, 2234, 5, 10, 0, 0, 2234, 2236, 1, 0, 0, 0,
		2235, 2232, 1, 0, 0, 0, 2235, 2236, 1, 0, 0, 0, 2236, 2237, 1, 0, 0, 0,
		2237, 2239, 3, 408, 204, 0, 2238, 2240, 3, 296, 148, 0, 2239, 2238, 1,
		0, 0, 0, 2239, 2240, 1, 0, 0, 0, 2240, 2241, 1, 0, 0, 0, 2241, 2243, 3,
		292, 146, 0, 2242, 2244, 3, 288, 144, 0, 2243, 2242, 1, 0, 0, 0, 2243,
		2244, 1, 0, 0, 0, 2244, 2246, 1, 0, 0, 0, 2245, 2247, 3, 280, 140, 0, 2246,
		2245, 1, 0, 0, 0, 2246, 2247, 1, 0, 0, 0, 2247, 279, 1, 0, 0, 0, 2248,
		2249, 3, 634, 317, 0, 2249, 2250, 3, 284, 142, 0, 2250, 2293, 1, 0, 0,
		0, 2251, 2252, 3, 634, 317, 0, 2252, 2253, 3, 284, 142, 0, 2253, 2254,
		3, 468, 234, 0, 2254, 2255, 3, 282, 141, 0, 2255, 2293, 1, 0, 0, 0, 2256,
		2257, 3, 634, 317, 0, 2257, 2258, 3, 282, 141, 0, 2258, 2293, 1, 0, 0,
		0, 2259, 2260, 3, 634, 317, 0, 2260, 2261, 3, 282, 141, 0, 2261, 2262,
		3, 468, 234, 0, 2262, 2263, 3, 284, 142, 0, 2263, 2293, 1, 0, 0, 0, 2264,
		2265, 3, 634, 317, 0, 2265, 2266, 3, 670, 335, 0, 2266, 2267, 3, 390, 195,
		0, 2267, 2293, 1, 0, 0, 0, 2268, 2269, 3, 634, 317, 0, 2269, 2270, 3, 284,
		142, 0, 2270, 2271, 3, 468, 234, 0, 2271, 2272, 3, 670, 335, 0, 2272, 2273,
		3, 390, 195, 0, 2273, 2293, 1, 0, 0, 0, 2274, 2275, 3, 634, 317, 0, 2275,
		2276, 3, 282, 141, 0, 2276, 2277, 3, 468, 234, 0, 2277, 2278, 3, 670, 335,
		0, 2278, 2279, 3, 390, 195, 0, 2279, 2293, 1, 0, 0, 0, 2280, 2281, 3, 634,
		317, 0, 2281, 2282, 3, 670, 335, 0, 2282, 2283, 3, 390, 195, 0, 2283, 2284,
		3, 468, 234, 0, 2284, 2285, 3, 284, 142, 0, 2285, 2293, 1, 0, 0, 0, 2286,
		2287, 3, 634, 317, 0, 2287, 2288, 3, 670, 335, 0, 2288, 2289, 3, 390, 195,
		0, 2289, 2290, 3, 468, 234, 0, 2290, 2291, 3, 282, 141, 0, 2291, 2293,
		1, 0, 0, 0, 2292, 2248, 1, 0, 0, 0, 2292, 2251, 1, 0, 0, 0, 2292, 2256,
		1, 0, 0, 0, 2292, 2259, 1, 0, 0, 0, 2292, 2264, 1, 0, 0, 0, 2292, 2268,
		1, 0, 0, 0, 2292, 2274, 1, 0, 0, 0, 2292, 2280, 1, 0, 0, 0, 2292, 2286,
		1, 0, 0, 0, 2293, 281, 1, 0, 0, 0, 2294, 2295, 3, 614, 307, 0, 2295, 2296,
		3, 396, 198, 0, 2296, 283, 1, 0, 0, 0, 2297, 2298, 3, 622, 311, 0, 2298,
		2299, 3, 396, 198, 0, 2299, 285, 1, 0, 0, 0, 2300, 2301, 3, 634, 317, 0,
		2301, 2302, 3, 282, 141, 0, 2302, 2320, 1, 0, 0, 0, 2303, 2304, 3, 634,
		317, 0, 2304, 2305, 3, 670, 335, 0, 2305, 2306, 3, 390, 195, 0, 2306, 2320,
		1, 0, 0, 0, 2307, 2308, 3, 634, 317, 0, 2308, 2309, 3, 282, 141, 0, 2309,
		2310, 3, 468, 234, 0, 2310, 2311, 3, 670, 335, 0, 2311, 2312, 3, 390, 195,
		0, 2312, 2320, 1, 0, 0, 0, 2313, 2314, 3, 634, 317, 0, 2314, 2315, 3, 670,
		335, 0, 2315, 2316, 3, 390, 195, 0, 2316, 2317, 3, 468, 234, 0, 2317, 2318,
		3, 282, 141, 0, 2318, 2320, 1, 0, 0, 0, 2319, 2300, 1, 0, 0, 0, 2319, 2303,
		1, 0, 0, 0, 2319, 2307, 1, 0, 0, 0, 2319, 2313, 1, 0, 0, 0, 2320, 287,
		1, 0, 0, 0, 2321, 2322, 3, 526, 263, 0, 2322, 2323, 3, 570, 285, 0, 2323,
		2324, 3, 510, 255, 0, 2324, 289, 1, 0, 0, 0, 2325, 2326, 3, 526, 263, 0,
		2326, 2327, 3, 510, 255, 0, 2327, 291, 1, 0, 0, 0, 2328, 2329, 3, 636,
		318, 0, 2329, 2330, 5, 1, 0, 0, 2330, 2331, 3, 300, 150, 0, 2331, 2332,
		5, 2, 0, 0, 2332, 2339, 1, 0, 0, 0, 2333, 2334, 3, 542, 271, 0, 2334, 2336,
		3, 390, 195, 0, 2335, 2337, 3, 294, 147, 0, 2336, 2335, 1, 0, 0, 0, 2336,
		2337, 1, 0, 0, 0, 2337, 2339, 1, 0, 0, 0, 2338, 2328, 1, 0, 0, 0, 2338,
		2333, 1, 0, 0, 0, 2339, 293, 1, 0, 0, 0, 2340, 2341, 3, 692, 346, 0, 2341,
		2342, 3, 572, 286, 0, 2342, 2347, 1, 0, 0, 0, 2343, 2344, 3, 692, 346,
		0, 2344, 2345, 3, 694, 347, 0, 2345, 2347, 1, 0, 0, 0, 2346, 2340, 1, 0,
		0, 0, 2346, 2343, 1, 0, 0, 0, 2347, 295, 1, 0, 0, 0, 2348, 2349, 5, 1,
		0, 0, 2349, 2350, 3, 298, 149, 0, 2350, 2351, 5, 2, 0, 0, 2351, 297, 1,
		0, 0, 0, 2352, 2358, 3, 410, 205, 0, 2353, 2354, 3, 662, 331, 0, 2354,
		2355, 3, 410, 205, 0, 2355, 2357, 1, 0, 0, 0, 2356, 2353, 1, 0, 0, 0, 2357,
		2360, 1, 0, 0, 0, 2358, 2356, 1, 0, 0, 0, 2358, 2359, 1, 0, 0, 0, 2359,
		299, 1, 0, 0, 0, 2360, 2358, 1, 0, 0, 0, 2361, 2367, 3, 302, 151, 0, 2362,
		2363, 3, 662, 331, 0, 2363, 2364, 3, 302, 151, 0, 2364, 2366, 1, 0, 0,
		0, 2365, 2362, 1, 0, 0, 0, 2366, 2369, 1, 0, 0, 0, 2367, 2365, 1, 0, 0,
		0, 2367, 2368, 1, 0, 0, 0, 2368, 301, 1, 0, 0, 0, 2369, 2367, 1, 0, 0,
		0, 2370, 2377, 3, 390, 195, 0, 2371, 2377, 3, 382, 191, 0, 2372, 2377,
		3, 264, 132, 0, 2373, 2377, 3, 260, 130, 0, 2374, 2377, 3, 272, 136, 0,
		2375, 2377, 3, 276, 138, 0, 2376, 2370, 1, 0, 0, 0, 2376, 2371, 1, 0, 0,
		0, 2376, 2372, 1, 0, 0, 0, 2376, 2373, 1, 0, 0, 0, 2376, 2374, 1, 0, 0,
		0, 2376, 2375, 1, 0, 0, 0, 2377, 303, 1, 0, 0, 0, 2378, 2380, 3, 600, 300,
		0, 2379, 2381, 3, 366, 183, 0, 2380, 2379, 1, 0, 0, 0, 2380, 2381, 1, 0,
		0, 0, 2381, 2383, 1, 0, 0, 0, 2382, 2384, 3, 542, 271, 0, 2383, 2382, 1,
		0, 0, 0, 2383, 2384, 1, 0, 0, 0, 2384, 2385, 1, 0, 0, 0, 2385, 2386, 3,
		368, 184, 0, 2386, 2388, 3, 354, 177, 0, 2387, 2389, 3, 364, 182, 0, 2388,
		2387, 1, 0, 0, 0, 2388, 2389, 1, 0, 0, 0, 2389, 2391, 1, 0, 0, 0, 2390,
		2392, 3, 308, 154, 0, 2391, 2390, 1, 0, 0, 0, 2391, 2392, 1, 0, 0, 0, 2392,
		2394, 1, 0, 0, 0, 2393, 2395, 3, 358, 179, 0, 2394, 2393, 1, 0, 0, 0, 2394,
		2395, 1, 0, 0, 0, 2395, 2397, 1, 0, 0, 0, 2396, 2398, 3, 312, 156, 0, 2397,
		2396, 1, 0, 0, 0, 2397, 2398, 1, 0, 0, 0, 2398, 2400, 1, 0, 0, 0, 2399,
		2401, 3, 352, 176, 0, 2400, 2399, 1, 0, 0, 0, 2400, 2401, 1, 0, 0, 0, 2401,
		2403, 1, 0, 0, 0, 2402, 2404, 3, 306, 153, 0, 2403, 2402, 1, 0, 0, 0, 2403,
		2404, 1, 0, 0, 0, 2404, 2406, 1, 0, 0, 0, 2405, 2407, 3, 310, 155, 0, 2406,
		2405, 1, 0, 0, 0, 2406, 2407, 1, 0, 0, 0, 2407, 2409, 1, 0, 0, 0, 2408,
		2410, 3, 314, 157, 0, 2409, 2408, 1, 0, 0, 0, 2409, 2410, 1, 0, 0, 0, 2410,
		305, 1, 0, 0, 0, 2411, 2412, 3, 464, 232, 0, 2412, 2413, 3, 512, 256, 0,
		2413, 307, 1, 0, 0, 0, 2414, 2415, 3, 678, 339, 0, 2415, 2416, 3, 482,
		241, 0, 2416, 2417, 3, 298, 149, 0, 2417, 309, 1, 0, 0, 0, 2418, 2419,
		3, 666, 333, 0, 2419, 2420, 3, 668, 334, 0, 2420, 311, 1, 0, 0, 0, 2421,
		2422, 3, 674, 337, 0, 2422, 2423, 3, 676, 338, 0, 2423, 2424, 3, 554, 277,
		0, 2424, 2425, 3, 396, 198, 0, 2425, 313, 1, 0, 0, 0, 2426, 2427, 3, 634,
		317, 0, 2427, 2428, 3, 670, 335, 0, 2428, 2429, 3, 390, 195, 0, 2429, 315,
		1, 0, 0, 0, 2430, 2431, 3, 672, 336, 0, 2431, 2432, 3, 562, 281, 0, 2432,
		2436, 3, 638, 319, 0, 2433, 2434, 3, 406, 203, 0, 2434, 2435, 5, 10, 0,
		0, 2435, 2437, 1, 0, 0, 0, 2436, 2433, 1, 0, 0, 0, 2436, 2437, 1, 0, 0,
		0, 2437, 2438, 1, 0, 0, 0, 2438, 2440, 3, 436, 218, 0, 2439, 2441, 3, 364,
		182, 0, 2440, 2439, 1, 0, 0, 0, 2440, 2441, 1, 0, 0, 0, 2441, 2443, 1,
		0, 0, 0, 2442, 2444, 3, 350, 175, 0, 2443, 2442, 1, 0, 0, 0, 2443, 2444,
		1, 0, 0, 0, 2444, 317, 1, 0, 0, 0, 2445, 2448, 3, 698, 349, 0, 2446, 2448,
		3, 496, 248, 0, 2447, 2445, 1, 0, 0, 0, 2447, 2446, 1, 0, 0, 0, 2448, 2449,
		1, 0, 0, 0, 2449, 2451, 3, 320, 160, 0, 2450, 2452, 3, 322, 161, 0, 2451,
		2450, 1, 0, 0, 0, 2451, 2452, 1, 0, 0, 0, 2452, 319, 1, 0, 0, 0, 2453,
		2529, 3, 700, 350, 0, 2454, 2456, 3, 518, 259, 0, 2455, 2454, 1, 0, 0,
		0, 2455, 2456, 1, 0, 0, 0, 2456, 2457, 1, 0, 0, 0, 2457, 2529, 3, 708,
		354, 0, 2458, 2529, 3, 550, 275, 0, 2459, 2461, 3, 702, 351, 0, 2460, 2459,
		1, 0, 0, 0, 2460, 2461, 1, 0, 0, 0, 2461, 2462, 1, 0, 0, 0, 2462, 2464,
		3, 548, 274, 0, 2463, 2465, 3, 406, 203, 0, 2464, 2463, 1, 0, 0, 0, 2464,
		2465, 1, 0, 0, 0, 2465, 2529, 1, 0, 0, 0, 2466, 2529, 3, 710, 355, 0, 2467,
		2469, 3, 612, 306, 0, 2468, 2467, 1, 0, 0, 0, 2468, 2469, 1, 0, 0, 0, 2469,
		2473, 1, 0, 0, 0, 2470, 2471, 3, 406, 203, 0, 2471, 2472, 5, 10, 0, 0,
		2472, 2474, 1, 0, 0, 0, 2473, 2470, 1, 0, 0, 0, 2473, 2474, 1, 0, 0, 0,
		2474, 2475, 1, 0, 0, 0, 2475, 2529, 3, 408, 204, 0, 2476, 2480, 3, 716,
		358, 0, 2477, 2478, 3, 406, 203, 0, 2478, 2479, 5, 10, 0, 0, 2479, 2481,
		1, 0, 0, 0, 2480, 2477, 1, 0, 0, 0, 2480, 2481, 1, 0, 0, 0, 2481, 2482,
		1, 0, 0, 0, 2482, 2483, 3, 408, 204, 0, 2483, 2529, 1, 0, 0, 0, 2484, 2488,
		3, 530, 265, 0, 2485, 2486, 3, 406, 203, 0, 2486, 2487, 5, 10, 0, 0, 2487,
		2489, 1, 0, 0, 0, 2488, 2485, 1, 0, 0, 0, 2488, 2489, 1, 0, 0, 0, 2489,
		2490, 1, 0, 0, 0, 2490, 2491, 5, 208, 0, 0, 2491, 2529, 1, 0, 0, 0, 2492,
		2493, 3, 562, 281, 0, 2493, 2497, 3, 638, 319, 0, 2494, 2495, 3, 406, 203,
		0, 2495, 2496, 5, 10, 0, 0, 2496, 2498, 1, 0, 0, 0, 2497, 2494, 1, 0, 0,
		0, 2497, 2498, 1, 0, 0, 0, 2498, 2499, 1, 0, 0, 0, 2499, 2500, 5, 208,
		0, 0, 2500, 2529, 1, 0, 0, 0, 2501, 2529, 3, 712, 356, 0, 2502, 2506, 3,
		624, 312, 0, 2503, 2504, 3, 406, 203, 0, 2504, 2505, 5, 10, 0, 0, 2505,
		2507, 1, 0, 0, 0, 2506, 2503, 1, 0, 0, 0, 2506, 2507, 1, 0, 0, 0, 2507,
		2508, 1, 0, 0, 0, 2508, 2509, 5, 208, 0, 0, 2509, 2529, 1, 0, 0, 0, 2510,
		2529, 3, 522, 261, 0, 2511, 2515, 3, 520, 260, 0, 2512, 2513, 3, 406, 203,
		0, 2513, 2514, 5, 10, 0, 0, 2514, 2516, 1, 0, 0, 0, 2515, 2512, 1, 0, 0,
		0, 2515, 2516, 1, 0, 0, 0, 2516, 2517, 1, 0, 0, 0, 2517, 2518, 5, 208,
		0, 0, 2518, 2529, 1, 0, 0, 0, 2519, 2529, 3, 714, 357, 0, 2520, 2524, 3,
		458, 229, 0, 2521, 2522, 3, 406, 203, 0, 2522, 2523, 5, 10, 0, 0, 2523,
		2525, 1, 0, 0, 0, 2524, 2521, 1, 0, 0, 0, 2524, 2525, 1, 0, 0, 0, 2525,
		2526, 1, 0, 0, 0, 2526, 2527, 5, 208, 0, 0, 2527, 2529, 1, 0, 0, 0, 2528,
		2453, 1, 0, 0, 0, 2528, 2455, 1, 0, 0, 0, 2528, 2458, 1, 0, 0, 0, 2528,
		2460, 1, 0, 0, 0, 2528, 2466, 1, 0, 0, 0, 2528, 2468, 1, 0, 0, 0, 2528,
		2476, 1, 0, 0, 0, 2528, 2484, 1, 0, 0, 0, 2528, 2492, 1, 0, 0, 0, 2528,
		2501, 1, 0, 0, 0, 2528, 2502, 1, 0, 0, 0, 2528, 2510, 1, 0, 0, 0, 2528,
		2511, 1, 0, 0, 0, 2528, 2519, 1, 0, 0, 0, 2528, 2520, 1, 0, 0, 0, 2529,
		321, 1, 0, 0, 0, 2530, 2531, 3, 642, 321, 0, 2531, 2535, 3, 704, 352, 0,
		2532, 2533, 3, 468, 234, 0, 2533, 2534, 3, 706, 353, 0, 2534, 2536, 1,
		0, 0, 0, 2535, 2532, 1, 0, 0, 0, 2535, 2536, 1, 0, 0, 0, 2536, 323, 1,
		0, 0, 0, 2537, 2540, 5, 208, 0, 0, 2538, 2540, 3, 400, 200, 0, 2539, 2537,
		1, 0, 0, 0, 2539, 2538, 1, 0, 0, 0, 2540, 325, 1, 0, 0, 0, 2541, 2542,
		3, 718, 359, 0, 2542, 2543, 3, 720, 360, 0, 2543, 327, 1, 0, 0, 0, 2544,
		2545, 3, 718, 359, 0, 2545, 2546, 3, 722, 361, 0, 2546, 329, 1, 0, 0, 0,
		2547, 2548, 3, 492, 246, 0, 2548, 2550, 3, 326, 163, 0, 2549, 2551, 3,
		288, 144, 0, 2550, 2549, 1, 0, 0, 0, 2550, 2551, 1, 0, 0, 0, 2551, 2552,
		1, 0, 0, 0, 2552, 2556, 3, 324, 162, 0, 2553, 2554, 3, 642, 321, 0, 2554,
		2555, 3, 342, 171, 0, 2555, 2557, 1, 0, 0, 0, 2556, 2553, 1, 0, 0, 0, 2556,
		2557, 1, 0, 0, 0, 2557, 331, 1, 0, 0, 0, 2558, 2559, 3, 466, 233, 0, 2559,
		2560, 3, 326, 163, 0, 2560, 2561, 3, 324, 162, 0, 2561, 2562, 3, 642, 321,
		0, 2562, 2563, 3, 342, 171, 0, 2563, 333, 1, 0, 0, 0, 2564, 2565, 3, 502,
		251, 0, 2565, 2567, 3, 326, 163, 0, 2566, 2568, 3, 290, 145, 0, 2567, 2566,
		1, 0, 0, 0, 2567, 2568, 1, 0, 0, 0, 2568, 2569, 1, 0, 0, 0, 2569, 2570,
		3, 324, 162, 0, 2570, 335, 1, 0, 0, 0, 2571, 2572, 3, 724, 362, 0, 2572,
		2573, 3, 326, 163, 0, 2573, 2574, 3, 324, 162, 0, 2574, 2575, 3, 616, 308,
		0, 2575, 2576, 3, 324, 162, 0, 2576, 337, 1, 0, 0, 0, 2577, 2578, 3, 726,
		363, 0, 2578, 2579, 3, 326, 163, 0, 2579, 2580, 3, 516, 258, 0, 2580, 2581,
		3, 324, 162, 0, 2581, 339, 1, 0, 0, 0, 2582, 2583, 3, 556, 278, 0, 2583,
		2584, 3, 326, 163, 0, 2584, 2585, 3, 324, 162, 0, 2585, 2603, 1, 0, 0,
		0, 2586, 2587, 3, 556, 278, 0, 2587, 2588, 3, 460, 230, 0, 2588, 2589,
		3, 328, 164, 0, 2589, 2603, 1, 0, 0, 0, 2590, 2591, 3, 556, 278, 0, 2591,
		2592, 3, 728, 364, 0, 2592, 2593, 3, 326, 163, 0, 2593, 2594, 3, 574, 287,
		0, 2594, 2595, 3, 324, 162, 0, 2595, 2603, 1, 0, 0, 0, 2596, 2597, 3, 556,
		278, 0, 2597, 2598, 3, 730, 365, 0, 2598, 2599, 3, 326, 163, 0, 2599, 2600,
		3, 574, 287, 0, 2600, 2601, 3, 324, 162, 0, 2601, 2603, 1, 0, 0, 0, 2602,
		2582, 1, 0, 0, 0, 2602, 2586, 1, 0, 0, 0, 2602, 2590, 1, 0, 0, 0, 2602,
		2596, 1, 0, 0, 0, 2603, 341, 1, 0, 0, 0, 2604, 2610, 3, 344, 172, 0, 2605,
		2606, 3, 468, 234, 0, 2606, 2607, 3, 344, 172, 0, 2607, 2609, 1, 0, 0,
		0, 2608, 2605, 1, 0, 0, 0, 2609, 2612, 1, 0, 0, 0, 2610, 2608, 1, 0, 0,
		0, 2610, 2611, 1, 0, 0, 0, 2611, 343, 1, 0, 0, 0, 2612, 2610, 1, 0, 0,
		0, 2613, 2614, 3, 346, 173, 0, 2614, 2615, 5, 19, 0, 0, 2615, 2616, 3,
		348, 174, 0, 2616, 345, 1, 0, 0, 0, 2617, 2621, 5, 208, 0, 0, 2618, 2621,
		3, 670, 335, 0, 2619, 2621, 3, 692, 346, 0, 2620, 2617, 1, 0, 0, 0, 2620,
		2618, 1, 0, 0, 0, 2620, 2619, 1, 0, 0, 0, 2621, 347, 1, 0, 0, 0, 2622,
		2625, 3, 390, 195, 0, 2623, 2625, 5, 208, 0, 0, 2624, 2622, 1, 0, 0, 0,
		2624, 2623, 1, 0, 0, 0, 2625, 349, 1, 0, 0, 0, 2626, 2627, 3, 634, 317,
		0, 2627, 2628, 3, 670, 335, 0, 2628, 2629, 3, 390, 195, 0, 2629, 2649,
		1, 0, 0, 0, 2630, 2631, 3, 634, 317, 0, 2631, 2632, 3, 746, 373, 0, 2632,
		2633, 3, 396, 198, 0, 2633, 2649, 1, 0, 0, 0, 2634, 2635, 3, 634, 317,
		0, 2635, 2636, 3, 746, 373, 0, 2636, 2637, 3, 396, 198, 0, 2637, 2638,
		3, 468, 234, 0, 2638, 2639, 3, 670, 335, 0, 2639, 2640, 3, 390, 195, 0,
		2640, 2649, 1, 0, 0, 0, 2641, 2642, 3, 634, 317, 0, 2642, 2643, 3, 670,
		335, 0, 2643, 2644, 3, 390, 195, 0, 2644, 2645, 3, 468, 234, 0, 2645, 2646,
		3, 746, 373, 0, 2646, 2647, 3, 396, 198, 0, 2647, 2649, 1, 0, 0, 0, 2648,
		2626, 1, 0, 0, 0, 2648, 2630, 1, 0, 0, 0, 2648, 2634, 1, 0, 0, 0, 2648,
		2641, 1, 0, 0, 0, 2649, 351, 1, 0, 0, 0, 2650, 2651, 3, 554, 277, 0, 2651,
		2652, 3, 396, 198, 0, 2652, 353, 1, 0, 0, 0, 2653, 2654, 3, 516, 258, 0,
		2654, 2655, 3, 356, 178, 0, 2655, 355, 1, 0, 0, 0, 2656, 2669, 5, 208,
		0, 0, 2657, 2669, 3, 416, 208, 0, 2658, 2669, 3, 418, 209, 0, 2659, 2660,
		5, 208, 0, 0, 2660, 2661, 5, 10, 0, 0, 2661, 2669, 5, 208, 0, 0, 2662,
		2663, 5, 208, 0, 0, 2663, 2664, 5, 10, 0, 0, 2664, 2669, 3, 416, 208, 0,
		2665, 2666, 5, 208, 0, 0, 2666, 2667, 5, 10, 0, 0, 2667, 2669, 3, 418,
		209, 0, 2668, 2656, 1, 0, 0, 0, 2668, 2657, 1, 0, 0, 0, 2668, 2658, 1,
		0, 0, 0, 2668, 2659, 1, 0, 0, 0, 2668, 2662, 1, 0, 0, 0, 2668, 2665, 1,
		0, 0, 0, 2669, 357, 1, 0, 0, 0, 2670, 2671, 3, 582, 291, 0, 2671, 2672,
		3, 482, 241, 0, 2672, 2673, 3, 360, 180, 0, 2673, 359, 1, 0, 0, 0, 2674,
		2677, 5, 208, 0, 0, 2675, 2678, 3, 474, 237, 0, 2676, 2678, 3, 496, 248,
		0, 2677, 2675, 1, 0, 0, 0, 2677, 2676, 1, 0, 0, 0, 2677, 2678, 1, 0, 0,
		0, 2678, 2685, 1, 0, 0, 0, 2679, 2680, 5, 208, 0, 0, 2680, 2681, 3, 734,
		367, 0, 2681, 2682, 3, 574, 287, 0, 2682, 2683, 3, 362, 181, 0, 2683, 2685,
		1, 0, 0, 0, 2684, 2674, 1, 0, 0, 0, 2684, 2679, 1, 0, 0, 0, 2685, 361,
		1, 0, 0, 0, 2686, 2689, 3, 658, 329, 0, 2687, 2690, 3, 398, 199, 0, 2688,
		2690, 3, 396, 198, 0, 2689, 2687, 1, 0, 0, 0, 2689, 2688, 1, 0, 0, 0, 2690,
		2698, 1, 0, 0, 0, 2691, 2694, 3, 662, 331, 0, 2692, 2695, 3, 398, 199,
		0, 2693, 2695, 3, 396, 198, 0, 2694, 2692, 1, 0, 0, 0, 2694, 2693, 1, 0,
		0, 0, 2695, 2697, 1, 0, 0, 0, 2696, 2691, 1, 0, 0, 0, 2697, 2700, 1, 0,
		0, 0, 2698, 2696, 1, 0, 0, 0, 2698, 2699, 1, 0, 0, 0, 2699, 2701, 1, 0,
		0, 0, 2700, 2698, 1, 0, 0, 0, 2701, 2702, 3, 660, 330, 0, 2702, 363, 1,
		0, 0, 0, 2703, 2704, 3, 640, 320, 0, 2704, 2705, 3, 372, 186, 0, 2705,
		365, 1, 0, 0, 0, 2706, 2707, 3, 500, 250, 0, 2707, 367, 1, 0, 0, 0, 2708,
		2711, 5, 11, 0, 0, 2709, 2711, 3, 370, 185, 0, 2710, 2708, 1, 0, 0, 0,
		2710, 2709, 1, 0, 0, 0, 2711, 2717, 1, 0, 0, 0, 2712, 2713, 3, 662, 331,
		0, 2713, 2714, 3, 370, 185, 0, 2714, 2716, 1, 0, 0, 0, 2715, 2712, 1, 0,
		0, 0, 2716, 2719, 1, 0, 0, 0, 2717, 2715, 1, 0, 0, 0, 2717, 2718, 1, 0,
		0, 0, 2718, 369, 1, 0, 0, 0, 2719, 2717, 1, 0, 0, 0, 2720, 2721, 5, 208,
		0, 0, 2721, 2722, 5, 10, 0, 0, 2722, 2748, 5, 11, 0, 0, 2723, 2727, 3,
		414, 207, 0, 2724, 2725, 3, 472, 236, 0, 2725, 2726, 5, 208, 0, 0, 2726,
		2728, 1, 0, 0, 0, 2727, 2724, 1, 0, 0, 0, 2727, 2728, 1, 0, 0, 0, 2728,
		2748, 1, 0, 0, 0, 2729, 2733, 3, 382, 191, 0, 2730, 2731, 3, 472, 236,
		0, 2731, 2732, 5, 208, 0, 0, 2732, 2734, 1, 0, 0, 0, 2733, 2730, 1, 0,
		0, 0, 2733, 2734, 1, 0, 0, 0, 2734, 2748, 1, 0, 0, 0, 2735, 2739, 3, 384,
		192, 0, 2736, 2737, 3, 472, 236, 0, 2737, 2738, 5, 208, 0, 0, 2738, 2740,
		1, 0, 0, 0, 2739, 2736, 1, 0, 0, 0, 2739, 2740, 1, 0, 0, 0, 2740, 2748,
		1, 0, 0, 0, 2741, 2745, 3, 386, 193, 0, 2742, 2743, 3, 472, 236, 0, 2743,
		2744, 5, 208, 0, 0, 2744, 2746, 1, 0, 0, 0, 2745, 2742, 1, 0, 0, 0, 2745,
		2746, 1, 0, 0, 0, 2746, 2748, 1, 0, 0, 0, 2747, 2720, 1, 0, 0, 0, 2747,
		2723, 1, 0, 0, 0, 2747, 2729, 1, 0, 0, 0, 2747, 2735, 1, 0, 0, 0, 2747,
		2741, 1, 0, 0, 0, 2748, 371, 1, 0, 0, 0, 2749, 2755, 3, 374, 187, 0, 2750,
		2751, 3, 468, 234, 0, 2751, 2752, 3, 374, 187, 0, 2752, 2754, 1, 0, 0,
		0, 2753, 2750, 1, 0, 0, 0, 2754, 2757, 1, 0, 0, 0, 2755, 2753, 1, 0, 0,
		0, 2755, 2756, 1, 0, 0, 0, 2756, 373, 1, 0, 0, 0, 2757, 2755, 1, 0, 0,
		0, 2758, 2759, 3, 414, 207, 0, 2759, 2760, 7, 0, 0, 0, 2760, 2761, 3, 390,
		195, 0, 2761, 2860, 1, 0, 0, 0, 2762, 2763, 3, 414, 207, 0, 2763, 2764,
		7, 0, 0, 0, 2764, 2765, 3, 382, 191, 0, 2765, 2860, 1, 0, 0, 0, 2766, 2767,
		3, 414, 207, 0, 2767, 2768, 5, 10, 0, 0, 2768, 2769, 5, 208, 0, 0, 2769,
		2770, 7, 0, 0, 0, 2770, 2771, 3, 390, 195, 0, 2771, 2860, 1, 0, 0, 0, 2772,
		2773, 3, 382, 191, 0, 2773, 2774, 7, 0, 0, 0, 2774, 2775, 3, 390, 195,
		0, 2775, 2860, 1, 0, 0, 0, 2776, 2777, 3, 382, 191, 0, 2777, 2778, 7, 0,
		0, 0, 2778, 2779, 3, 382, 191, 0, 2779, 2860, 1, 0, 0, 0, 2780, 2781, 3,
		414, 207, 0, 2781, 2782, 3, 528, 264, 0, 2782, 2784, 5, 1, 0, 0, 2783,
		2785, 3, 388, 194, 0, 2784, 2783, 1, 0, 0, 0, 2784, 2785, 1, 0, 0, 0, 2785,
		2786, 1, 0, 0, 0, 2786, 2787, 5, 2, 0, 0, 2787, 2860, 1, 0, 0, 0, 2788,
		2789, 5, 1, 0, 0, 2789, 2795, 3, 414, 207, 0, 2790, 2791, 3, 662, 331,
		0, 2791, 2792, 3, 414, 207, 0, 2792, 2794, 1, 0, 0, 0, 2793, 2790, 1, 0,
		0, 0, 2794, 2797, 1, 0, 0, 0, 2795, 2793, 1, 0, 0, 0, 2795, 2796, 1, 0,
		0, 0, 2796, 2798, 1, 0, 0, 0, 2797, 2795, 1, 0, 0, 0, 2798, 2799, 5, 2,
		0, 0, 2799, 2800, 3, 528, 264, 0, 2800, 2801, 5, 1, 0, 0, 2801, 2807, 3,
		276, 138, 0, 2802, 2803, 3, 662, 331, 0, 2803, 2804, 3, 276, 138, 0, 2804,
		2806, 1, 0, 0, 0, 2805, 2802, 1, 0, 0, 0, 2806, 2809, 1, 0, 0, 0, 2807,
		2805, 1, 0, 0, 0, 2807, 2808, 1, 0, 0, 0, 2808, 2810, 1, 0, 0, 0, 2809,
		2807, 1, 0, 0, 0, 2810, 2811, 5, 2, 0, 0, 2811, 2860, 1, 0, 0, 0, 2812,
		2813, 5, 1, 0, 0, 2813, 2819, 3, 414, 207, 0, 2814, 2815, 3, 662, 331,
		0, 2815, 2816, 3, 414, 207, 0, 2816, 2818, 1, 0, 0, 0, 2817, 2814, 1, 0,
		0, 0, 2818, 2821, 1, 0, 0, 0, 2819, 2817, 1, 0, 0, 0, 2819, 2820, 1, 0,
		0, 0, 2820, 2822, 1, 0, 0, 0, 2821, 2819, 1, 0, 0, 0, 2822, 2823, 5, 2,
		0, 0, 2823, 2824, 7, 0, 0, 0, 2824, 2830, 3, 276, 138, 0, 2825, 2826, 3,
		662, 331, 0, 2826, 2827, 3, 276, 138, 0, 2827, 2829, 1, 0, 0, 0, 2828,
		2825, 1, 0, 0, 0, 2829, 2832, 1, 0, 0, 0, 2830, 2828, 1, 0, 0, 0, 2830,
		2831, 1, 0, 0, 0, 2831, 2860, 1, 0, 0, 0, 2832, 2830, 1, 0, 0, 0, 2833,
		2834, 5, 1, 0, 0, 2834, 2840, 3, 414, 207, 0, 2835, 2836, 3, 662, 331,
		0, 2836, 2837, 3, 414, 207, 0, 2837, 2839, 1, 0, 0, 0, 2838, 2835, 1, 0,
		0, 0, 2839, 2842, 1, 0, 0, 0, 2840, 2838, 1, 0, 0, 0, 2840, 2841, 1, 0,
		0, 0, 2841, 2843, 1, 0, 0, 0, 2842, 2840, 1, 0, 0, 0, 2843, 2844, 5, 2,
		0, 0, 2844, 2845, 7, 0, 0, 0, 2845, 2846, 3, 380, 190, 0, 2846, 2860, 1,
		0, 0, 0, 2847, 2848, 3, 380, 190, 0, 2848, 2849, 7, 0, 0, 0, 2849, 2850,
		5, 1, 0, 0, 2850, 2851, 3, 388, 194, 0, 2851, 2852, 5, 2, 0, 0, 2852, 2860,
		1, 0, 0, 0, 2853, 2860, 3, 378, 189, 0, 2854, 2860, 3, 376, 188, 0, 2855,
		2856, 3, 414, 207, 0, 2856, 2857, 3, 684, 342, 0, 2857, 2858, 3, 390, 195,
		0, 2858, 2860, 1, 0, 0, 0, 2859, 2758, 1, 0, 0, 0, 2859, 2762, 1, 0, 0,
		0, 2859, 2766, 1, 0, 0, 0, 2859, 2772, 1, 0, 0, 0, 2859, 2776, 1, 0, 0,
		0, 2859, 2780, 1, 0, 0, 0, 2859, 2788, 1, 0, 0, 0, 2859, 2812, 1, 0, 0,
		0, 2859, 2833, 1, 0, 0, 0, 2859, 2847, 1, 0, 0, 0, 2859, 2853, 1, 0, 0,
		0, 2859, 2854, 1, 0, 0, 0, 2859, 2855, 1, 0, 0, 0, 2860, 375, 1, 0, 0,
		0, 2861, 2862, 3, 414, 207, 0, 2862, 2863, 3, 490, 245, 0, 2863, 2864,
		3, 390, 195, 0, 2864, 377, 1, 0, 0, 0, 2865, 2866, 3, 414, 207, 0, 2866,
		2867, 3, 490, 245, 0, 2867, 2868, 3, 544, 272, 0, 2868, 2869, 1, 0, 0,
		0, 2869, 2870, 3, 390, 195, 0, 2870, 379, 1, 0, 0, 0, 2871, 2872, 5, 177,
		0, 0, 2872, 2874, 5, 1, 0, 0, 2873, 2875, 3, 388, 194, 0, 2874, 2873, 1,
		0, 0, 0, 2874, 2875, 1, 0, 0, 0, 2875, 2876, 1, 0, 0, 0, 2876, 2879, 5,
		2, 0, 0, 2877, 2879, 5, 177, 0, 0, 2878, 2871, 1, 0, 0, 0, 2878, 2877,
		1, 0, 0, 0, 2879, 381, 1, 0, 0, 0, 2880, 2881, 5, 208, 0, 0, 2881, 2882,
		5, 1, 0, 0, 2882, 2883, 5, 11, 0, 0, 2883, 2909, 5, 2, 0, 0, 2884, 2885,
		5, 208, 0, 0, 2885, 2887, 5, 1, 0, 0, 2886, 2888, 3, 388, 194, 0, 2887,
		2886, 1, 0, 0, 0, 2887, 2888, 1, 0, 0, 0, 2888, 2889, 1, 0, 0, 0, 2889,
		2909, 5, 2, 0, 0, 2890, 2891, 5, 136, 0, 0, 2891, 2892, 5, 1, 0, 0, 2892,
		2909, 5, 2, 0, 0, 2893, 2894, 3, 686, 343, 0, 2894, 2895, 5, 1, 0, 0, 2895,
		2896, 5, 208, 0, 0, 2896, 2897, 5, 2, 0, 0, 2897, 2909, 1, 0, 0, 0, 2898,
		2899, 3, 622, 311, 0, 2899, 2900, 5, 1, 0, 0, 2900, 2901, 5, 208, 0, 0,
		2901, 2902, 5, 2, 0, 0, 2902, 2909, 1, 0, 0, 0, 2903, 2904, 3, 688, 344,
		0, 2904, 2905, 5, 1, 0, 0, 2905, 2906, 3, 388, 194, 0, 2906, 2907, 5, 2,
		0, 0, 2907, 2909, 1, 0, 0, 0, 2908, 2880, 1, 0, 0, 0, 2908, 2884, 1, 0,
		0, 0, 2908, 2890, 1, 0, 0, 0, 2908, 2893, 1, 0, 0, 0, 2908, 2898, 1, 0,
		0, 0, 2908, 2903, 1, 0, 0, 0, 2909, 383, 1, 0, 0, 0, 2910, 2911, 3, 682,
		341, 0, 2911, 2912, 3, 646, 323, 0, 2912, 2913, 5, 208, 0, 0, 2913, 2914,
		3, 472, 236, 0, 2914, 2915, 3, 420, 210, 0, 2915, 2916, 3, 648, 324, 0,
		2916, 385, 1, 0, 0, 0, 2917, 2918, 5, 208, 0, 0, 2918, 2919, 5, 10, 0,
		0, 2919, 2920, 5, 208, 0, 0, 2920, 2922, 5, 1, 0, 0, 2921, 2923, 3, 388,
		194, 0, 2922, 2921, 1, 0, 0, 0, 2922, 2923, 1, 0, 0, 0, 2923, 2924, 1,
		0, 0, 0, 2924, 2925, 5, 2, 0, 0, 2925, 387, 1, 0, 0, 0, 2926, 2931, 3,
		390, 195, 0, 2927, 2931, 3, 414, 207, 0, 2928, 2931, 3, 382, 191, 0, 2929,
		2931, 3, 386, 193, 0, 2930, 2926, 1, 0, 0, 0, 2930, 2927, 1, 0, 0, 0, 2930,
		2928, 1, 0, 0, 0, 2930, 2929, 1, 0, 0, 0, 2931, 2941, 1, 0, 0, 0, 2932,
		2937, 3, 662, 331, 0, 2933, 2938, 3, 390, 195, 0, 2934, 2938, 3, 414, 207,
		0, 2935, 2938, 3, 382, 191, 0, 2936, 2938, 3, 386, 193, 0, 2937, 2933,
		1, 0, 0, 0, 2937, 2934, 1, 0, 0, 0, 2937, 2935, 1, 0, 0, 0, 2937, 2936,
		1, 0, 0, 0, 2938, 2940, 1, 0, 0, 0, 2939, 2932, 1, 0, 0, 0, 2940, 2943,
		1, 0, 0, 0, 2941, 2939, 1, 0, 0, 0, 2941, 2942, 1, 0, 0, 0, 2942, 389,
		1, 0, 0, 0, 2943, 2941, 1, 0, 0, 0, 2944, 2957, 5, 209, 0, 0, 2945, 2957,
		3, 400, 200, 0, 2946, 2957, 3, 396, 198, 0, 2947, 2957, 3, 398, 199, 0,
		2948, 2957, 3, 404, 202, 0, 2949, 2957, 3, 402, 201, 0, 2950, 2957, 3,
		52, 26, 0, 2951, 2957, 3, 572, 286, 0, 2952, 2957, 5, 205, 0, 0, 2953,
		2957, 3, 392, 196, 0, 2954, 2957, 3, 394, 197, 0, 2955, 2957, 3, 744, 372,
		0, 2956, 2944, 1, 0, 0, 0, 2956, 2945, 1, 0, 0, 0, 2956, 2946, 1, 0, 0,
		0, 2956, 2947, 1, 0, 0, 0, 2956, 2948, 1, 0, 0, 0, 2956, 2949, 1, 0, 0,
		0, 2956, 2950, 1, 0, 0, 0, 2956, 2951, 1, 0, 0, 0, 2956, 2952, 1, 0, 0,
		0, 2956, 2953, 1, 0, 0, 0, 2956, 2954, 1, 0, 0, 0, 2956, 2955, 1, 0, 0,
		0, 2957, 391, 1, 0, 0, 0, 2958, 2959, 5, 9, 0, 0, 2959, 2960, 5, 208, 0,
		0, 2960, 393, 1, 0, 0, 0, 2961, 2962, 5, 207, 0, 0, 2962, 395, 1, 0, 0,
		0, 2963, 2964, 5, 201, 0, 0, 2964, 397, 1, 0, 0, 0, 2965, 2966, 7, 5, 0,
		0, 2966, 399, 1, 0, 0, 0, 2967, 2968, 5, 200, 0, 0, 2968, 401, 1, 0, 0,
		0, 2969, 2970, 7, 6, 0, 0, 2970, 403, 1, 0, 0, 0, 2971, 2972, 5, 203, 0,
		0, 2972, 405, 1, 0, 0, 0, 2973, 2978, 5, 208, 0, 0, 2974, 2975, 5, 17,
		0, 0, 2975, 2976, 5, 208, 0, 0, 2976, 2978, 5, 17, 0, 0, 2977, 2973, 1,
		0, 0, 0, 2977, 2974, 1, 0, 0, 0, 2978, 407, 1, 0, 0, 0, 2979, 2983, 5,
		208, 0, 0, 2980, 2983, 3, 416, 208, 0, 2981, 2983, 3, 418, 209, 0, 2982,
		2979, 1, 0, 0, 0, 2982, 2980, 1, 0, 0, 0, 2982, 2981, 1, 0, 0, 0, 2983,
		409, 1, 0, 0, 0, 2984, 2990, 5, 208, 0, 0, 2985, 2986, 5, 17, 0, 0, 2986,
		2987, 5, 208, 0, 0, 2987, 2990, 5, 17, 0, 0, 2988, 2990, 3, 412, 206, 0,
		2989, 2984, 1, 0, 0, 0, 2989, 2985, 1, 0, 0, 0, 2989, 2988, 1, 0, 0, 0,
		2990, 411, 1, 0, 0, 0, 2991, 2992, 7, 7, 0, 0, 2992, 413, 1, 0, 0, 0, 2993,
		2996, 5, 208, 0, 0, 2994, 2996, 3, 412, 206, 0, 2995, 2993, 1, 0, 0, 0,
		2995, 2994, 1, 0, 0, 0, 2996, 415, 1, 0, 0, 0, 2997, 2998, 7, 8, 0, 0,
		2998, 417, 1, 0, 0, 0, 2999, 3000, 7, 9, 0, 0, 3000, 419, 1, 0, 0, 0, 3001,
		3003, 3, 422, 211, 0, 3002, 3004, 3, 424, 212, 0, 3003, 3002, 1, 0, 0,
		0, 3003, 3004, 1, 0, 0, 0, 3004, 421, 1, 0, 0, 0, 3005, 3006, 7, 10, 0,
		0, 3006, 423, 1, 0, 0, 0, 3007, 3008, 3, 654, 327, 0, 3008, 3014, 3, 426,
		213, 0, 3009, 3010, 3, 662, 331, 0, 3010, 3011, 3, 426, 213, 0, 3011, 3013,
		1, 0, 0, 0, 3012, 3009, 1, 0, 0, 0, 3013, 3016, 1, 0, 0, 0, 3014, 3012,
		1, 0, 0, 0, 3014, 3015, 1, 0, 0, 0, 3015, 3017, 1, 0, 0, 0, 3016, 3014,
		1, 0, 0, 0, 3017, 3018, 3, 656, 328, 0, 3018, 425, 1, 0, 0, 0, 3019, 3022,
		3, 420, 210, 0, 3020, 3022, 3, 396, 198, 0, 3021, 3019, 1, 0, 0, 0, 3021,
		3020, 1, 0, 0, 0, 3022, 427, 1, 0, 0, 0, 3023, 3026, 3, 474, 237, 0, 3024,
		3026, 3, 496, 248, 0, 3025, 3023, 1, 0, 0, 0, 3025, 3024, 1, 0, 0, 0, 3026,
		429, 1, 0, 0, 0, 3027, 3028, 5, 208, 0, 0, 3028, 431, 1, 0, 0, 0, 3029,
		3030, 5, 208, 0, 0, 3030, 433, 1, 0, 0, 0, 3031, 3032, 3, 400, 200, 0,
		3032, 435, 1, 0, 0, 0, 3033, 3034, 5, 208, 0, 0, 3034, 437, 1, 0, 0, 0,
		3035, 3036, 5, 208, 0, 0, 3036, 439, 1, 0, 0, 0, 3037, 3038, 5, 208, 0,
		0, 3038, 441, 1, 0, 0, 0, 3039, 3040, 5, 208, 0, 0, 3040, 443, 1, 0, 0,
		0, 3041, 3042, 5, 208, 0, 0, 3042, 445, 1, 0, 0, 0, 3043, 3044, 5, 208,
		0, 0, 3044, 447, 1, 0, 0, 0, 3045, 3046, 3, 400, 200, 0, 3046, 449, 1,
		0, 0, 0, 3047, 3048, 5, 208, 0, 0, 3048, 451, 1, 0, 0, 0, 3049, 3050, 3,
		454, 227, 0, 3050, 3051, 3, 420, 210, 0, 3051, 453, 1, 0, 0, 0, 3052, 3053,
		7, 11, 0, 0, 3053, 455, 1, 0, 0, 0, 3054, 3055, 5, 24, 0, 0, 3055, 457,
		1, 0, 0, 0, 3056, 3057, 5, 25, 0, 0, 3057, 459, 1, 0, 0, 0, 3058, 3059,
		5, 26, 0, 0, 3059, 461, 1, 0, 0, 0, 3060, 3061, 5, 26, 0, 0, 3061, 3062,
		5, 102, 0, 0, 3062, 463, 1, 0, 0, 0, 3063, 3064, 5, 27, 0, 0, 3064, 465,
		1, 0, 0, 0, 3065, 3066, 5, 28, 0, 0, 3066, 467, 1, 0, 0, 0, 3067, 3068,
		5, 29, 0, 0, 3068, 469, 1, 0, 0, 0, 3069, 3070, 5, 31, 0, 0, 3070, 471,
		1, 0, 0, 0, 3071, 3072, 5, 32, 0, 0, 3072, 473, 1, 0, 0, 0, 3073, 3074,
		5, 33, 0, 0, 3074, 475, 1, 0, 0, 0, 3075, 3076, 5, 34, 0, 0, 3076, 477,
		1, 0, 0, 0, 3077, 3078, 5, 35, 0, 0, 3078, 479, 1, 0, 0, 0, 3079, 3080,
		5, 36, 0, 0, 3080, 481, 1, 0, 0, 0, 3081, 3082, 5, 37, 0, 0, 3082, 483,
		1, 0, 0, 0, 3083, 3084, 5, 38, 0, 0, 3084, 485, 1, 0, 0, 0, 3085, 3086,
		5, 39, 0, 0, 3086, 487, 1, 0, 0, 0, 3087, 3088, 5, 41, 0, 0, 3088, 489,
		1, 0, 0, 0, 3089, 3090, 5, 43, 0, 0, 3090, 491, 1, 0, 0, 0, 3091, 3092,
		5, 44, 0, 0, 3092, 493, 1, 0, 0, 0, 3093, 3094, 5, 46, 0, 0, 3094, 495,
		1, 0, 0, 0, 3095, 3096, 5, 47, 0, 0, 3096, 497, 1, 0, 0, 0, 3097, 3098,
		5, 48, 0, 0, 3098, 499, 1, 0, 0, 0, 3099, 3100, 5, 49, 0, 0, 3100, 501,
		1, 0, 0, 0, 3101, 3102, 5, 50, 0, 0, 3102, 503, 1, 0, 0, 0, 3103, 3104,
		5, 51, 0, 0, 3104, 505, 1, 0, 0, 0, 3105, 3106, 5, 53, 0, 0, 3106, 507,
		1, 0, 0, 0, 3107, 3108, 5, 54, 0, 0, 3108, 509, 1, 0, 0, 0, 3109, 3110,
		5, 55, 0, 0, 3110, 511, 1, 0, 0, 0, 3111, 3112, 5, 57, 0, 0, 3112, 513,
		1, 0, 0, 0, 3113, 3114, 5, 58, 0, 0, 3114, 515, 1, 0, 0, 0, 3115, 3116,
		5, 59, 0, 0, 3116, 517, 1, 0, 0, 0, 3117, 3118, 5, 60, 0, 0, 3118, 519,
		1, 0, 0, 0, 3119, 3120, 5, 61, 0, 0, 3120, 521, 1, 0, 0, 0, 3121, 3122,
		5, 62, 0, 0, 3122, 523, 1, 0, 0, 0, 3123, 3124, 5, 63, 0, 0, 3124, 525,
		1, 0, 0, 0, 3125, 3126, 5, 64, 0, 0, 3126, 527, 1, 0, 0, 0, 3127, 3128,
		5, 65, 0, 0, 3128, 529, 1, 0, 0, 0, 3129, 3130, 5, 66, 0, 0, 3130, 531,
		1, 0, 0, 0, 3131, 3132, 5, 68, 0, 0, 3132, 533, 1, 0, 0, 0, 3133, 3134,
		5, 69, 0, 0, 3134, 535, 1, 0, 0, 0, 3135, 3136, 5, 70, 0, 0, 3136, 537,
		1, 0, 0, 0, 3137, 3138, 5, 71, 0, 0, 3138, 539, 1, 0, 0, 0, 3139, 3140,
		5, 72, 0, 0, 3140, 541, 1, 0, 0, 0, 3141, 3142, 5, 73, 0, 0, 3142, 543,
		1, 0, 0, 0, 3143, 3144, 5, 74, 0, 0, 3144, 545, 1, 0, 0, 0, 3145, 3146,
		5, 75, 0, 0, 3146, 547, 1, 0, 0, 0, 3147, 3148, 5, 76, 0, 0, 3148, 549,
		1, 0, 0, 0, 3149, 3150, 5, 77, 0, 0, 3150, 551, 1, 0, 0, 0, 3151, 3152,
		5, 78, 0, 0, 3152, 553, 1, 0, 0, 0, 3153, 3154, 5, 80, 0, 0, 3154, 555,
		1, 0, 0, 0, 3155, 3156, 5, 154, 0, 0, 3156, 557, 1, 0, 0, 0, 3157, 3158,
		5, 83, 0, 0, 3158, 559, 1, 0, 0, 0, 3159, 3160, 5, 84, 0, 0, 3160, 561,
		1, 0, 0, 0, 3161, 3162, 5, 85, 0, 0, 3162, 563, 1, 0, 0, 0, 3163, 3164,
		5, 86, 0, 0, 3164, 565, 1, 0, 0, 0, 3165, 3166, 5, 89, 0, 0, 3166, 567,
		1, 0, 0, 0, 3167, 3168, 5, 88, 0, 0, 3168, 569, 1, 0, 0, 0, 3169, 3170,
		5, 90, 0, 0, 3170, 571, 1, 0, 0, 0, 3171, 3172, 5, 91, 0, 0, 3172, 573,
		1, 0, 0, 0, 3173, 3174, 5, 92, 0, 0, 3174, 575, 1, 0, 0, 0, 3175, 3176,
		5, 93, 0, 0, 3176, 577, 1, 0, 0, 0, 3177, 3178, 5, 95, 0, 0, 3178, 579,
		1, 0, 0, 0, 3179, 3180, 5, 96, 0, 0, 3180, 581, 1, 0, 0, 0, 3181, 3182,
		5, 97, 0, 0, 3182, 583, 1, 0, 0, 0, 3183, 3184, 5, 99, 0, 0, 3184, 585,
		1, 0, 0, 0, 3185, 3186, 5, 103, 0, 0, 3186, 587, 1, 0, 0, 0, 3187, 3188,
		5, 105, 0, 0, 3188, 589, 1, 0, 0, 0, 3189, 3190, 5, 106, 0, 0, 3190, 591,
		1, 0, 0, 0, 3191, 3192, 5, 107, 0, 0, 3192, 593, 1, 0, 0, 0, 3193, 3194,
		5, 108, 0, 0, 3194, 595, 1, 0, 0, 0, 3195, 3196, 5, 110, 0, 0, 3196, 597,
		1, 0, 0, 0, 3197, 3198, 5, 111, 0, 0, 3198, 599, 1, 0, 0, 0, 3199, 3200,
		5, 113, 0, 0, 3200, 601, 1, 0, 0, 0, 3201, 3202, 5, 114, 0, 0, 3202, 603,
		1, 0, 0, 0, 3203, 3204, 5, 115, 0, 0, 3204, 605, 1, 0, 0, 0, 3205, 3206,
		5, 117, 0, 0, 3206, 607, 1, 0, 0, 0, 3207, 3208, 5, 118, 0, 0, 3208, 609,
		1, 0, 0, 0, 3209, 3210, 5, 119, 0, 0, 3210, 611, 1, 0, 0, 0, 3211, 3212,
		5, 120, 0, 0, 3212, 613, 1, 0, 0, 0, 3213, 3214, 5, 122, 0, 0, 3214, 615,
		1, 0, 0, 0, 3215, 3216, 5, 123, 0, 0, 3216, 617, 1, 0, 0, 0, 3217, 3218,
		5, 125, 0, 0, 3218, 619, 1, 0, 0, 0, 3219, 3220, 5, 127, 0, 0, 3220, 621,
		1, 0, 0, 0, 3221, 3222, 5, 128, 0, 0, 3222, 623, 1, 0, 0, 0, 3223, 3224,
		5, 130, 0, 0, 3224, 625, 1, 0, 0, 0, 3225, 3226, 5, 131, 0, 0, 3226, 627,
		1, 0, 0, 0, 3227, 3228, 5, 132, 0, 0, 3228, 629, 1, 0, 0, 0, 3229, 3230,
		5, 133, 0, 0, 3230, 631, 1, 0, 0, 0, 3231, 3232, 5, 134, 0, 0, 3232, 633,
		1, 0, 0, 0, 3233, 3234, 5, 135, 0, 0, 3234, 635, 1, 0, 0, 0, 3235, 3236,
		5, 137, 0, 0, 3236, 637, 1, 0, 0, 0, 3237, 3238, 5, 138, 0, 0, 3238, 639,
		1, 0, 0, 0, 3239, 3240, 5, 139, 0, 0, 3240, 641, 1, 0, 0, 0, 3241, 3242,
		5, 140, 0, 0, 3242, 643, 1, 0, 0, 0, 3243, 3244, 5, 109, 0, 0, 3244, 645,
		1, 0, 0, 0, 3245, 3246, 5, 1, 0, 0, 3246, 647, 1, 0, 0, 0, 3247, 3248,
		5, 2, 0, 0, 3248, 649, 1, 0, 0, 0, 3249, 3250, 5, 3, 0, 0, 3250, 651, 1,
		0, 0, 0, 3251, 3252, 5, 4, 0, 0, 3252, 653, 1, 0, 0, 0, 3253, 3254, 5,
		20, 0, 0, 3254, 655, 1, 0, 0, 0, 3255, 3256, 5, 21, 0, 0, 3256, 657, 1,
		0, 0, 0, 3257, 3258, 5, 5, 0, 0, 3258, 659, 1, 0, 0, 0, 3259, 3260, 5,
		6, 0, 0, 3260, 661, 1, 0, 0, 0, 3261, 3262, 5, 7, 0, 0, 3262, 663, 1, 0,
		0, 0, 3263, 3264, 5, 9, 0, 0, 3264, 665, 1, 0, 0, 0, 3265, 3266, 5, 164,
		0, 0, 3266, 667, 1, 0, 0, 0, 3267, 3268, 5, 165, 0, 0, 3268, 669, 1, 0,
		0, 0, 3269, 3270, 5, 166, 0, 0, 3270, 671, 1, 0, 0, 0, 3271, 3272, 5, 167,
		0, 0, 3272, 673, 1, 0, 0, 0, 3273, 3274, 5, 100, 0, 0, 3274, 675, 1, 0,
		0, 0, 3275, 3276, 5, 98, 0, 0, 3276, 677, 1, 0, 0, 0, 3277, 3278, 5, 168,
		0, 0, 3278, 679, 1, 0, 0, 0, 3279, 3280, 5, 116, 0, 0, 3280, 681, 1, 0,
		0, 0, 3281, 3282, 5, 172, 0, 0, 3282, 683, 1, 0, 0, 0, 3283, 3284, 5, 171,
		0, 0, 3284, 685, 1, 0, 0, 0, 3285, 3286, 5, 141, 0, 0, 3286, 687, 1, 0,
		0, 0, 3287, 3288, 5, 124, 0, 0, 3288, 689, 1, 0, 0, 0, 3289, 3290, 5, 174,
		0, 0, 3290, 691, 1, 0, 0, 0, 3291, 3292, 5, 175, 0, 0, 3292, 693, 1, 0,
		0, 0, 3293, 3294, 5, 176, 0, 0, 3294, 695, 1, 0, 0, 0, 3295, 3296, 5, 146,
		0, 0, 3296, 697, 1, 0, 0, 0, 3297, 3298, 5, 48, 0, 0, 3298, 699, 1, 0,
		0, 0, 3299, 3300, 5, 178, 0, 0, 3300, 701, 1, 0, 0, 0, 3301, 3302, 5, 179,
		0, 0, 3302, 703, 1, 0, 0, 0, 3303, 3304, 5, 180, 0, 0, 3304, 705, 1, 0,
		0, 0, 3305, 3306, 5, 181, 0, 0, 3306, 707, 1, 0, 0, 0, 3307, 3308, 5, 112,
		0, 0, 3308, 709, 1, 0, 0, 0, 3309, 3310, 5, 182, 0, 0, 3310, 711, 1, 0,
		0, 0, 3311, 3312, 5, 183, 0, 0, 3312, 713, 1, 0, 0, 0, 3313, 3314, 5, 184,
		0, 0, 3314, 715, 1, 0, 0, 0, 3315, 3316, 5, 40, 0, 0, 3316, 717, 1, 0,
		0, 0, 3317, 3318, 5, 185, 0, 0, 3318, 719, 1, 0, 0, 0, 3319, 3320, 5, 79,
		0, 0, 3320, 721, 1, 0, 0, 0, 3321, 3322, 5, 186, 0, 0, 3322, 723, 1, 0,
		0, 0, 3323, 3324, 5, 187, 0, 0, 3324, 725, 1, 0, 0, 0, 3325, 3326, 5, 188,
		0, 0, 3326, 727, 1, 0, 0, 0, 3327, 3328, 5, 189, 0, 0, 3328, 729, 1, 0,
		0, 0, 3329, 3330, 5, 190, 0, 0, 3330, 731, 1, 0, 0, 0, 3331, 3332, 5, 45,
		0, 0, 3332, 733, 1, 0, 0, 0, 3333, 3334, 5, 191, 0, 0, 3334, 735, 1, 0,
		0, 0, 3335, 3336, 5, 192, 0, 0, 3336, 737, 1, 0, 0, 0, 3337, 3338, 5, 193,
		0, 0, 3338, 739, 1, 0, 0, 0, 3339, 3340, 5, 194, 0, 0, 3340, 741, 1, 0,
		0, 0, 3341, 3342, 5, 195, 0, 0, 3342, 743, 1, 0, 0, 0, 3343, 3344, 5, 196,
		0, 0, 3344, 745, 1, 0, 0, 0, 3345, 3346, 5, 197, 0, 0, 3346, 747, 1, 0,
		0, 0, 3347, 3348, 5, 198, 0, 0, 3348, 749, 1, 0, 0, 0, 269, 751, 754, 760,
		765, 767, 772, 775, 778, 831, 842, 848, 851, 861, 866, 877, 888, 903, 914,
		919, 928, 933, 941, 946, 950, 955, 960, 975, 981, 986, 996, 1001, 1009,
		1015, 1024, 1036, 1043, 1051, 1065, 1070, 1082, 1087, 1091, 1095, 1100,
		1105, 1124, 1131, 1139, 1143, 1148, 1161, 1166, 1171, 1177, 1186, 1201,
		1203, 1215, 1229, 1236, 1243, 1251, 1262, 1278, 1291, 1301, 1324, 1331,
		1341, 1346, 1356, 1363, 1372, 1400, 1408, 1414, 1419, 1426, 1431, 1439,
		1444, 1451, 1456, 1463, 1468, 1473, 1480, 1487, 1494, 1501, 1506, 1513,
		1520, 1525, 1532, 1537, 1544, 1554, 1560, 1568, 1571, 1579, 1584, 1588,
		1601, 1607, 1616, 1631, 1639, 1645, 1650, 1653, 1669, 1689, 1698, 1710,
		1714, 1717, 1725, 1730, 1737, 1741, 1745, 1748, 1754, 1758, 1765, 1769,
		1773, 1778, 1782, 1786, 1791, 1805, 1813, 1822, 1840, 1848, 1855, 1860,
		1866, 1870, 1873, 1879, 1886, 1891, 1900, 1906, 1924, 1928, 1932, 1937,
		1945, 1953, 1957, 1960, 1966, 1970, 1977, 1986, 1994, 2002, 2022, 2025,
		2062, 2070, 2078, 2088, 2139, 2145, 2154, 2157, 2164, 2173, 2176, 2187,
		2193, 2202, 2205, 2213, 2222, 2228, 2235, 2239, 2243, 2246, 2292, 2319,
		2336, 2338, 2346, 2358, 2367, 2376, 2380, 2383, 2388, 2391, 2394, 2397,
		2400, 2403, 2406, 2409, 2436, 2440, 2443, 2447, 2451, 2455, 2460, 2464,
		2468, 2473, 2480, 2488, 2497, 2506, 2515, 2524, 2528, 2535, 2539, 2550,
		2556, 2567, 2602, 2610, 2620, 2624, 2648, 2668, 2677, 2684, 2689, 2694,
		2698, 2710, 2717, 2727, 2733, 2739, 2745, 2747, 2755, 2784, 2795, 2807,
		2819, 2830, 2840, 2859, 2874, 2878, 2887, 2908, 2922, 2930, 2937, 2941,
		2956, 2977, 2982, 2989, 2995, 3003, 3014, 3021, 3025,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// CqlParserInit initializes any static state used to implement CqlParser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewCqlParser(). You can call this function if you wish to initialize the static state ahead
// of time.
func CqlParserInit() {
	staticData := &CqlParserParserStaticData
	staticData.once.Do(cqlparserParserInit)
}

// NewCqlParser produces a new parser instance for the optional input antlr.TokenStream.
func NewCqlParser(input antlr.TokenStream) *CqlParser {
	CqlParserInit()
	this := new(CqlParser)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &CqlParserParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.PredictionContextCache)
	this.RuleNames = staticData.RuleNames
	this.LiteralNames = staticData.LiteralNames
	this.SymbolicNames = staticData.SymbolicNames
	this.GrammarFileName = "CqlParser.g4"

	return this
}

// CqlParser tokens.
const (
	CqlParserEOF                       = antlr.TokenEOF
	CqlParserLR_BRACKET                = 1
	CqlParserRR_BRACKET                = 2
	CqlParserLC_BRACKET                = 3
	CqlParserRC_BRACKET                = 4
	CqlParserLS_BRACKET                = 5
	CqlParserRS_BRACKET                = 6
	CqlParserCOMMA                     = 7
	CqlParserSEMI                      = 8
	CqlParserCOLON                     = 9
	CqlParserDOT                       = 10
	CqlParserSTAR                      = 11
	CqlParserDIVIDE                    = 12
	CqlParserMODULE                    = 13
	CqlParserPLUS                      = 14
	CqlParserMINUSMINUS                = 15
	CqlParserMINUS                     = 16
	CqlParserDQUOTE                    = 17
	CqlParserSQUOTE                    = 18
	CqlParserOPERATOR_EQ               = 19
	CqlParserOPERATOR_LT               = 20
	CqlParserOPERATOR_GT               = 21
	CqlParserOPERATOR_LTE              = 22
	CqlParserOPERATOR_GTE              = 23
	CqlParserK_ADD                     = 24
	CqlParserK_AGGREGATE               = 25
	CqlParserK_ALL                     = 26
	CqlParserK_ALLOW                   = 27
	CqlParserK_ALTER                   = 28
	CqlParserK_AND                     = 29
	CqlParserK_ANY                     = 30
	CqlParserK_APPLY                   = 31
	CqlParserK_AS                      = 32
	CqlParserK_ASC                     = 33
	CqlParserK_AUTHORIZE               = 34
	CqlParserK_BATCH                   = 35
	CqlParserK_BEGIN                   = 36
	CqlParserK_BY                      = 37
	CqlParserK_CALLED                  = 38
	CqlParserK_CLUSTERING              = 39
	CqlParserK_COLUMNFAMILY            = 40
	CqlParserK_COMPACT                 = 41
	CqlParserK_CONSISTENCY             = 42
	CqlParserK_CONTAINS                = 43
	CqlParserK_CREATE                  = 44
	CqlParserK_CUSTOM                  = 45
	CqlParserK_DELETE                  = 46
	CqlParserK_DESC                    = 47
	CqlParserK_DESCRIBE                = 48
	CqlParserK_DISTINCT                = 49
	CqlParserK_DROP                    = 50
	CqlParserK_DURABLE_WRITES          = 51
	CqlParserK_EACH_QUORUM             = 52
	CqlParserK_ENTRIES                 = 53
	CqlParserK_EXECUTE                 = 54
	CqlParserK_EXISTS                  = 55
	CqlParserK_FALSE                   = 56
	CqlParserK_FILTERING               = 57
	CqlParserK_FINALFUNC               = 58
	CqlParserK_FROM                    = 59
	CqlParserK_FULL                    = 60
	CqlParserK_FUNCTION                = 61
	CqlParserK_FUNCTIONS               = 62
	CqlParserK_GRANT                   = 63
	CqlParserK_IF                      = 64
	CqlParserK_IN                      = 65
	CqlParserK_INDEX                   = 66
	CqlParserK_INFINITY                = 67
	CqlParserK_INITCOND                = 68
	CqlParserK_INPUT                   = 69
	CqlParserK_INSERT                  = 70
	CqlParserK_INTO                    = 71
	CqlParserK_IS                      = 72
	CqlParserK_JSON                    = 73
	CqlParserK_KEY                     = 74
	CqlParserK_KEYS                    = 75
	CqlParserK_KEYSPACE                = 76
	CqlParserK_KEYSPACES               = 77
	CqlParserK_LANGUAGE                = 78
	CqlParserK_LEVEL                   = 79
	CqlParserK_LIMIT                   = 80
	CqlParserK_LOCAL_ONE               = 81
	CqlParserK_LOCAL_QUORUM            = 82
	CqlParserK_LOGGED                  = 83
	CqlParserK_LOGIN                   = 84
	CqlParserK_MATERIALIZED            = 85
	CqlParserK_MODIFY                  = 86
	CqlParserK_NAN                     = 87
	CqlParserK_NORECURSIVE             = 88
	CqlParserK_NOSUPERUSER             = 89
	CqlParserK_NOT                     = 90
	CqlParserK_NULL                    = 91
	CqlParserK_OF                      = 92
	CqlParserK_ON                      = 93
	CqlParserK_ONE                     = 94
	CqlParserK_OPTIONS                 = 95
	CqlParserK_OR                      = 96
	CqlParserK_ORDER                   = 97
	CqlParserK_PARTITION               = 98
	CqlParserK_PASSWORD                = 99
	CqlParserK_PER                     = 100
	CqlParserK_PERMISSION              = 101
	CqlParserK_PERMISSIONS             = 102
	CqlParserK_PRIMARY                 = 103
	CqlParserK_QUORUM                  = 104
	CqlParserK_RENAME                  = 105
	CqlParserK_REPLACE                 = 106
	CqlParserK_REPLICATION             = 107
	CqlParserK_RETURNS                 = 108
	CqlParserK_REVOKE                  = 109
	CqlParserK_ROLE                    = 110
	CqlParserK_ROLES                   = 111
	CqlParserK_SCHEMA                  = 112
	CqlParserK_SELECT                  = 113
	CqlParserK_SET                     = 114
	CqlParserK_SFUNC                   = 115
	CqlParserK_STATIC                  = 116
	CqlParserK_STORAGE                 = 117
	CqlParserK_STYPE                   = 118
	CqlParserK_SUPERUSER               = 119
	CqlParserK_TABLE                   = 120
	CqlParserK_THREE                   = 121
	CqlParserK_TIMESTAMP               = 122
	CqlParserK_TO                      = 123
	CqlParserK_TOKEN                   = 124
	CqlParserK_TRIGGER                 = 125
	CqlParserK_TRUE                    = 126
	CqlParserK_TRUNCATE                = 127
	CqlParserK_TTL                     = 128
	CqlParserK_TWO                     = 129
	CqlParserK_TYPE                    = 130
	CqlParserK_UNLOGGED                = 131
	CqlParserK_UPDATE                  = 132
	CqlParserK_USE                     = 133
	CqlParserK_USER                    = 134
	CqlParserK_USING                   = 135
	CqlParserK_UUID                    = 136
	CqlParserK_VALUES                  = 137
	CqlParserK_VIEW                    = 138
	CqlParserK_WHERE                   = 139
	CqlParserK_WITH                    = 140
	CqlParserK_WRITETIME               = 141
	CqlParserK_ASCII                   = 142
	CqlParserK_BIGINT                  = 143
	CqlParserK_BLOB                    = 144
	CqlParserK_BOOLEAN                 = 145
	CqlParserK_COUNTER                 = 146
	CqlParserK_DATE                    = 147
	CqlParserK_DECIMAL                 = 148
	CqlParserK_DOUBLE                  = 149
	CqlParserK_FLOAT                   = 150
	CqlParserK_FROZEN                  = 151
	CqlParserK_INET                    = 152
	CqlParserK_INT                     = 153
	CqlParserK_LIST                    = 154
	CqlParserK_MAP                     = 155
	CqlParserK_SMALLINT                = 156
	CqlParserK_TEXT                    = 157
	CqlParserK_TIMEUUID                = 158
	CqlParserK_TIME                    = 159
	CqlParserK_TINYINT                 = 160
	CqlParserK_TUPLE                   = 161
	CqlParserK_VARCHAR                 = 162
	CqlParserK_VARINT                  = 163
	CqlParserK_BYPASS                  = 164
	CqlParserK_CACHE                   = 165
	CqlParserK_TIMEOUT                 = 166
	CqlParserK_PRUNE                   = 167
	CqlParserK_GROUP                   = 168
	CqlParserK_DURATION                = 169
	CqlParserK_VECTOR                  = 170
	CqlParserK_LIKE                    = 171
	CqlParserK_CAST                    = 172
	CqlParserK_VALUE                   = 173
	CqlParserK_TABLETS                 = 174
	CqlParserK_DEFAULT                 = 175
	CqlParserK_UNSET                   = 176
	CqlParserK_SCYLLA_CLUSTERING_BOUND = 177
	CqlParserK_CLUSTER                 = 178
	CqlParserK_ONLY                    = 179
	CqlParserK_INTERNALS               = 180
	CqlParserK_PASSWORDS               = 181
	CqlParserK_TABLES                  = 182
	CqlParserK_TYPES                   = 183
	CqlParserK_AGGREGATES              = 184
	CqlParserK_SERVICE                 = 185
	CqlParserK_LEVELS                  = 186
	CqlParserK_ATTACH                  = 187
	CqlParserK_DETACH                  = 188
	CqlParserK_ATTACHED                = 189
	CqlParserK_EFFECTIVE               = 190
	CqlParserK_ANN                     = 191
	CqlParserK_REDUCEFUNC              = 192
	CqlParserK_NOLOGIN                 = 193
	CqlParserK_USERS                   = 194
	CqlParserK_HASHED                  = 195
	CqlParserK_EMPTY                   = 196
	CqlParserK_CONCURRENCY             = 197
	CqlParserK_VECTOR_SEARCH_INDEXING  = 198
	CqlParserCODE_BLOCK                = 199
	CqlParserSTRING_LITERAL            = 200
	CqlParserDECIMAL_LITERAL           = 201
	CqlParserFLOAT_LITERAL             = 202
	CqlParserHEXADECIMAL_LITERAL       = 203
	CqlParserREAL_LITERAL              = 204
	CqlParserQMARK                     = 205
	CqlParserOPERATOR_NEQ              = 206
	CqlParserDURATION_LITERAL          = 207
	CqlParserOBJECT_NAME               = 208
	CqlParserUUID                      = 209
	CqlParserSPACE                     = 210
	CqlParserSPEC_MYSQL_COMMENT        = 211
	CqlParserCOMMENT_INPUT             = 212
	CqlParserLINE_COMMENT              = 213
	CqlParserK_COLUMNS                 = 214
	CqlParserK_VIEWS                   = 215
	CqlParserK_INDEXES                 = 216
)

// CqlParser rules.
const (
	CqlParserRULE_root                         = 0
	CqlParserRULE_cqls                         = 1
	CqlParserRULE_statementSeparator           = 2
	CqlParserRULE_empty_                       = 3
	CqlParserRULE_cql                          = 4
	CqlParserRULE_revoke                       = 5
	CqlParserRULE_listRoles                    = 6
	CqlParserRULE_listUsers                    = 7
	CqlParserRULE_listPermissions              = 8
	CqlParserRULE_grant                        = 9
	CqlParserRULE_priviledge                   = 10
	CqlParserRULE_resource                     = 11
	CqlParserRULE_createUser                   = 12
	CqlParserRULE_createRole                   = 13
	CqlParserRULE_createType                   = 14
	CqlParserRULE_typeMemberColumnList         = 15
	CqlParserRULE_createTrigger                = 16
	CqlParserRULE_createMaterializedView       = 17
	CqlParserRULE_mvWhereSpec                  = 18
	CqlParserRULE_mvWhereClause                = 19
	CqlParserRULE_materializedViewWhere        = 20
	CqlParserRULE_columnNotNullList            = 21
	CqlParserRULE_columnNotNull                = 22
	CqlParserRULE_materializedViewOptions      = 23
	CqlParserRULE_createKeyspace               = 24
	CqlParserRULE_createFunction               = 25
	CqlParserRULE_codeBlock                    = 26
	CqlParserRULE_paramList                    = 27
	CqlParserRULE_returnMode                   = 28
	CqlParserRULE_createAggregate              = 29
	CqlParserRULE_initCondDefinition           = 30
	CqlParserRULE_initCondHash                 = 31
	CqlParserRULE_initCondHashItem             = 32
	CqlParserRULE_initCondListNested           = 33
	CqlParserRULE_initCondList                 = 34
	CqlParserRULE_orReplace                    = 35
	CqlParserRULE_alterUser                    = 36
	CqlParserRULE_userPassword                 = 37
	CqlParserRULE_userSuperUser                = 38
	CqlParserRULE_alterType                    = 39
	CqlParserRULE_alterTypeOperation           = 40
	CqlParserRULE_alterTypeRename              = 41
	CqlParserRULE_alterTypeRenameList          = 42
	CqlParserRULE_alterTypeRenameItem          = 43
	CqlParserRULE_alterTypeAdd                 = 44
	CqlParserRULE_alterTypeAlterType           = 45
	CqlParserRULE_alterTable                   = 46
	CqlParserRULE_alterTableOperation          = 47
	CqlParserRULE_alterTableWith               = 48
	CqlParserRULE_alterTableRename             = 49
	CqlParserRULE_alterTableDropCompactStorage = 50
	CqlParserRULE_alterTableDropColumns        = 51
	CqlParserRULE_alterTableDropColumnList     = 52
	CqlParserRULE_alterTableAdd                = 53
	CqlParserRULE_alterTableColumnDefinition   = 54
	CqlParserRULE_alterRole                    = 55
	CqlParserRULE_roleWith                     = 56
	CqlParserRULE_roleWithOptions              = 57
	CqlParserRULE_alterMaterializedView        = 58
	CqlParserRULE_dropUser                     = 59
	CqlParserRULE_dropType                     = 60
	CqlParserRULE_dropMaterializedView         = 61
	CqlParserRULE_dropAggregate                = 62
	CqlParserRULE_dropFunction                 = 63
	CqlParserRULE_dropTrigger                  = 64
	CqlParserRULE_dropRole                     = 65
	CqlParserRULE_dropTable                    = 66
	CqlParserRULE_dropKeyspace                 = 67
	CqlParserRULE_dropIndex                    = 68
	CqlParserRULE_createTable                  = 69
	CqlParserRULE_withElement                  = 70
	CqlParserRULE_tableOptions                 = 71
	CqlParserRULE_clusteringOrder              = 72
	CqlParserRULE_tableOptionItem              = 73
	CqlParserRULE_tableOptionName              = 74
	CqlParserRULE_tableOptionValue             = 75
	CqlParserRULE_optionHash                   = 76
	CqlParserRULE_optionHashItem               = 77
	CqlParserRULE_optionHashKey                = 78
	CqlParserRULE_optionHashValue              = 79
	CqlParserRULE_columnDefinitionList         = 80
	CqlParserRULE_columnDefinition             = 81
	CqlParserRULE_primaryKeyColumn             = 82
	CqlParserRULE_staticColumn                 = 83
	CqlParserRULE_primaryKeyElement            = 84
	CqlParserRULE_primaryKeyDefinition         = 85
	CqlParserRULE_singlePrimaryKey             = 86
	CqlParserRULE_compoundKey                  = 87
	CqlParserRULE_compositeKey                 = 88
	CqlParserRULE_partitionKeyList             = 89
	CqlParserRULE_clusteringKeyList            = 90
	CqlParserRULE_partitionKey                 = 91
	CqlParserRULE_clusteringKey                = 92
	CqlParserRULE_applyBatch                   = 93
	CqlParserRULE_batch                        = 94
	CqlParserRULE_batchStatementList           = 95
	CqlParserRULE_batchStatement               = 96
	CqlParserRULE_batchInsert                  = 97
	CqlParserRULE_batchUpdate                  = 98
	CqlParserRULE_batchDelete                  = 99
	CqlParserRULE_beginBatch                   = 100
	CqlParserRULE_batchType                    = 101
	CqlParserRULE_alterKeyspace                = 102
	CqlParserRULE_replicationList              = 103
	CqlParserRULE_replicationListItem          = 104
	CqlParserRULE_durableWrites                = 105
	CqlParserRULE_tabletsSpec                  = 106
	CqlParserRULE_tabletsOptions               = 107
	CqlParserRULE_tabletsOption                = 108
	CqlParserRULE_use_                         = 109
	CqlParserRULE_truncate                     = 110
	CqlParserRULE_createIndex                  = 111
	CqlParserRULE_indexUsing                   = 112
	CqlParserRULE_indexOptions                 = 113
	CqlParserRULE_indexName                    = 114
	CqlParserRULE_indexColumnSpec              = 115
	CqlParserRULE_indexKeysSpec                = 116
	CqlParserRULE_indexEntriesSSpec            = 117
	CqlParserRULE_indexFullSpec                = 118
	CqlParserRULE_delete_                      = 119
	CqlParserRULE_deleteColumnList             = 120
	CqlParserRULE_deleteColumnItem             = 121
	CqlParserRULE_update                       = 122
	CqlParserRULE_ifSpec                       = 123
	CqlParserRULE_ifConditionList              = 124
	CqlParserRULE_ifCondition                  = 125
	CqlParserRULE_ifConditionValue             = 126
	CqlParserRULE_assignments                  = 127
	CqlParserRULE_assignmentElement            = 128
	CqlParserRULE_assignmentIndexKey           = 129
	CqlParserRULE_assignmentSet                = 130
	CqlParserRULE_assignmentSetElement         = 131
	CqlParserRULE_assignmentMap                = 132
	CqlParserRULE_assignmentMapEntry           = 133
	CqlParserRULE_assignmentMapKey             = 134
	CqlParserRULE_assignmentMapValue           = 135
	CqlParserRULE_assignmentList               = 136
	CqlParserRULE_assignmentListElement        = 137
	CqlParserRULE_assignmentTuple              = 138
	CqlParserRULE_insert                       = 139
	CqlParserRULE_usingTtlTimestamp            = 140
	CqlParserRULE_timestamp                    = 141
	CqlParserRULE_ttl                          = 142
	CqlParserRULE_usingTimestampSpec           = 143
	CqlParserRULE_ifNotExist                   = 144
	CqlParserRULE_ifExist                      = 145
	CqlParserRULE_insertValuesSpec             = 146
	CqlParserRULE_jsonDefault                  = 147
	CqlParserRULE_insertColumnSpec             = 148
	CqlParserRULE_columnList                   = 149
	CqlParserRULE_expressionList               = 150
	CqlParserRULE_expression                   = 151
	CqlParserRULE_select_                      = 152
	CqlParserRULE_allowFilteringSpec           = 153
	CqlParserRULE_groupBySpec                  = 154
	CqlParserRULE_bypassCacheSpec              = 155
	CqlParserRULE_perPartitionLimitSpec        = 156
	CqlParserRULE_usingTimeoutSpec             = 157
	CqlParserRULE_pruneMaterializedView        = 158
	CqlParserRULE_describeStatement            = 159
	CqlParserRULE_describeTarget               = 160
	CqlParserRULE_describeInternals            = 161
	CqlParserRULE_serviceLevelName             = 162
	CqlParserRULE_serviceLevel                 = 163
	CqlParserRULE_serviceLevels                = 164
	CqlParserRULE_createServiceLevel           = 165
	CqlParserRULE_alterServiceLevel            = 166
	CqlParserRULE_dropServiceLevel             = 167
	CqlParserRULE_attachServiceLevel           = 168
	CqlParserRULE_detachServiceLevel           = 169
	CqlParserRULE_listServiceLevel             = 170
	CqlParserRULE_propertyList                 = 171
	CqlParserRULE_property                     = 172
	CqlParserRULE_propertyName                 = 173
	CqlParserRULE_propertyValue                = 174
	CqlParserRULE_pruneUsingSpec               = 175
	CqlParserRULE_limitSpec                    = 176
	CqlParserRULE_fromSpec                     = 177
	CqlParserRULE_fromSpecElement              = 178
	CqlParserRULE_orderSpec                    = 179
	CqlParserRULE_orderSpecElement             = 180
	CqlParserRULE_vectorLiteral                = 181
	CqlParserRULE_whereSpec                    = 182
	CqlParserRULE_distinctSpec                 = 183
	CqlParserRULE_selectElements               = 184
	CqlParserRULE_selectElement                = 185
	CqlParserRULE_relationElements             = 186
	CqlParserRULE_relationElement              = 187
	CqlParserRULE_relalationContains           = 188
	CqlParserRULE_relalationContainsKey        = 189
	CqlParserRULE_scyllaClusteringBound        = 190
	CqlParserRULE_functionCall                 = 191
	CqlParserRULE_castCall                     = 192
	CqlParserRULE_qualifiedFunctionCall        = 193
	CqlParserRULE_functionArgs                 = 194
	CqlParserRULE_constant                     = 195
	CqlParserRULE_namedMarker                  = 196
	CqlParserRULE_durationLiteral              = 197
	CqlParserRULE_decimalLiteral               = 198
	CqlParserRULE_floatLiteral                 = 199
	CqlParserRULE_stringLiteral                = 200
	CqlParserRULE_booleanLiteral               = 201
	CqlParserRULE_hexadecimalLiteral           = 202
	CqlParserRULE_keyspace                     = 203
	CqlParserRULE_table                        = 204
	CqlParserRULE_column                       = 205
	CqlParserRULE_reservedKeywordAsColumn      = 206
	CqlParserRULE_columnRef                    = 207
	CqlParserRULE_reservedKeywordAsTable       = 208
	CqlParserRULE_reservedTypeAsTable          = 209
	CqlParserRULE_dataType                     = 210
	CqlParserRULE_dataTypeName                 = 211
	CqlParserRULE_dataTypeDefinition           = 212
	CqlParserRULE_dataTypeArg                  = 213
	CqlParserRULE_orderDirection               = 214
	CqlParserRULE_role                         = 215
	CqlParserRULE_trigger                      = 216
	CqlParserRULE_triggerClass                 = 217
	CqlParserRULE_materializedView             = 218
	CqlParserRULE_type_                        = 219
	CqlParserRULE_aggregate                    = 220
	CqlParserRULE_function_                    = 221
	CqlParserRULE_language                     = 222
	CqlParserRULE_user                         = 223
	CqlParserRULE_password                     = 224
	CqlParserRULE_hashKey                      = 225
	CqlParserRULE_param                        = 226
	CqlParserRULE_paramName                    = 227
	CqlParserRULE_kwAdd                        = 228
	CqlParserRULE_kwAggregate                  = 229
	CqlParserRULE_kwAll                        = 230
	CqlParserRULE_kwAllPermissions             = 231
	CqlParserRULE_kwAllow                      = 232
	CqlParserRULE_kwAlter                      = 233
	CqlParserRULE_kwAnd                        = 234
	CqlParserRULE_kwApply                      = 235
	CqlParserRULE_kwAs                         = 236
	CqlParserRULE_kwAsc                        = 237
	CqlParserRULE_kwAuthorize                  = 238
	CqlParserRULE_kwBatch                      = 239
	CqlParserRULE_kwBegin                      = 240
	CqlParserRULE_kwBy                         = 241
	CqlParserRULE_kwCalled                     = 242
	CqlParserRULE_kwClustering                 = 243
	CqlParserRULE_kwCompact                    = 244
	CqlParserRULE_kwContains                   = 245
	CqlParserRULE_kwCreate                     = 246
	CqlParserRULE_kwDelete                     = 247
	CqlParserRULE_kwDesc                       = 248
	CqlParserRULE_kwDescibe                    = 249
	CqlParserRULE_kwDistinct                   = 250
	CqlParserRULE_kwDrop                       = 251
	CqlParserRULE_kwDurableWrites              = 252
	CqlParserRULE_kwEntries                    = 253
	CqlParserRULE_kwExecute                    = 254
	CqlParserRULE_kwExists                     = 255
	CqlParserRULE_kwFiltering                  = 256
	CqlParserRULE_kwFinalfunc                  = 257
	CqlParserRULE_kwFrom                       = 258
	CqlParserRULE_kwFull                       = 259
	CqlParserRULE_kwFunction                   = 260
	CqlParserRULE_kwFunctions                  = 261
	CqlParserRULE_kwGrant                      = 262
	CqlParserRULE_kwIf                         = 263
	CqlParserRULE_kwIn                         = 264
	CqlParserRULE_kwIndex                      = 265
	CqlParserRULE_kwInitcond                   = 266
	CqlParserRULE_kwInput                      = 267
	CqlParserRULE_kwInsert                     = 268
	CqlParserRULE_kwInto                       = 269
	CqlParserRULE_kwIs                         = 270
	CqlParserRULE_kwJson                       = 271
	CqlParserRULE_kwKey                        = 272
	CqlParserRULE_kwKeys                       = 273
	CqlParserRULE_kwKeyspace                   = 274
	CqlParserRULE_kwKeyspaces                  = 275
	CqlParserRULE_kwLanguage                   = 276
	CqlParserRULE_kwLimit                      = 277
	CqlParserRULE_kwList                       = 278
	CqlParserRULE_kwLogged                     = 279
	CqlParserRULE_kwLogin                      = 280
	CqlParserRULE_kwMaterialized               = 281
	CqlParserRULE_kwModify                     = 282
	CqlParserRULE_kwNosuperuser                = 283
	CqlParserRULE_kwNorecursive                = 284
	CqlParserRULE_kwNot                        = 285
	CqlParserRULE_kwNull                       = 286
	CqlParserRULE_kwOf                         = 287
	CqlParserRULE_kwOn                         = 288
	CqlParserRULE_kwOptions                    = 289
	CqlParserRULE_kwOr                         = 290
	CqlParserRULE_kwOrder                      = 291
	CqlParserRULE_kwPassword                   = 292
	CqlParserRULE_kwPrimary                    = 293
	CqlParserRULE_kwRename                     = 294
	CqlParserRULE_kwReplace                    = 295
	CqlParserRULE_kwReplication                = 296
	CqlParserRULE_kwReturns                    = 297
	CqlParserRULE_kwRole                       = 298
	CqlParserRULE_kwRoles                      = 299
	CqlParserRULE_kwSelect                     = 300
	CqlParserRULE_kwSet                        = 301
	CqlParserRULE_kwSfunc                      = 302
	CqlParserRULE_kwStorage                    = 303
	CqlParserRULE_kwStype                      = 304
	CqlParserRULE_kwSuperuser                  = 305
	CqlParserRULE_kwTable                      = 306
	CqlParserRULE_kwTimestamp                  = 307
	CqlParserRULE_kwTo                         = 308
	CqlParserRULE_kwTrigger                    = 309
	CqlParserRULE_kwTruncate                   = 310
	CqlParserRULE_kwTtl                        = 311
	CqlParserRULE_kwType                       = 312
	CqlParserRULE_kwUnlogged                   = 313
	CqlParserRULE_kwUpdate                     = 314
	CqlParserRULE_kwUse                        = 315
	CqlParserRULE_kwUser                       = 316
	CqlParserRULE_kwUsing                      = 317
	CqlParserRULE_kwValues                     = 318
	CqlParserRULE_kwView                       = 319
	CqlParserRULE_kwWhere                      = 320
	CqlParserRULE_kwWith                       = 321
	CqlParserRULE_kwRevoke                     = 322
	CqlParserRULE_syntaxBracketLr              = 323
	CqlParserRULE_syntaxBracketRr              = 324
	CqlParserRULE_syntaxBracketLc              = 325
	CqlParserRULE_syntaxBracketRc              = 326
	CqlParserRULE_syntaxBracketLa              = 327
	CqlParserRULE_syntaxBracketRa              = 328
	CqlParserRULE_syntaxBracketLs              = 329
	CqlParserRULE_syntaxBracketRs              = 330
	CqlParserRULE_syntaxComma                  = 331
	CqlParserRULE_syntaxColon                  = 332
	CqlParserRULE_kwBypass                     = 333
	CqlParserRULE_kwCache                      = 334
	CqlParserRULE_kwTimeout                    = 335
	CqlParserRULE_kwPrune                      = 336
	CqlParserRULE_kwPer                        = 337
	CqlParserRULE_kwPartition                  = 338
	CqlParserRULE_kwGroup                      = 339
	CqlParserRULE_kwStatic                     = 340
	CqlParserRULE_kwCast                       = 341
	CqlParserRULE_kwLike                       = 342
	CqlParserRULE_kwWritetime                  = 343
	CqlParserRULE_kwToken                      = 344
	CqlParserRULE_kwTablets                    = 345
	CqlParserRULE_kwDefault                    = 346
	CqlParserRULE_kwUnset                      = 347
	CqlParserRULE_kwCounter                    = 348
	CqlParserRULE_kwDescribe                   = 349
	CqlParserRULE_kwCluster                    = 350
	CqlParserRULE_kwOnly                       = 351
	CqlParserRULE_kwInternals                  = 352
	CqlParserRULE_kwPasswords                  = 353
	CqlParserRULE_kwSchema                     = 354
	CqlParserRULE_kwTables                     = 355
	CqlParserRULE_kwTypes                      = 356
	CqlParserRULE_kwAggregates                 = 357
	CqlParserRULE_kwColumnfamily               = 358
	CqlParserRULE_kwService                    = 359
	CqlParserRULE_kwLevel                      = 360
	CqlParserRULE_kwLevels                     = 361
	CqlParserRULE_kwAttach                     = 362
	CqlParserRULE_kwDetach                     = 363
	CqlParserRULE_kwAttached                   = 364
	CqlParserRULE_kwEffective                  = 365
	CqlParserRULE_kwCustom                     = 366
	CqlParserRULE_kwAnn                        = 367
	CqlParserRULE_kwReducefunc                 = 368
	CqlParserRULE_kwNologin                    = 369
	CqlParserRULE_kwUsers                      = 370
	CqlParserRULE_kwHashed                     = 371
	CqlParserRULE_kwEmpty                      = 372
	CqlParserRULE_kwConcurrency                = 373
	CqlParserRULE_kwVectorSearchIndexing       = 374
)

// IRootContext is an interface to support dynamic dispatch.
type IRootContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EOF() antlr.TerminalNode
	Cqls() ICqlsContext
	MINUSMINUS() antlr.TerminalNode

	// IsRootContext differentiates from other interfaces.
	IsRootContext()
}

type RootContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRootContext() *RootContext {
	var p = new(RootContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_root
	return p
}

func InitEmptyRootContext(p *RootContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_root
}

func (*RootContext) IsRootContext() {}

func NewRootContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RootContext {
	var p = new(RootContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_root

	return p
}

func (s *RootContext) GetParser() antlr.Parser { return s.parser }

func (s *RootContext) EOF() antlr.TerminalNode {
	return s.GetToken(CqlParserEOF, 0)
}

func (s *RootContext) Cqls() ICqlsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICqlsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICqlsContext)
}

func (s *RootContext) MINUSMINUS() antlr.TerminalNode {
	return s.GetToken(CqlParserMINUSMINUS, 0)
}

func (s *RootContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RootContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RootContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterRoot(s)
	}
}

func (s *RootContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitRoot(s)
	}
}

func (p *CqlParser) Root() (localctx IRootContext) {
	localctx = NewRootContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, CqlParserRULE_root)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(751)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-9221735892417249024) != 0) || ((int64((_la-70)) & ^0x3f) == 0 && ((int64(1)<<(_la-70))&-4467561484502695935) != 0) || ((int64((_la-154)) & ^0x3f) == 0 && ((int64(1)<<(_la-154))&25769811969) != 0) {
		{
			p.SetState(750)
			p.Cqls()
		}

	}
	p.SetState(754)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CqlParserMINUSMINUS {
		{
			p.SetState(753)
			p.Match(CqlParserMINUSMINUS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(756)
		p.Match(CqlParserEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICqlsContext is an interface to support dynamic dispatch.
type ICqlsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllCql() []ICqlContext
	Cql(i int) ICqlContext
	AllEmpty_() []IEmpty_Context
	Empty_(i int) IEmpty_Context
	AllStatementSeparator() []IStatementSeparatorContext
	StatementSeparator(i int) IStatementSeparatorContext
	AllMINUSMINUS() []antlr.TerminalNode
	MINUSMINUS(i int) antlr.TerminalNode

	// IsCqlsContext differentiates from other interfaces.
	IsCqlsContext()
}

type CqlsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCqlsContext() *CqlsContext {
	var p = new(CqlsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_cqls
	return p
}

func InitEmptyCqlsContext(p *CqlsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_cqls
}

func (*CqlsContext) IsCqlsContext() {}

func NewCqlsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CqlsContext {
	var p = new(CqlsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_cqls

	return p
}

func (s *CqlsContext) GetParser() antlr.Parser { return s.parser }

func (s *CqlsContext) AllCql() []ICqlContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICqlContext); ok {
			len++
		}
	}

	tst := make([]ICqlContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICqlContext); ok {
			tst[i] = t.(ICqlContext)
			i++
		}
	}

	return tst
}

func (s *CqlsContext) Cql(i int) ICqlContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICqlContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICqlContext)
}

func (s *CqlsContext) AllEmpty_() []IEmpty_Context {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEmpty_Context); ok {
			len++
		}
	}

	tst := make([]IEmpty_Context, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEmpty_Context); ok {
			tst[i] = t.(IEmpty_Context)
			i++
		}
	}

	return tst
}

func (s *CqlsContext) Empty_(i int) IEmpty_Context {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEmpty_Context); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEmpty_Context)
}

func (s *CqlsContext) AllStatementSeparator() []IStatementSeparatorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementSeparatorContext); ok {
			len++
		}
	}

	tst := make([]IStatementSeparatorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementSeparatorContext); ok {
			tst[i] = t.(IStatementSeparatorContext)
			i++
		}
	}

	return tst
}

func (s *CqlsContext) StatementSeparator(i int) IStatementSeparatorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementSeparatorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementSeparatorContext)
}

func (s *CqlsContext) AllMINUSMINUS() []antlr.TerminalNode {
	return s.GetTokens(CqlParserMINUSMINUS)
}

func (s *CqlsContext) MINUSMINUS(i int) antlr.TerminalNode {
	return s.GetToken(CqlParserMINUSMINUS, i)
}

func (s *CqlsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CqlsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CqlsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterCqls(s)
	}
}

func (s *CqlsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitCqls(s)
	}
}

func (p *CqlParser) Cqls() (localctx ICqlsContext) {
	localctx = NewCqlsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, CqlParserRULE_cqls)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(767)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 4, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(765)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case CqlParserK_ALTER, CqlParserK_APPLY, CqlParserK_BEGIN, CqlParserK_CREATE, CqlParserK_DELETE, CqlParserK_DESC, CqlParserK_DESCRIBE, CqlParserK_DROP, CqlParserK_GRANT, CqlParserK_INSERT, CqlParserK_REVOKE, CqlParserK_SELECT, CqlParserK_TRUNCATE, CqlParserK_UPDATE, CqlParserK_USE, CqlParserK_LIST, CqlParserK_PRUNE, CqlParserK_ATTACH, CqlParserK_DETACH:
				{
					p.SetState(758)
					p.Cql()
				}
				p.SetState(760)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == CqlParserMINUSMINUS {
					{
						p.SetState(759)
						p.Match(CqlParserMINUSMINUS)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}
				{
					p.SetState(762)
					p.StatementSeparator()
				}

			case CqlParserSEMI:
				{
					p.SetState(764)
					p.Empty_()
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

		}
		p.SetState(769)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 4, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(778)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case CqlParserK_ALTER, CqlParserK_APPLY, CqlParserK_BEGIN, CqlParserK_CREATE, CqlParserK_DELETE, CqlParserK_DESC, CqlParserK_DESCRIBE, CqlParserK_DROP, CqlParserK_GRANT, CqlParserK_INSERT, CqlParserK_REVOKE, CqlParserK_SELECT, CqlParserK_TRUNCATE, CqlParserK_UPDATE, CqlParserK_USE, CqlParserK_LIST, CqlParserK_PRUNE, CqlParserK_ATTACH, CqlParserK_DETACH:
		{
			p.SetState(770)
			p.Cql()
		}
		p.SetState(775)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 6, p.GetParserRuleContext()) == 1 {
			p.SetState(772)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == CqlParserMINUSMINUS {
				{
					p.SetState(771)
					p.Match(CqlParserMINUSMINUS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(774)
				p.StatementSeparator()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case CqlParserSEMI:
		{
			p.SetState(777)
			p.Empty_()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStatementSeparatorContext is an interface to support dynamic dispatch.
type IStatementSeparatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SEMI() antlr.TerminalNode

	// IsStatementSeparatorContext differentiates from other interfaces.
	IsStatementSeparatorContext()
}

type StatementSeparatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementSeparatorContext() *StatementSeparatorContext {
	var p = new(StatementSeparatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_statementSeparator
	return p
}

func InitEmptyStatementSeparatorContext(p *StatementSeparatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_statementSeparator
}

func (*StatementSeparatorContext) IsStatementSeparatorContext() {}

func NewStatementSeparatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementSeparatorContext {
	var p = new(StatementSeparatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_statementSeparator

	return p
}

func (s *StatementSeparatorContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementSeparatorContext) SEMI() antlr.TerminalNode {
	return s.GetToken(CqlParserSEMI, 0)
}

func (s *StatementSeparatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementSeparatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementSeparatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterStatementSeparator(s)
	}
}

func (s *StatementSeparatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitStatementSeparator(s)
	}
}

func (p *CqlParser) StatementSeparator() (localctx IStatementSeparatorContext) {
	localctx = NewStatementSeparatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, CqlParserRULE_statementSeparator)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(780)
		p.Match(CqlParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEmpty_Context is an interface to support dynamic dispatch.
type IEmpty_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	StatementSeparator() IStatementSeparatorContext

	// IsEmpty_Context differentiates from other interfaces.
	IsEmpty_Context()
}

type Empty_Context struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEmpty_Context() *Empty_Context {
	var p = new(Empty_Context)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_empty_
	return p
}

func InitEmptyEmpty_Context(p *Empty_Context) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_empty_
}

func (*Empty_Context) IsEmpty_Context() {}

func NewEmpty_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Empty_Context {
	var p = new(Empty_Context)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_empty_

	return p
}

func (s *Empty_Context) GetParser() antlr.Parser { return s.parser }

func (s *Empty_Context) StatementSeparator() IStatementSeparatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementSeparatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementSeparatorContext)
}

func (s *Empty_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Empty_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Empty_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterEmpty_(s)
	}
}

func (s *Empty_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitEmpty_(s)
	}
}

func (p *CqlParser) Empty_() (localctx IEmpty_Context) {
	localctx = NewEmpty_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, CqlParserRULE_empty_)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(782)
		p.StatementSeparator()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICqlContext is an interface to support dynamic dispatch.
type ICqlContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AlterKeyspace() IAlterKeyspaceContext
	AlterMaterializedView() IAlterMaterializedViewContext
	AlterRole() IAlterRoleContext
	AlterTable() IAlterTableContext
	AlterType() IAlterTypeContext
	AlterUser() IAlterUserContext
	ApplyBatch() IApplyBatchContext
	CreateAggregate() ICreateAggregateContext
	CreateFunction() ICreateFunctionContext
	CreateIndex() ICreateIndexContext
	CreateKeyspace() ICreateKeyspaceContext
	CreateMaterializedView() ICreateMaterializedViewContext
	CreateRole() ICreateRoleContext
	CreateTable() ICreateTableContext
	CreateTrigger() ICreateTriggerContext
	CreateType() ICreateTypeContext
	CreateUser() ICreateUserContext
	Delete_() IDelete_Context
	DropAggregate() IDropAggregateContext
	DropFunction() IDropFunctionContext
	DropIndex() IDropIndexContext
	DropKeyspace() IDropKeyspaceContext
	DropMaterializedView() IDropMaterializedViewContext
	DropRole() IDropRoleContext
	DropTable() IDropTableContext
	DropTrigger() IDropTriggerContext
	DropType() IDropTypeContext
	DropUser() IDropUserContext
	Grant() IGrantContext
	Insert() IInsertContext
	ListPermissions() IListPermissionsContext
	ListRoles() IListRolesContext
	Revoke() IRevokeContext
	Select_() ISelect_Context
	Truncate() ITruncateContext
	Update() IUpdateContext
	Use_() IUse_Context
	PruneMaterializedView() IPruneMaterializedViewContext
	Batch() IBatchContext
	DescribeStatement() IDescribeStatementContext
	CreateServiceLevel() ICreateServiceLevelContext
	AlterServiceLevel() IAlterServiceLevelContext
	DropServiceLevel() IDropServiceLevelContext
	AttachServiceLevel() IAttachServiceLevelContext
	DetachServiceLevel() IDetachServiceLevelContext
	ListServiceLevel() IListServiceLevelContext
	ListUsers() IListUsersContext

	// IsCqlContext differentiates from other interfaces.
	IsCqlContext()
}

type CqlContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCqlContext() *CqlContext {
	var p = new(CqlContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_cql
	return p
}

func InitEmptyCqlContext(p *CqlContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_cql
}

func (*CqlContext) IsCqlContext() {}

func NewCqlContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CqlContext {
	var p = new(CqlContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_cql

	return p
}

func (s *CqlContext) GetParser() antlr.Parser { return s.parser }

func (s *CqlContext) AlterKeyspace() IAlterKeyspaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterKeyspaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterKeyspaceContext)
}

func (s *CqlContext) AlterMaterializedView() IAlterMaterializedViewContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterMaterializedViewContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterMaterializedViewContext)
}

func (s *CqlContext) AlterRole() IAlterRoleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterRoleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterRoleContext)
}

func (s *CqlContext) AlterTable() IAlterTableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterTableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterTableContext)
}

func (s *CqlContext) AlterType() IAlterTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterTypeContext)
}

func (s *CqlContext) AlterUser() IAlterUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterUserContext)
}

func (s *CqlContext) ApplyBatch() IApplyBatchContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IApplyBatchContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IApplyBatchContext)
}

func (s *CqlContext) CreateAggregate() ICreateAggregateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateAggregateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateAggregateContext)
}

func (s *CqlContext) CreateFunction() ICreateFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateFunctionContext)
}

func (s *CqlContext) CreateIndex() ICreateIndexContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateIndexContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateIndexContext)
}

func (s *CqlContext) CreateKeyspace() ICreateKeyspaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateKeyspaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateKeyspaceContext)
}

func (s *CqlContext) CreateMaterializedView() ICreateMaterializedViewContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateMaterializedViewContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateMaterializedViewContext)
}

func (s *CqlContext) CreateRole() ICreateRoleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateRoleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateRoleContext)
}

func (s *CqlContext) CreateTable() ICreateTableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateTableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateTableContext)
}

func (s *CqlContext) CreateTrigger() ICreateTriggerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateTriggerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateTriggerContext)
}

func (s *CqlContext) CreateType() ICreateTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateTypeContext)
}

func (s *CqlContext) CreateUser() ICreateUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateUserContext)
}

func (s *CqlContext) Delete_() IDelete_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDelete_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDelete_Context)
}

func (s *CqlContext) DropAggregate() IDropAggregateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropAggregateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropAggregateContext)
}

func (s *CqlContext) DropFunction() IDropFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropFunctionContext)
}

func (s *CqlContext) DropIndex() IDropIndexContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropIndexContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropIndexContext)
}

func (s *CqlContext) DropKeyspace() IDropKeyspaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropKeyspaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropKeyspaceContext)
}

func (s *CqlContext) DropMaterializedView() IDropMaterializedViewContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropMaterializedViewContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropMaterializedViewContext)
}

func (s *CqlContext) DropRole() IDropRoleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropRoleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropRoleContext)
}

func (s *CqlContext) DropTable() IDropTableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropTableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropTableContext)
}

func (s *CqlContext) DropTrigger() IDropTriggerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropTriggerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropTriggerContext)
}

func (s *CqlContext) DropType() IDropTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropTypeContext)
}

func (s *CqlContext) DropUser() IDropUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropUserContext)
}

func (s *CqlContext) Grant() IGrantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrantContext)
}

func (s *CqlContext) Insert() IInsertContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsertContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsertContext)
}

func (s *CqlContext) ListPermissions() IListPermissionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IListPermissionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IListPermissionsContext)
}

func (s *CqlContext) ListRoles() IListRolesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IListRolesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IListRolesContext)
}

func (s *CqlContext) Revoke() IRevokeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRevokeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRevokeContext)
}

func (s *CqlContext) Select_() ISelect_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_Context)
}

func (s *CqlContext) Truncate() ITruncateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITruncateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITruncateContext)
}

func (s *CqlContext) Update() IUpdateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdateContext)
}

func (s *CqlContext) Use_() IUse_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUse_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUse_Context)
}

func (s *CqlContext) PruneMaterializedView() IPruneMaterializedViewContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPruneMaterializedViewContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPruneMaterializedViewContext)
}

func (s *CqlContext) Batch() IBatchContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBatchContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBatchContext)
}

func (s *CqlContext) DescribeStatement() IDescribeStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDescribeStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDescribeStatementContext)
}

func (s *CqlContext) CreateServiceLevel() ICreateServiceLevelContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateServiceLevelContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateServiceLevelContext)
}

func (s *CqlContext) AlterServiceLevel() IAlterServiceLevelContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterServiceLevelContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterServiceLevelContext)
}

func (s *CqlContext) DropServiceLevel() IDropServiceLevelContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropServiceLevelContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropServiceLevelContext)
}

func (s *CqlContext) AttachServiceLevel() IAttachServiceLevelContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttachServiceLevelContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttachServiceLevelContext)
}

func (s *CqlContext) DetachServiceLevel() IDetachServiceLevelContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDetachServiceLevelContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDetachServiceLevelContext)
}

func (s *CqlContext) ListServiceLevel() IListServiceLevelContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IListServiceLevelContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IListServiceLevelContext)
}

func (s *CqlContext) ListUsers() IListUsersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IListUsersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IListUsersContext)
}

func (s *CqlContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CqlContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CqlContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterCql(s)
	}
}

func (s *CqlContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitCql(s)
	}
}

func (p *CqlParser) Cql() (localctx ICqlContext) {
	localctx = NewCqlContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, CqlParserRULE_cql)
	p.SetState(831)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 8, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(784)
			p.AlterKeyspace()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(785)
			p.AlterMaterializedView()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(786)
			p.AlterRole()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(787)
			p.AlterTable()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(788)
			p.AlterType()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(789)
			p.AlterUser()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(790)
			p.ApplyBatch()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(791)
			p.CreateAggregate()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(792)
			p.CreateFunction()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(793)
			p.CreateIndex()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(794)
			p.CreateKeyspace()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(795)
			p.CreateMaterializedView()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(796)
			p.CreateRole()
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(797)
			p.CreateTable()
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(798)
			p.CreateTrigger()
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(799)
			p.CreateType()
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(800)
			p.CreateUser()
		}

	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(801)
			p.Delete_()
		}

	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(802)
			p.DropAggregate()
		}

	case 20:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(803)
			p.DropFunction()
		}

	case 21:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(804)
			p.DropIndex()
		}

	case 22:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(805)
			p.DropKeyspace()
		}

	case 23:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(806)
			p.DropMaterializedView()
		}

	case 24:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(807)
			p.DropRole()
		}

	case 25:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(808)
			p.DropTable()
		}

	case 26:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(809)
			p.DropTrigger()
		}

	case 27:
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(810)
			p.DropType()
		}

	case 28:
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(811)
			p.DropUser()
		}

	case 29:
		p.EnterOuterAlt(localctx, 29)
		{
			p.SetState(812)
			p.Grant()
		}

	case 30:
		p.EnterOuterAlt(localctx, 30)
		{
			p.SetState(813)
			p.Insert()
		}

	case 31:
		p.EnterOuterAlt(localctx, 31)
		{
			p.SetState(814)
			p.ListPermissions()
		}

	case 32:
		p.EnterOuterAlt(localctx, 32)
		{
			p.SetState(815)
			p.ListRoles()
		}

	case 33:
		p.EnterOuterAlt(localctx, 33)
		{
			p.SetState(816)
			p.Revoke()
		}

	case 34:
		p.EnterOuterAlt(localctx, 34)
		{
			p.SetState(817)
			p.Select_()
		}

	case 35:
		p.EnterOuterAlt(localctx, 35)
		{
			p.SetState(818)
			p.Truncate()
		}

	case 36:
		p.EnterOuterAlt(localctx, 36)
		{
			p.SetState(819)
			p.Update()
		}

	case 37:
		p.EnterOuterAlt(localctx, 37)
		{
			p.SetState(820)
			p.Use_()
		}

	case 38:
		p.EnterOuterAlt(localctx, 38)
		{
			p.SetState(821)
			p.PruneMaterializedView()
		}

	case 39:
		p.EnterOuterAlt(localctx, 39)
		{
			p.SetState(822)
			p.Batch()
		}

	case 40:
		p.EnterOuterAlt(localctx, 40)
		{
			p.SetState(823)
			p.DescribeStatement()
		}

	case 41:
		p.EnterOuterAlt(localctx, 41)
		{
			p.SetState(824)
			p.CreateServiceLevel()
		}

	case 42:
		p.EnterOuterAlt(localctx, 42)
		{
			p.SetState(825)
			p.AlterServiceLevel()
		}

	case 43:
		p.EnterOuterAlt(localctx, 43)
		{
			p.SetState(826)
			p.DropServiceLevel()
		}

	case 44:
		p.EnterOuterAlt(localctx, 44)
		{
			p.SetState(827)
			p.AttachServiceLevel()
		}

	case 45:
		p.EnterOuterAlt(localctx, 45)
		{
			p.SetState(828)
			p.DetachServiceLevel()
		}

	case 46:
		p.EnterOuterAlt(localctx, 46)
		{
			p.SetState(829)
			p.ListServiceLevel()
		}

	case 47:
		p.EnterOuterAlt(localctx, 47)
		{
			p.SetState(830)
			p.ListUsers()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRevokeContext is an interface to support dynamic dispatch.
type IRevokeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwRevoke() IKwRevokeContext
	Priviledge() IPriviledgeContext
	KwOn() IKwOnContext
	Resource() IResourceContext
	KwFrom() IKwFromContext
	Role() IRoleContext

	// IsRevokeContext differentiates from other interfaces.
	IsRevokeContext()
}

type RevokeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRevokeContext() *RevokeContext {
	var p = new(RevokeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_revoke
	return p
}

func InitEmptyRevokeContext(p *RevokeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_revoke
}

func (*RevokeContext) IsRevokeContext() {}

func NewRevokeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RevokeContext {
	var p = new(RevokeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_revoke

	return p
}

func (s *RevokeContext) GetParser() antlr.Parser { return s.parser }

func (s *RevokeContext) KwRevoke() IKwRevokeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwRevokeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwRevokeContext)
}

func (s *RevokeContext) Priviledge() IPriviledgeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPriviledgeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPriviledgeContext)
}

func (s *RevokeContext) KwOn() IKwOnContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwOnContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwOnContext)
}

func (s *RevokeContext) Resource() IResourceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResourceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResourceContext)
}

func (s *RevokeContext) KwFrom() IKwFromContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwFromContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwFromContext)
}

func (s *RevokeContext) Role() IRoleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleContext)
}

func (s *RevokeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RevokeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RevokeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterRevoke(s)
	}
}

func (s *RevokeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitRevoke(s)
	}
}

func (p *CqlParser) Revoke() (localctx IRevokeContext) {
	localctx = NewRevokeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, CqlParserRULE_revoke)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(833)
		p.KwRevoke()
	}
	{
		p.SetState(834)
		p.Priviledge()
	}
	{
		p.SetState(835)
		p.KwOn()
	}
	{
		p.SetState(836)
		p.Resource()
	}
	{
		p.SetState(837)
		p.KwFrom()
	}
	{
		p.SetState(838)
		p.Role()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IListRolesContext is an interface to support dynamic dispatch.
type IListRolesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwList() IKwListContext
	KwRoles() IKwRolesContext
	KwAll() IKwAllContext
	KwOf() IKwOfContext
	Role() IRoleContext
	KwNorecursive() IKwNorecursiveContext

	// IsListRolesContext differentiates from other interfaces.
	IsListRolesContext()
}

type ListRolesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyListRolesContext() *ListRolesContext {
	var p = new(ListRolesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_listRoles
	return p
}

func InitEmptyListRolesContext(p *ListRolesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_listRoles
}

func (*ListRolesContext) IsListRolesContext() {}

func NewListRolesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ListRolesContext {
	var p = new(ListRolesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_listRoles

	return p
}

func (s *ListRolesContext) GetParser() antlr.Parser { return s.parser }

func (s *ListRolesContext) KwList() IKwListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwListContext)
}

func (s *ListRolesContext) KwRoles() IKwRolesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwRolesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwRolesContext)
}

func (s *ListRolesContext) KwAll() IKwAllContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwAllContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwAllContext)
}

func (s *ListRolesContext) KwOf() IKwOfContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwOfContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwOfContext)
}

func (s *ListRolesContext) Role() IRoleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleContext)
}

func (s *ListRolesContext) KwNorecursive() IKwNorecursiveContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwNorecursiveContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwNorecursiveContext)
}

func (s *ListRolesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListRolesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ListRolesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterListRoles(s)
	}
}

func (s *ListRolesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitListRoles(s)
	}
}

func (p *CqlParser) ListRoles() (localctx IListRolesContext) {
	localctx = NewListRolesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, CqlParserRULE_listRoles)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(840)
		p.KwList()
	}
	p.SetState(842)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CqlParserK_ALL {
		{
			p.SetState(841)
			p.KwAll()
		}

	}
	{
		p.SetState(844)
		p.KwRoles()
	}
	p.SetState(848)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CqlParserK_OF {
		{
			p.SetState(845)
			p.KwOf()
		}
		{
			p.SetState(846)
			p.Role()
		}

	}
	p.SetState(851)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CqlParserK_NORECURSIVE {
		{
			p.SetState(850)
			p.KwNorecursive()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IListUsersContext is an interface to support dynamic dispatch.
type IListUsersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwList() IKwListContext
	KwUsers() IKwUsersContext

	// IsListUsersContext differentiates from other interfaces.
	IsListUsersContext()
}

type ListUsersContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyListUsersContext() *ListUsersContext {
	var p = new(ListUsersContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_listUsers
	return p
}

func InitEmptyListUsersContext(p *ListUsersContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_listUsers
}

func (*ListUsersContext) IsListUsersContext() {}

func NewListUsersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ListUsersContext {
	var p = new(ListUsersContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_listUsers

	return p
}

func (s *ListUsersContext) GetParser() antlr.Parser { return s.parser }

func (s *ListUsersContext) KwList() IKwListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwListContext)
}

func (s *ListUsersContext) KwUsers() IKwUsersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwUsersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwUsersContext)
}

func (s *ListUsersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListUsersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ListUsersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterListUsers(s)
	}
}

func (s *ListUsersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitListUsers(s)
	}
}

func (p *CqlParser) ListUsers() (localctx IListUsersContext) {
	localctx = NewListUsersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, CqlParserRULE_listUsers)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(853)
		p.KwList()
	}
	{
		p.SetState(854)
		p.KwUsers()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IListPermissionsContext is an interface to support dynamic dispatch.
type IListPermissionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwList() IKwListContext
	Priviledge() IPriviledgeContext
	KwOn() IKwOnContext
	Resource() IResourceContext
	KwOf() IKwOfContext
	Role() IRoleContext

	// IsListPermissionsContext differentiates from other interfaces.
	IsListPermissionsContext()
}

type ListPermissionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyListPermissionsContext() *ListPermissionsContext {
	var p = new(ListPermissionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_listPermissions
	return p
}

func InitEmptyListPermissionsContext(p *ListPermissionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_listPermissions
}

func (*ListPermissionsContext) IsListPermissionsContext() {}

func NewListPermissionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ListPermissionsContext {
	var p = new(ListPermissionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_listPermissions

	return p
}

func (s *ListPermissionsContext) GetParser() antlr.Parser { return s.parser }

func (s *ListPermissionsContext) KwList() IKwListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwListContext)
}

func (s *ListPermissionsContext) Priviledge() IPriviledgeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPriviledgeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPriviledgeContext)
}

func (s *ListPermissionsContext) KwOn() IKwOnContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwOnContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwOnContext)
}

func (s *ListPermissionsContext) Resource() IResourceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResourceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResourceContext)
}

func (s *ListPermissionsContext) KwOf() IKwOfContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwOfContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwOfContext)
}

func (s *ListPermissionsContext) Role() IRoleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleContext)
}

func (s *ListPermissionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListPermissionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ListPermissionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterListPermissions(s)
	}
}

func (s *ListPermissionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitListPermissions(s)
	}
}

func (p *CqlParser) ListPermissions() (localctx IListPermissionsContext) {
	localctx = NewListPermissionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, CqlParserRULE_listPermissions)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(856)
		p.KwList()
	}
	{
		p.SetState(857)
		p.Priviledge()
	}
	p.SetState(861)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CqlParserK_ON {
		{
			p.SetState(858)
			p.KwOn()
		}
		{
			p.SetState(859)
			p.Resource()
		}

	}
	p.SetState(866)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CqlParserK_OF {
		{
			p.SetState(863)
			p.KwOf()
		}
		{
			p.SetState(864)
			p.Role()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGrantContext is an interface to support dynamic dispatch.
type IGrantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwGrant() IKwGrantContext
	Priviledge() IPriviledgeContext
	KwOn() IKwOnContext
	Resource() IResourceContext
	KwTo() IKwToContext
	Role() IRoleContext

	// IsGrantContext differentiates from other interfaces.
	IsGrantContext()
}

type GrantContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGrantContext() *GrantContext {
	var p = new(GrantContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_grant
	return p
}

func InitEmptyGrantContext(p *GrantContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_grant
}

func (*GrantContext) IsGrantContext() {}

func NewGrantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GrantContext {
	var p = new(GrantContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_grant

	return p
}

func (s *GrantContext) GetParser() antlr.Parser { return s.parser }

func (s *GrantContext) KwGrant() IKwGrantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwGrantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwGrantContext)
}

func (s *GrantContext) Priviledge() IPriviledgeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPriviledgeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPriviledgeContext)
}

func (s *GrantContext) KwOn() IKwOnContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwOnContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwOnContext)
}

func (s *GrantContext) Resource() IResourceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResourceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResourceContext)
}

func (s *GrantContext) KwTo() IKwToContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwToContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwToContext)
}

func (s *GrantContext) Role() IRoleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleContext)
}

func (s *GrantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GrantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GrantContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterGrant(s)
	}
}

func (s *GrantContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitGrant(s)
	}
}

func (p *CqlParser) Grant() (localctx IGrantContext) {
	localctx = NewGrantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, CqlParserRULE_grant)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(868)
		p.KwGrant()
	}
	{
		p.SetState(869)
		p.Priviledge()
	}
	{
		p.SetState(870)
		p.KwOn()
	}
	{
		p.SetState(871)
		p.Resource()
	}
	{
		p.SetState(872)
		p.KwTo()
	}
	{
		p.SetState(873)
		p.Role()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPriviledgeContext is an interface to support dynamic dispatch.
type IPriviledgeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwAll() IKwAllContext
	KwAllPermissions() IKwAllPermissionsContext
	KwAlter() IKwAlterContext
	KwAuthorize() IKwAuthorizeContext
	KwDescibe() IKwDescibeContext
	KwExecute() IKwExecuteContext
	KwCreate() IKwCreateContext
	KwDrop() IKwDropContext
	KwModify() IKwModifyContext
	KwSelect() IKwSelectContext
	KwVectorSearchIndexing() IKwVectorSearchIndexingContext

	// IsPriviledgeContext differentiates from other interfaces.
	IsPriviledgeContext()
}

type PriviledgeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPriviledgeContext() *PriviledgeContext {
	var p = new(PriviledgeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_priviledge
	return p
}

func InitEmptyPriviledgeContext(p *PriviledgeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_priviledge
}

func (*PriviledgeContext) IsPriviledgeContext() {}

func NewPriviledgeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PriviledgeContext {
	var p = new(PriviledgeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_priviledge

	return p
}

func (s *PriviledgeContext) GetParser() antlr.Parser { return s.parser }

func (s *PriviledgeContext) KwAll() IKwAllContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwAllContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwAllContext)
}

func (s *PriviledgeContext) KwAllPermissions() IKwAllPermissionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwAllPermissionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwAllPermissionsContext)
}

func (s *PriviledgeContext) KwAlter() IKwAlterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwAlterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwAlterContext)
}

func (s *PriviledgeContext) KwAuthorize() IKwAuthorizeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwAuthorizeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwAuthorizeContext)
}

func (s *PriviledgeContext) KwDescibe() IKwDescibeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwDescibeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwDescibeContext)
}

func (s *PriviledgeContext) KwExecute() IKwExecuteContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwExecuteContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwExecuteContext)
}

func (s *PriviledgeContext) KwCreate() IKwCreateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwCreateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwCreateContext)
}

func (s *PriviledgeContext) KwDrop() IKwDropContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwDropContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwDropContext)
}

func (s *PriviledgeContext) KwModify() IKwModifyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwModifyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwModifyContext)
}

func (s *PriviledgeContext) KwSelect() IKwSelectContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwSelectContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwSelectContext)
}

func (s *PriviledgeContext) KwVectorSearchIndexing() IKwVectorSearchIndexingContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwVectorSearchIndexingContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwVectorSearchIndexingContext)
}

func (s *PriviledgeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PriviledgeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PriviledgeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterPriviledge(s)
	}
}

func (s *PriviledgeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitPriviledge(s)
	}
}

func (p *CqlParser) Priviledge() (localctx IPriviledgeContext) {
	localctx = NewPriviledgeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, CqlParserRULE_priviledge)
	p.SetState(888)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case CqlParserK_ALL:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(877)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 14, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(875)
				p.KwAll()
			}

		case 2:
			{
				p.SetState(876)
				p.KwAllPermissions()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	case CqlParserK_ALTER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(879)
			p.KwAlter()
		}

	case CqlParserK_AUTHORIZE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(880)
			p.KwAuthorize()
		}

	case CqlParserK_DESCRIBE:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(881)
			p.KwDescibe()
		}

	case CqlParserK_EXECUTE:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(882)
			p.KwExecute()
		}

	case CqlParserK_CREATE:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(883)
			p.KwCreate()
		}

	case CqlParserK_DROP:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(884)
			p.KwDrop()
		}

	case CqlParserK_MODIFY:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(885)
			p.KwModify()
		}

	case CqlParserK_SELECT:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(886)
			p.KwSelect()
		}

	case CqlParserK_VECTOR_SEARCH_INDEXING:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(887)
			p.KwVectorSearchIndexing()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IResourceContext is an interface to support dynamic dispatch.
type IResourceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwAll() IKwAllContext
	KwFunctions() IKwFunctionsContext
	KwIn() IKwInContext
	KwKeyspace() IKwKeyspaceContext
	Keyspace() IKeyspaceContext
	KwFunction() IKwFunctionContext
	Function_() IFunction_Context
	DOT() antlr.TerminalNode
	KwKeyspaces() IKwKeyspacesContext
	Table() ITableContext
	KwTable() IKwTableContext
	KwRoles() IKwRolesContext
	KwRole() IKwRoleContext
	Role() IRoleContext

	// IsResourceContext differentiates from other interfaces.
	IsResourceContext()
}

type ResourceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyResourceContext() *ResourceContext {
	var p = new(ResourceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_resource
	return p
}

func InitEmptyResourceContext(p *ResourceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_resource
}

func (*ResourceContext) IsResourceContext() {}

func NewResourceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ResourceContext {
	var p = new(ResourceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_resource

	return p
}

func (s *ResourceContext) GetParser() antlr.Parser { return s.parser }

func (s *ResourceContext) KwAll() IKwAllContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwAllContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwAllContext)
}

func (s *ResourceContext) KwFunctions() IKwFunctionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwFunctionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwFunctionsContext)
}

func (s *ResourceContext) KwIn() IKwInContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwInContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwInContext)
}

func (s *ResourceContext) KwKeyspace() IKwKeyspaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwKeyspaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwKeyspaceContext)
}

func (s *ResourceContext) Keyspace() IKeyspaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyspaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyspaceContext)
}

func (s *ResourceContext) KwFunction() IKwFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwFunctionContext)
}

func (s *ResourceContext) Function_() IFunction_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunction_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunction_Context)
}

func (s *ResourceContext) DOT() antlr.TerminalNode {
	return s.GetToken(CqlParserDOT, 0)
}

func (s *ResourceContext) KwKeyspaces() IKwKeyspacesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwKeyspacesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwKeyspacesContext)
}

func (s *ResourceContext) Table() ITableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableContext)
}

func (s *ResourceContext) KwTable() IKwTableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwTableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwTableContext)
}

func (s *ResourceContext) KwRoles() IKwRolesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwRolesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwRolesContext)
}

func (s *ResourceContext) KwRole() IKwRoleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwRoleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwRoleContext)
}

func (s *ResourceContext) Role() IRoleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleContext)
}

func (s *ResourceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResourceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ResourceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterResource(s)
	}
}

func (s *ResourceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitResource(s)
	}
}

func (p *CqlParser) Resource() (localctx IResourceContext) {
	localctx = NewResourceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, CqlParserRULE_resource)
	var _la int

	p.SetState(928)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 19, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(890)
			p.KwAll()
		}
		{
			p.SetState(891)
			p.KwFunctions()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(893)
			p.KwAll()
		}
		{
			p.SetState(894)
			p.KwFunctions()
		}
		{
			p.SetState(895)
			p.KwIn()
		}
		{
			p.SetState(896)
			p.KwKeyspace()
		}
		{
			p.SetState(897)
			p.Keyspace()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(899)
			p.KwFunction()
		}
		p.SetState(903)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 16, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(900)
				p.Keyspace()
			}
			{
				p.SetState(901)
				p.Match(CqlParserDOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(905)
			p.Function_()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(907)
			p.KwAll()
		}
		{
			p.SetState(908)
			p.KwKeyspaces()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(910)
			p.KwKeyspace()
		}
		{
			p.SetState(911)
			p.Keyspace()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		p.SetState(914)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == CqlParserK_TABLE {
			{
				p.SetState(913)
				p.KwTable()
			}

		}
		p.SetState(919)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 18, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(916)
				p.Keyspace()
			}
			{
				p.SetState(917)
				p.Match(CqlParserDOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(921)
			p.Table()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(922)
			p.KwAll()
		}
		{
			p.SetState(923)
			p.KwRoles()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(925)
			p.KwRole()
		}
		{
			p.SetState(926)
			p.Role()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateUserContext is an interface to support dynamic dispatch.
type ICreateUserContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwCreate() IKwCreateContext
	KwUser() IKwUserContext
	User() IUserContext
	KwWith() IKwWithContext
	KwPassword() IKwPasswordContext
	StringLiteral() IStringLiteralContext
	IfNotExist() IIfNotExistContext
	KwSuperuser() IKwSuperuserContext
	KwNosuperuser() IKwNosuperuserContext

	// IsCreateUserContext differentiates from other interfaces.
	IsCreateUserContext()
}

type CreateUserContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateUserContext() *CreateUserContext {
	var p = new(CreateUserContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_createUser
	return p
}

func InitEmptyCreateUserContext(p *CreateUserContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_createUser
}

func (*CreateUserContext) IsCreateUserContext() {}

func NewCreateUserContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateUserContext {
	var p = new(CreateUserContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_createUser

	return p
}

func (s *CreateUserContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateUserContext) KwCreate() IKwCreateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwCreateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwCreateContext)
}

func (s *CreateUserContext) KwUser() IKwUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwUserContext)
}

func (s *CreateUserContext) User() IUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserContext)
}

func (s *CreateUserContext) KwWith() IKwWithContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwWithContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwWithContext)
}

func (s *CreateUserContext) KwPassword() IKwPasswordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwPasswordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwPasswordContext)
}

func (s *CreateUserContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *CreateUserContext) IfNotExist() IIfNotExistContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistContext)
}

func (s *CreateUserContext) KwSuperuser() IKwSuperuserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwSuperuserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwSuperuserContext)
}

func (s *CreateUserContext) KwNosuperuser() IKwNosuperuserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwNosuperuserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwNosuperuserContext)
}

func (s *CreateUserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateUserContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateUserContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterCreateUser(s)
	}
}

func (s *CreateUserContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitCreateUser(s)
	}
}

func (p *CqlParser) CreateUser() (localctx ICreateUserContext) {
	localctx = NewCreateUserContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, CqlParserRULE_createUser)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(930)
		p.KwCreate()
	}
	{
		p.SetState(931)
		p.KwUser()
	}
	p.SetState(933)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CqlParserK_IF {
		{
			p.SetState(932)
			p.IfNotExist()
		}

	}
	{
		p.SetState(935)
		p.User()
	}
	{
		p.SetState(936)
		p.KwWith()
	}
	{
		p.SetState(937)
		p.KwPassword()
	}
	{
		p.SetState(938)
		p.StringLiteral()
	}
	p.SetState(941)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case CqlParserK_SUPERUSER:
		{
			p.SetState(939)
			p.KwSuperuser()
		}

	case CqlParserK_NOSUPERUSER:
		{
			p.SetState(940)
			p.KwNosuperuser()
		}

	case CqlParserEOF, CqlParserSEMI, CqlParserMINUSMINUS:

	default:
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateRoleContext is an interface to support dynamic dispatch.
type ICreateRoleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwCreate() IKwCreateContext
	KwRole() IKwRoleContext
	Role() IRoleContext
	IfNotExist() IIfNotExistContext
	RoleWith() IRoleWithContext

	// IsCreateRoleContext differentiates from other interfaces.
	IsCreateRoleContext()
}

type CreateRoleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateRoleContext() *CreateRoleContext {
	var p = new(CreateRoleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_createRole
	return p
}

func InitEmptyCreateRoleContext(p *CreateRoleContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_createRole
}

func (*CreateRoleContext) IsCreateRoleContext() {}

func NewCreateRoleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateRoleContext {
	var p = new(CreateRoleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_createRole

	return p
}

func (s *CreateRoleContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateRoleContext) KwCreate() IKwCreateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwCreateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwCreateContext)
}

func (s *CreateRoleContext) KwRole() IKwRoleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwRoleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwRoleContext)
}

func (s *CreateRoleContext) Role() IRoleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleContext)
}

func (s *CreateRoleContext) IfNotExist() IIfNotExistContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistContext)
}

func (s *CreateRoleContext) RoleWith() IRoleWithContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleWithContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleWithContext)
}

func (s *CreateRoleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateRoleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateRoleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterCreateRole(s)
	}
}

func (s *CreateRoleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitCreateRole(s)
	}
}

func (p *CqlParser) CreateRole() (localctx ICreateRoleContext) {
	localctx = NewCreateRoleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, CqlParserRULE_createRole)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(943)
		p.KwCreate()
	}
	{
		p.SetState(944)
		p.KwRole()
	}
	p.SetState(946)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CqlParserK_IF {
		{
			p.SetState(945)
			p.IfNotExist()
		}

	}
	{
		p.SetState(948)
		p.Role()
	}
	p.SetState(950)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CqlParserK_WITH {
		{
			p.SetState(949)
			p.RoleWith()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateTypeContext is an interface to support dynamic dispatch.
type ICreateTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwCreate() IKwCreateContext
	KwType() IKwTypeContext
	Type_() IType_Context
	SyntaxBracketLr() ISyntaxBracketLrContext
	TypeMemberColumnList() ITypeMemberColumnListContext
	SyntaxBracketRr() ISyntaxBracketRrContext
	IfNotExist() IIfNotExistContext
	Keyspace() IKeyspaceContext
	DOT() antlr.TerminalNode

	// IsCreateTypeContext differentiates from other interfaces.
	IsCreateTypeContext()
}

type CreateTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateTypeContext() *CreateTypeContext {
	var p = new(CreateTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_createType
	return p
}

func InitEmptyCreateTypeContext(p *CreateTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_createType
}

func (*CreateTypeContext) IsCreateTypeContext() {}

func NewCreateTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateTypeContext {
	var p = new(CreateTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_createType

	return p
}

func (s *CreateTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateTypeContext) KwCreate() IKwCreateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwCreateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwCreateContext)
}

func (s *CreateTypeContext) KwType() IKwTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwTypeContext)
}

func (s *CreateTypeContext) Type_() IType_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *CreateTypeContext) SyntaxBracketLr() ISyntaxBracketLrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxBracketLrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxBracketLrContext)
}

func (s *CreateTypeContext) TypeMemberColumnList() ITypeMemberColumnListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeMemberColumnListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeMemberColumnListContext)
}

func (s *CreateTypeContext) SyntaxBracketRr() ISyntaxBracketRrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxBracketRrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxBracketRrContext)
}

func (s *CreateTypeContext) IfNotExist() IIfNotExistContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistContext)
}

func (s *CreateTypeContext) Keyspace() IKeyspaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyspaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyspaceContext)
}

func (s *CreateTypeContext) DOT() antlr.TerminalNode {
	return s.GetToken(CqlParserDOT, 0)
}

func (s *CreateTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterCreateType(s)
	}
}

func (s *CreateTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitCreateType(s)
	}
}

func (p *CqlParser) CreateType() (localctx ICreateTypeContext) {
	localctx = NewCreateTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, CqlParserRULE_createType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(952)
		p.KwCreate()
	}
	{
		p.SetState(953)
		p.KwType()
	}
	p.SetState(955)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CqlParserK_IF {
		{
			p.SetState(954)
			p.IfNotExist()
		}

	}
	p.SetState(960)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 25, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(957)
			p.Keyspace()
		}
		{
			p.SetState(958)
			p.Match(CqlParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(962)
		p.Type_()
	}
	{
		p.SetState(963)
		p.SyntaxBracketLr()
	}
	{
		p.SetState(964)
		p.TypeMemberColumnList()
	}
	{
		p.SetState(965)
		p.SyntaxBracketRr()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeMemberColumnListContext is an interface to support dynamic dispatch.
type ITypeMemberColumnListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllColumn() []IColumnContext
	Column(i int) IColumnContext
	AllDataType() []IDataTypeContext
	DataType(i int) IDataTypeContext
	AllSyntaxComma() []ISyntaxCommaContext
	SyntaxComma(i int) ISyntaxCommaContext

	// IsTypeMemberColumnListContext differentiates from other interfaces.
	IsTypeMemberColumnListContext()
}

type TypeMemberColumnListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeMemberColumnListContext() *TypeMemberColumnListContext {
	var p = new(TypeMemberColumnListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_typeMemberColumnList
	return p
}

func InitEmptyTypeMemberColumnListContext(p *TypeMemberColumnListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_typeMemberColumnList
}

func (*TypeMemberColumnListContext) IsTypeMemberColumnListContext() {}

func NewTypeMemberColumnListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeMemberColumnListContext {
	var p = new(TypeMemberColumnListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_typeMemberColumnList

	return p
}

func (s *TypeMemberColumnListContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeMemberColumnListContext) AllColumn() []IColumnContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnContext); ok {
			len++
		}
	}

	tst := make([]IColumnContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnContext); ok {
			tst[i] = t.(IColumnContext)
			i++
		}
	}

	return tst
}

func (s *TypeMemberColumnListContext) Column(i int) IColumnContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnContext)
}

func (s *TypeMemberColumnListContext) AllDataType() []IDataTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDataTypeContext); ok {
			len++
		}
	}

	tst := make([]IDataTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDataTypeContext); ok {
			tst[i] = t.(IDataTypeContext)
			i++
		}
	}

	return tst
}

func (s *TypeMemberColumnListContext) DataType(i int) IDataTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *TypeMemberColumnListContext) AllSyntaxComma() []ISyntaxCommaContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			len++
		}
	}

	tst := make([]ISyntaxCommaContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISyntaxCommaContext); ok {
			tst[i] = t.(ISyntaxCommaContext)
			i++
		}
	}

	return tst
}

func (s *TypeMemberColumnListContext) SyntaxComma(i int) ISyntaxCommaContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxCommaContext)
}

func (s *TypeMemberColumnListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeMemberColumnListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeMemberColumnListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterTypeMemberColumnList(s)
	}
}

func (s *TypeMemberColumnListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitTypeMemberColumnList(s)
	}
}

func (p *CqlParser) TypeMemberColumnList() (localctx ITypeMemberColumnListContext) {
	localctx = NewTypeMemberColumnListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, CqlParserRULE_typeMemberColumnList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(967)
		p.Column()
	}
	{
		p.SetState(968)
		p.DataType()
	}
	p.SetState(975)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == CqlParserCOMMA {
		{
			p.SetState(969)
			p.SyntaxComma()
		}
		{
			p.SetState(970)
			p.Column()
		}
		{
			p.SetState(971)
			p.DataType()
		}

		p.SetState(977)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateTriggerContext is an interface to support dynamic dispatch.
type ICreateTriggerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwCreate() IKwCreateContext
	KwTrigger() IKwTriggerContext
	Trigger() ITriggerContext
	KwUsing() IKwUsingContext
	TriggerClass() ITriggerClassContext
	IfNotExist() IIfNotExistContext
	Keyspace() IKeyspaceContext
	DOT() antlr.TerminalNode

	// IsCreateTriggerContext differentiates from other interfaces.
	IsCreateTriggerContext()
}

type CreateTriggerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateTriggerContext() *CreateTriggerContext {
	var p = new(CreateTriggerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_createTrigger
	return p
}

func InitEmptyCreateTriggerContext(p *CreateTriggerContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_createTrigger
}

func (*CreateTriggerContext) IsCreateTriggerContext() {}

func NewCreateTriggerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateTriggerContext {
	var p = new(CreateTriggerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_createTrigger

	return p
}

func (s *CreateTriggerContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateTriggerContext) KwCreate() IKwCreateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwCreateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwCreateContext)
}

func (s *CreateTriggerContext) KwTrigger() IKwTriggerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwTriggerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwTriggerContext)
}

func (s *CreateTriggerContext) Trigger() ITriggerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITriggerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITriggerContext)
}

func (s *CreateTriggerContext) KwUsing() IKwUsingContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwUsingContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwUsingContext)
}

func (s *CreateTriggerContext) TriggerClass() ITriggerClassContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITriggerClassContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITriggerClassContext)
}

func (s *CreateTriggerContext) IfNotExist() IIfNotExistContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistContext)
}

func (s *CreateTriggerContext) Keyspace() IKeyspaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyspaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyspaceContext)
}

func (s *CreateTriggerContext) DOT() antlr.TerminalNode {
	return s.GetToken(CqlParserDOT, 0)
}

func (s *CreateTriggerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateTriggerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateTriggerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterCreateTrigger(s)
	}
}

func (s *CreateTriggerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitCreateTrigger(s)
	}
}

func (p *CqlParser) CreateTrigger() (localctx ICreateTriggerContext) {
	localctx = NewCreateTriggerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, CqlParserRULE_createTrigger)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(978)
		p.KwCreate()
	}
	{
		p.SetState(979)
		p.KwTrigger()
	}
	p.SetState(981)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CqlParserK_IF {
		{
			p.SetState(980)
			p.IfNotExist()
		}

	}
	p.SetState(986)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 28, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(983)
			p.Keyspace()
		}
		{
			p.SetState(984)
			p.Match(CqlParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(988)
		p.Trigger()
	}
	{
		p.SetState(989)
		p.KwUsing()
	}
	{
		p.SetState(990)
		p.TriggerClass()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateMaterializedViewContext is an interface to support dynamic dispatch.
type ICreateMaterializedViewContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwCreate() IKwCreateContext
	KwMaterialized() IKwMaterializedContext
	KwView() IKwViewContext
	MaterializedView() IMaterializedViewContext
	KwAs() IKwAsContext
	KwSelect() IKwSelectContext
	SelectElements() ISelectElementsContext
	FromSpec() IFromSpecContext
	PrimaryKeyElement() IPrimaryKeyElementContext
	IfNotExist() IIfNotExistContext
	Keyspace() IKeyspaceContext
	DOT() antlr.TerminalNode
	MvWhereSpec() IMvWhereSpecContext
	KwWith() IKwWithContext
	MaterializedViewOptions() IMaterializedViewOptionsContext

	// IsCreateMaterializedViewContext differentiates from other interfaces.
	IsCreateMaterializedViewContext()
}

type CreateMaterializedViewContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateMaterializedViewContext() *CreateMaterializedViewContext {
	var p = new(CreateMaterializedViewContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_createMaterializedView
	return p
}

func InitEmptyCreateMaterializedViewContext(p *CreateMaterializedViewContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_createMaterializedView
}

func (*CreateMaterializedViewContext) IsCreateMaterializedViewContext() {}

func NewCreateMaterializedViewContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateMaterializedViewContext {
	var p = new(CreateMaterializedViewContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_createMaterializedView

	return p
}

func (s *CreateMaterializedViewContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateMaterializedViewContext) KwCreate() IKwCreateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwCreateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwCreateContext)
}

func (s *CreateMaterializedViewContext) KwMaterialized() IKwMaterializedContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwMaterializedContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwMaterializedContext)
}

func (s *CreateMaterializedViewContext) KwView() IKwViewContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwViewContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwViewContext)
}

func (s *CreateMaterializedViewContext) MaterializedView() IMaterializedViewContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMaterializedViewContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMaterializedViewContext)
}

func (s *CreateMaterializedViewContext) KwAs() IKwAsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwAsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwAsContext)
}

func (s *CreateMaterializedViewContext) KwSelect() IKwSelectContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwSelectContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwSelectContext)
}

func (s *CreateMaterializedViewContext) SelectElements() ISelectElementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectElementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectElementsContext)
}

func (s *CreateMaterializedViewContext) FromSpec() IFromSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFromSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFromSpecContext)
}

func (s *CreateMaterializedViewContext) PrimaryKeyElement() IPrimaryKeyElementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryKeyElementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryKeyElementContext)
}

func (s *CreateMaterializedViewContext) IfNotExist() IIfNotExistContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistContext)
}

func (s *CreateMaterializedViewContext) Keyspace() IKeyspaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyspaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyspaceContext)
}

func (s *CreateMaterializedViewContext) DOT() antlr.TerminalNode {
	return s.GetToken(CqlParserDOT, 0)
}

func (s *CreateMaterializedViewContext) MvWhereSpec() IMvWhereSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMvWhereSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMvWhereSpecContext)
}

func (s *CreateMaterializedViewContext) KwWith() IKwWithContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwWithContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwWithContext)
}

func (s *CreateMaterializedViewContext) MaterializedViewOptions() IMaterializedViewOptionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMaterializedViewOptionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMaterializedViewOptionsContext)
}

func (s *CreateMaterializedViewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateMaterializedViewContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateMaterializedViewContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterCreateMaterializedView(s)
	}
}

func (s *CreateMaterializedViewContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitCreateMaterializedView(s)
	}
}

func (p *CqlParser) CreateMaterializedView() (localctx ICreateMaterializedViewContext) {
	localctx = NewCreateMaterializedViewContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, CqlParserRULE_createMaterializedView)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(992)
		p.KwCreate()
	}
	{
		p.SetState(993)
		p.KwMaterialized()
	}
	{
		p.SetState(994)
		p.KwView()
	}
	p.SetState(996)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CqlParserK_IF {
		{
			p.SetState(995)
			p.IfNotExist()
		}

	}
	p.SetState(1001)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 30, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(998)
			p.Keyspace()
		}
		{
			p.SetState(999)
			p.Match(CqlParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1003)
		p.MaterializedView()
	}
	{
		p.SetState(1004)
		p.KwAs()
	}
	{
		p.SetState(1005)
		p.KwSelect()
	}
	{
		p.SetState(1006)
		p.SelectElements()
	}
	{
		p.SetState(1007)
		p.FromSpec()
	}
	p.SetState(1009)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CqlParserK_WHERE {
		{
			p.SetState(1008)
			p.MvWhereSpec()
		}

	}
	{
		p.SetState(1011)
		p.PrimaryKeyElement()
	}
	p.SetState(1015)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CqlParserK_WITH {
		{
			p.SetState(1012)
			p.KwWith()
		}
		{
			p.SetState(1013)
			p.MaterializedViewOptions()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMvWhereSpecContext is an interface to support dynamic dispatch.
type IMvWhereSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwWhere() IKwWhereContext
	AllMvWhereClause() []IMvWhereClauseContext
	MvWhereClause(i int) IMvWhereClauseContext
	AllKwAnd() []IKwAndContext
	KwAnd(i int) IKwAndContext

	// IsMvWhereSpecContext differentiates from other interfaces.
	IsMvWhereSpecContext()
}

type MvWhereSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMvWhereSpecContext() *MvWhereSpecContext {
	var p = new(MvWhereSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_mvWhereSpec
	return p
}

func InitEmptyMvWhereSpecContext(p *MvWhereSpecContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_mvWhereSpec
}

func (*MvWhereSpecContext) IsMvWhereSpecContext() {}

func NewMvWhereSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MvWhereSpecContext {
	var p = new(MvWhereSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_mvWhereSpec

	return p
}

func (s *MvWhereSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *MvWhereSpecContext) KwWhere() IKwWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwWhereContext)
}

func (s *MvWhereSpecContext) AllMvWhereClause() []IMvWhereClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMvWhereClauseContext); ok {
			len++
		}
	}

	tst := make([]IMvWhereClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMvWhereClauseContext); ok {
			tst[i] = t.(IMvWhereClauseContext)
			i++
		}
	}

	return tst
}

func (s *MvWhereSpecContext) MvWhereClause(i int) IMvWhereClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMvWhereClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMvWhereClauseContext)
}

func (s *MvWhereSpecContext) AllKwAnd() []IKwAndContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IKwAndContext); ok {
			len++
		}
	}

	tst := make([]IKwAndContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IKwAndContext); ok {
			tst[i] = t.(IKwAndContext)
			i++
		}
	}

	return tst
}

func (s *MvWhereSpecContext) KwAnd(i int) IKwAndContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwAndContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwAndContext)
}

func (s *MvWhereSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MvWhereSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MvWhereSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterMvWhereSpec(s)
	}
}

func (s *MvWhereSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitMvWhereSpec(s)
	}
}

func (p *CqlParser) MvWhereSpec() (localctx IMvWhereSpecContext) {
	localctx = NewMvWhereSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, CqlParserRULE_mvWhereSpec)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1017)
		p.KwWhere()
	}
	{
		p.SetState(1018)
		p.MvWhereClause()
	}
	p.SetState(1024)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == CqlParserK_AND {
		{
			p.SetState(1019)
			p.KwAnd()
		}
		{
			p.SetState(1020)
			p.MvWhereClause()
		}

		p.SetState(1026)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMvWhereClauseContext is an interface to support dynamic dispatch.
type IMvWhereClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ColumnRef() IColumnRefContext
	KwIs() IKwIsContext
	KwNot() IKwNotContext
	KwNull() IKwNullContext
	Constant() IConstantContext
	OPERATOR_EQ() antlr.TerminalNode
	OPERATOR_LT() antlr.TerminalNode
	OPERATOR_GT() antlr.TerminalNode
	OPERATOR_LTE() antlr.TerminalNode
	OPERATOR_GTE() antlr.TerminalNode

	// IsMvWhereClauseContext differentiates from other interfaces.
	IsMvWhereClauseContext()
}

type MvWhereClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMvWhereClauseContext() *MvWhereClauseContext {
	var p = new(MvWhereClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_mvWhereClause
	return p
}

func InitEmptyMvWhereClauseContext(p *MvWhereClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_mvWhereClause
}

func (*MvWhereClauseContext) IsMvWhereClauseContext() {}

func NewMvWhereClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MvWhereClauseContext {
	var p = new(MvWhereClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_mvWhereClause

	return p
}

func (s *MvWhereClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *MvWhereClauseContext) ColumnRef() IColumnRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnRefContext)
}

func (s *MvWhereClauseContext) KwIs() IKwIsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwIsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwIsContext)
}

func (s *MvWhereClauseContext) KwNot() IKwNotContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwNotContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwNotContext)
}

func (s *MvWhereClauseContext) KwNull() IKwNullContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwNullContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwNullContext)
}

func (s *MvWhereClauseContext) Constant() IConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *MvWhereClauseContext) OPERATOR_EQ() antlr.TerminalNode {
	return s.GetToken(CqlParserOPERATOR_EQ, 0)
}

func (s *MvWhereClauseContext) OPERATOR_LT() antlr.TerminalNode {
	return s.GetToken(CqlParserOPERATOR_LT, 0)
}

func (s *MvWhereClauseContext) OPERATOR_GT() antlr.TerminalNode {
	return s.GetToken(CqlParserOPERATOR_GT, 0)
}

func (s *MvWhereClauseContext) OPERATOR_LTE() antlr.TerminalNode {
	return s.GetToken(CqlParserOPERATOR_LTE, 0)
}

func (s *MvWhereClauseContext) OPERATOR_GTE() antlr.TerminalNode {
	return s.GetToken(CqlParserOPERATOR_GTE, 0)
}

func (s *MvWhereClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MvWhereClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MvWhereClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterMvWhereClause(s)
	}
}

func (s *MvWhereClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitMvWhereClause(s)
	}
}

func (p *CqlParser) MvWhereClause() (localctx IMvWhereClauseContext) {
	localctx = NewMvWhereClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, CqlParserRULE_mvWhereClause)
	var _la int

	p.SetState(1036)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 34, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1027)
			p.ColumnRef()
		}
		{
			p.SetState(1028)
			p.KwIs()
		}
		{
			p.SetState(1029)
			p.KwNot()
		}
		{
			p.SetState(1030)
			p.KwNull()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1032)
			p.ColumnRef()
		}
		{
			p.SetState(1033)
			_la = p.GetTokenStream().LA(1)

			if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&16252928) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1034)
			p.Constant()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMaterializedViewWhereContext is an interface to support dynamic dispatch.
type IMaterializedViewWhereContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwWhere() IKwWhereContext
	ColumnNotNullList() IColumnNotNullListContext
	KwAnd() IKwAndContext
	RelationElements() IRelationElementsContext

	// IsMaterializedViewWhereContext differentiates from other interfaces.
	IsMaterializedViewWhereContext()
}

type MaterializedViewWhereContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMaterializedViewWhereContext() *MaterializedViewWhereContext {
	var p = new(MaterializedViewWhereContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_materializedViewWhere
	return p
}

func InitEmptyMaterializedViewWhereContext(p *MaterializedViewWhereContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_materializedViewWhere
}

func (*MaterializedViewWhereContext) IsMaterializedViewWhereContext() {}

func NewMaterializedViewWhereContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MaterializedViewWhereContext {
	var p = new(MaterializedViewWhereContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_materializedViewWhere

	return p
}

func (s *MaterializedViewWhereContext) GetParser() antlr.Parser { return s.parser }

func (s *MaterializedViewWhereContext) KwWhere() IKwWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwWhereContext)
}

func (s *MaterializedViewWhereContext) ColumnNotNullList() IColumnNotNullListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnNotNullListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnNotNullListContext)
}

func (s *MaterializedViewWhereContext) KwAnd() IKwAndContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwAndContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwAndContext)
}

func (s *MaterializedViewWhereContext) RelationElements() IRelationElementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationElementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationElementsContext)
}

func (s *MaterializedViewWhereContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MaterializedViewWhereContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MaterializedViewWhereContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterMaterializedViewWhere(s)
	}
}

func (s *MaterializedViewWhereContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitMaterializedViewWhere(s)
	}
}

func (p *CqlParser) MaterializedViewWhere() (localctx IMaterializedViewWhereContext) {
	localctx = NewMaterializedViewWhereContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, CqlParserRULE_materializedViewWhere)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1038)
		p.KwWhere()
	}
	{
		p.SetState(1039)
		p.ColumnNotNullList()
	}
	p.SetState(1043)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CqlParserK_AND {
		{
			p.SetState(1040)
			p.KwAnd()
		}
		{
			p.SetState(1041)
			p.RelationElements()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnNotNullListContext is an interface to support dynamic dispatch.
type IColumnNotNullListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllColumnNotNull() []IColumnNotNullContext
	ColumnNotNull(i int) IColumnNotNullContext
	AllKwAnd() []IKwAndContext
	KwAnd(i int) IKwAndContext

	// IsColumnNotNullListContext differentiates from other interfaces.
	IsColumnNotNullListContext()
}

type ColumnNotNullListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnNotNullListContext() *ColumnNotNullListContext {
	var p = new(ColumnNotNullListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_columnNotNullList
	return p
}

func InitEmptyColumnNotNullListContext(p *ColumnNotNullListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_columnNotNullList
}

func (*ColumnNotNullListContext) IsColumnNotNullListContext() {}

func NewColumnNotNullListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnNotNullListContext {
	var p = new(ColumnNotNullListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_columnNotNullList

	return p
}

func (s *ColumnNotNullListContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnNotNullListContext) AllColumnNotNull() []IColumnNotNullContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnNotNullContext); ok {
			len++
		}
	}

	tst := make([]IColumnNotNullContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnNotNullContext); ok {
			tst[i] = t.(IColumnNotNullContext)
			i++
		}
	}

	return tst
}

func (s *ColumnNotNullListContext) ColumnNotNull(i int) IColumnNotNullContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnNotNullContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnNotNullContext)
}

func (s *ColumnNotNullListContext) AllKwAnd() []IKwAndContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IKwAndContext); ok {
			len++
		}
	}

	tst := make([]IKwAndContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IKwAndContext); ok {
			tst[i] = t.(IKwAndContext)
			i++
		}
	}

	return tst
}

func (s *ColumnNotNullListContext) KwAnd(i int) IKwAndContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwAndContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwAndContext)
}

func (s *ColumnNotNullListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnNotNullListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnNotNullListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterColumnNotNullList(s)
	}
}

func (s *ColumnNotNullListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitColumnNotNullList(s)
	}
}

func (p *CqlParser) ColumnNotNullList() (localctx IColumnNotNullListContext) {
	localctx = NewColumnNotNullListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, CqlParserRULE_columnNotNullList)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1045)
		p.ColumnNotNull()
	}
	p.SetState(1051)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 36, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1046)
				p.KwAnd()
			}
			{
				p.SetState(1047)
				p.ColumnNotNull()
			}

		}
		p.SetState(1053)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 36, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnNotNullContext is an interface to support dynamic dispatch.
type IColumnNotNullContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Column() IColumnContext
	KwIs() IKwIsContext
	KwNot() IKwNotContext
	KwNull() IKwNullContext

	// IsColumnNotNullContext differentiates from other interfaces.
	IsColumnNotNullContext()
}

type ColumnNotNullContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnNotNullContext() *ColumnNotNullContext {
	var p = new(ColumnNotNullContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_columnNotNull
	return p
}

func InitEmptyColumnNotNullContext(p *ColumnNotNullContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_columnNotNull
}

func (*ColumnNotNullContext) IsColumnNotNullContext() {}

func NewColumnNotNullContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnNotNullContext {
	var p = new(ColumnNotNullContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_columnNotNull

	return p
}

func (s *ColumnNotNullContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnNotNullContext) Column() IColumnContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnContext)
}

func (s *ColumnNotNullContext) KwIs() IKwIsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwIsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwIsContext)
}

func (s *ColumnNotNullContext) KwNot() IKwNotContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwNotContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwNotContext)
}

func (s *ColumnNotNullContext) KwNull() IKwNullContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwNullContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwNullContext)
}

func (s *ColumnNotNullContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnNotNullContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnNotNullContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterColumnNotNull(s)
	}
}

func (s *ColumnNotNullContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitColumnNotNull(s)
	}
}

func (p *CqlParser) ColumnNotNull() (localctx IColumnNotNullContext) {
	localctx = NewColumnNotNullContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, CqlParserRULE_columnNotNull)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1054)
		p.Column()
	}
	{
		p.SetState(1055)
		p.KwIs()
	}
	{
		p.SetState(1056)
		p.KwNot()
	}
	{
		p.SetState(1057)
		p.KwNull()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMaterializedViewOptionsContext is an interface to support dynamic dispatch.
type IMaterializedViewOptionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TableOptions() ITableOptionsContext
	KwAnd() IKwAndContext
	ClusteringOrder() IClusteringOrderContext

	// IsMaterializedViewOptionsContext differentiates from other interfaces.
	IsMaterializedViewOptionsContext()
}

type MaterializedViewOptionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMaterializedViewOptionsContext() *MaterializedViewOptionsContext {
	var p = new(MaterializedViewOptionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_materializedViewOptions
	return p
}

func InitEmptyMaterializedViewOptionsContext(p *MaterializedViewOptionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_materializedViewOptions
}

func (*MaterializedViewOptionsContext) IsMaterializedViewOptionsContext() {}

func NewMaterializedViewOptionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MaterializedViewOptionsContext {
	var p = new(MaterializedViewOptionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_materializedViewOptions

	return p
}

func (s *MaterializedViewOptionsContext) GetParser() antlr.Parser { return s.parser }

func (s *MaterializedViewOptionsContext) TableOptions() ITableOptionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableOptionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableOptionsContext)
}

func (s *MaterializedViewOptionsContext) KwAnd() IKwAndContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwAndContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwAndContext)
}

func (s *MaterializedViewOptionsContext) ClusteringOrder() IClusteringOrderContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClusteringOrderContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClusteringOrderContext)
}

func (s *MaterializedViewOptionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MaterializedViewOptionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MaterializedViewOptionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterMaterializedViewOptions(s)
	}
}

func (s *MaterializedViewOptionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitMaterializedViewOptions(s)
	}
}

func (p *CqlParser) MaterializedViewOptions() (localctx IMaterializedViewOptionsContext) {
	localctx = NewMaterializedViewOptionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, CqlParserRULE_materializedViewOptions)
	p.SetState(1065)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 37, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1059)
			p.TableOptions()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1060)
			p.TableOptions()
		}
		{
			p.SetState(1061)
			p.KwAnd()
		}
		{
			p.SetState(1062)
			p.ClusteringOrder()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1064)
			p.ClusteringOrder()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateKeyspaceContext is an interface to support dynamic dispatch.
type ICreateKeyspaceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwCreate() IKwCreateContext
	KwKeyspace() IKwKeyspaceContext
	Keyspace() IKeyspaceContext
	KwWith() IKwWithContext
	KwReplication() IKwReplicationContext
	OPERATOR_EQ() antlr.TerminalNode
	SyntaxBracketLc() ISyntaxBracketLcContext
	ReplicationList() IReplicationListContext
	SyntaxBracketRc() ISyntaxBracketRcContext
	IfNotExist() IIfNotExistContext
	AllKwAnd() []IKwAndContext
	KwAnd(i int) IKwAndContext
	DurableWrites() IDurableWritesContext
	TabletsSpec() ITabletsSpecContext

	// IsCreateKeyspaceContext differentiates from other interfaces.
	IsCreateKeyspaceContext()
}

type CreateKeyspaceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateKeyspaceContext() *CreateKeyspaceContext {
	var p = new(CreateKeyspaceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_createKeyspace
	return p
}

func InitEmptyCreateKeyspaceContext(p *CreateKeyspaceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_createKeyspace
}

func (*CreateKeyspaceContext) IsCreateKeyspaceContext() {}

func NewCreateKeyspaceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateKeyspaceContext {
	var p = new(CreateKeyspaceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_createKeyspace

	return p
}

func (s *CreateKeyspaceContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateKeyspaceContext) KwCreate() IKwCreateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwCreateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwCreateContext)
}

func (s *CreateKeyspaceContext) KwKeyspace() IKwKeyspaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwKeyspaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwKeyspaceContext)
}

func (s *CreateKeyspaceContext) Keyspace() IKeyspaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyspaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyspaceContext)
}

func (s *CreateKeyspaceContext) KwWith() IKwWithContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwWithContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwWithContext)
}

func (s *CreateKeyspaceContext) KwReplication() IKwReplicationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwReplicationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwReplicationContext)
}

func (s *CreateKeyspaceContext) OPERATOR_EQ() antlr.TerminalNode {
	return s.GetToken(CqlParserOPERATOR_EQ, 0)
}

func (s *CreateKeyspaceContext) SyntaxBracketLc() ISyntaxBracketLcContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxBracketLcContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxBracketLcContext)
}

func (s *CreateKeyspaceContext) ReplicationList() IReplicationListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReplicationListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReplicationListContext)
}

func (s *CreateKeyspaceContext) SyntaxBracketRc() ISyntaxBracketRcContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxBracketRcContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxBracketRcContext)
}

func (s *CreateKeyspaceContext) IfNotExist() IIfNotExistContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistContext)
}

func (s *CreateKeyspaceContext) AllKwAnd() []IKwAndContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IKwAndContext); ok {
			len++
		}
	}

	tst := make([]IKwAndContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IKwAndContext); ok {
			tst[i] = t.(IKwAndContext)
			i++
		}
	}

	return tst
}

func (s *CreateKeyspaceContext) KwAnd(i int) IKwAndContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwAndContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwAndContext)
}

func (s *CreateKeyspaceContext) DurableWrites() IDurableWritesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDurableWritesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDurableWritesContext)
}

func (s *CreateKeyspaceContext) TabletsSpec() ITabletsSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITabletsSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITabletsSpecContext)
}

func (s *CreateKeyspaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateKeyspaceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateKeyspaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterCreateKeyspace(s)
	}
}

func (s *CreateKeyspaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitCreateKeyspace(s)
	}
}

func (p *CqlParser) CreateKeyspace() (localctx ICreateKeyspaceContext) {
	localctx = NewCreateKeyspaceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, CqlParserRULE_createKeyspace)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1067)
		p.KwCreate()
	}
	{
		p.SetState(1068)
		p.KwKeyspace()
	}
	p.SetState(1070)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CqlParserK_IF {
		{
			p.SetState(1069)
			p.IfNotExist()
		}

	}
	{
		p.SetState(1072)
		p.Keyspace()
	}
	{
		p.SetState(1073)
		p.KwWith()
	}
	{
		p.SetState(1074)
		p.KwReplication()
	}
	{
		p.SetState(1075)
		p.Match(CqlParserOPERATOR_EQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1076)
		p.SyntaxBracketLc()
	}
	{
		p.SetState(1077)
		p.ReplicationList()
	}
	{
		p.SetState(1078)
		p.SyntaxBracketRc()
	}
	p.SetState(1082)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 39, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1079)
			p.KwAnd()
		}
		{
			p.SetState(1080)
			p.DurableWrites()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1087)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CqlParserK_AND {
		{
			p.SetState(1084)
			p.KwAnd()
		}
		{
			p.SetState(1085)
			p.TabletsSpec()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateFunctionContext is an interface to support dynamic dispatch.
type ICreateFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwCreate() IKwCreateContext
	KwFunction() IKwFunctionContext
	Function_() IFunction_Context
	SyntaxBracketLr() ISyntaxBracketLrContext
	SyntaxBracketRr() ISyntaxBracketRrContext
	ReturnMode() IReturnModeContext
	KwReturns() IKwReturnsContext
	DataType() IDataTypeContext
	KwLanguage() IKwLanguageContext
	Language() ILanguageContext
	KwAs() IKwAsContext
	CodeBlock() ICodeBlockContext
	OrReplace() IOrReplaceContext
	IfNotExist() IIfNotExistContext
	Keyspace() IKeyspaceContext
	DOT() antlr.TerminalNode
	ParamList() IParamListContext

	// IsCreateFunctionContext differentiates from other interfaces.
	IsCreateFunctionContext()
}

type CreateFunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateFunctionContext() *CreateFunctionContext {
	var p = new(CreateFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_createFunction
	return p
}

func InitEmptyCreateFunctionContext(p *CreateFunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_createFunction
}

func (*CreateFunctionContext) IsCreateFunctionContext() {}

func NewCreateFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateFunctionContext {
	var p = new(CreateFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_createFunction

	return p
}

func (s *CreateFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateFunctionContext) KwCreate() IKwCreateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwCreateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwCreateContext)
}

func (s *CreateFunctionContext) KwFunction() IKwFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwFunctionContext)
}

func (s *CreateFunctionContext) Function_() IFunction_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunction_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunction_Context)
}

func (s *CreateFunctionContext) SyntaxBracketLr() ISyntaxBracketLrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxBracketLrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxBracketLrContext)
}

func (s *CreateFunctionContext) SyntaxBracketRr() ISyntaxBracketRrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxBracketRrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxBracketRrContext)
}

func (s *CreateFunctionContext) ReturnMode() IReturnModeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReturnModeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReturnModeContext)
}

func (s *CreateFunctionContext) KwReturns() IKwReturnsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwReturnsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwReturnsContext)
}

func (s *CreateFunctionContext) DataType() IDataTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *CreateFunctionContext) KwLanguage() IKwLanguageContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwLanguageContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwLanguageContext)
}

func (s *CreateFunctionContext) Language() ILanguageContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILanguageContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILanguageContext)
}

func (s *CreateFunctionContext) KwAs() IKwAsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwAsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwAsContext)
}

func (s *CreateFunctionContext) CodeBlock() ICodeBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICodeBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICodeBlockContext)
}

func (s *CreateFunctionContext) OrReplace() IOrReplaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrReplaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrReplaceContext)
}

func (s *CreateFunctionContext) IfNotExist() IIfNotExistContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistContext)
}

func (s *CreateFunctionContext) Keyspace() IKeyspaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyspaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyspaceContext)
}

func (s *CreateFunctionContext) DOT() antlr.TerminalNode {
	return s.GetToken(CqlParserDOT, 0)
}

func (s *CreateFunctionContext) ParamList() IParamListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParamListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParamListContext)
}

func (s *CreateFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterCreateFunction(s)
	}
}

func (s *CreateFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitCreateFunction(s)
	}
}

func (p *CqlParser) CreateFunction() (localctx ICreateFunctionContext) {
	localctx = NewCreateFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, CqlParserRULE_createFunction)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1089)
		p.KwCreate()
	}
	p.SetState(1091)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CqlParserK_OR {
		{
			p.SetState(1090)
			p.OrReplace()
		}

	}
	{
		p.SetState(1093)
		p.KwFunction()
	}
	p.SetState(1095)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CqlParserK_IF {
		{
			p.SetState(1094)
			p.IfNotExist()
		}

	}
	p.SetState(1100)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 43, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1097)
			p.Keyspace()
		}
		{
			p.SetState(1098)
			p.Match(CqlParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1102)
		p.Function_()
	}
	{
		p.SetState(1103)
		p.SyntaxBracketLr()
	}
	p.SetState(1105)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CqlParserK_INPUT || _la == CqlParserOBJECT_NAME {
		{
			p.SetState(1104)
			p.ParamList()
		}

	}
	{
		p.SetState(1107)
		p.SyntaxBracketRr()
	}
	{
		p.SetState(1108)
		p.ReturnMode()
	}
	{
		p.SetState(1109)
		p.KwReturns()
	}
	{
		p.SetState(1110)
		p.DataType()
	}
	{
		p.SetState(1111)
		p.KwLanguage()
	}
	{
		p.SetState(1112)
		p.Language()
	}
	{
		p.SetState(1113)
		p.KwAs()
	}
	{
		p.SetState(1114)
		p.CodeBlock()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICodeBlockContext is an interface to support dynamic dispatch.
type ICodeBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CODE_BLOCK() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode

	// IsCodeBlockContext differentiates from other interfaces.
	IsCodeBlockContext()
}

type CodeBlockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCodeBlockContext() *CodeBlockContext {
	var p = new(CodeBlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_codeBlock
	return p
}

func InitEmptyCodeBlockContext(p *CodeBlockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_codeBlock
}

func (*CodeBlockContext) IsCodeBlockContext() {}

func NewCodeBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CodeBlockContext {
	var p = new(CodeBlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_codeBlock

	return p
}

func (s *CodeBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *CodeBlockContext) CODE_BLOCK() antlr.TerminalNode {
	return s.GetToken(CqlParserCODE_BLOCK, 0)
}

func (s *CodeBlockContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(CqlParserSTRING_LITERAL, 0)
}

func (s *CodeBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CodeBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CodeBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterCodeBlock(s)
	}
}

func (s *CodeBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitCodeBlock(s)
	}
}

func (p *CqlParser) CodeBlock() (localctx ICodeBlockContext) {
	localctx = NewCodeBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, CqlParserRULE_codeBlock)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1116)
		_la = p.GetTokenStream().LA(1)

		if !(_la == CqlParserCODE_BLOCK || _la == CqlParserSTRING_LITERAL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParamListContext is an interface to support dynamic dispatch.
type IParamListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllParam() []IParamContext
	Param(i int) IParamContext
	AllSyntaxComma() []ISyntaxCommaContext
	SyntaxComma(i int) ISyntaxCommaContext

	// IsParamListContext differentiates from other interfaces.
	IsParamListContext()
}

type ParamListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParamListContext() *ParamListContext {
	var p = new(ParamListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_paramList
	return p
}

func InitEmptyParamListContext(p *ParamListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_paramList
}

func (*ParamListContext) IsParamListContext() {}

func NewParamListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParamListContext {
	var p = new(ParamListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_paramList

	return p
}

func (s *ParamListContext) GetParser() antlr.Parser { return s.parser }

func (s *ParamListContext) AllParam() []IParamContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IParamContext); ok {
			len++
		}
	}

	tst := make([]IParamContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IParamContext); ok {
			tst[i] = t.(IParamContext)
			i++
		}
	}

	return tst
}

func (s *ParamListContext) Param(i int) IParamContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParamContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParamContext)
}

func (s *ParamListContext) AllSyntaxComma() []ISyntaxCommaContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			len++
		}
	}

	tst := make([]ISyntaxCommaContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISyntaxCommaContext); ok {
			tst[i] = t.(ISyntaxCommaContext)
			i++
		}
	}

	return tst
}

func (s *ParamListContext) SyntaxComma(i int) ISyntaxCommaContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxCommaContext)
}

func (s *ParamListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParamListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParamListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterParamList(s)
	}
}

func (s *ParamListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitParamList(s)
	}
}

func (p *CqlParser) ParamList() (localctx IParamListContext) {
	localctx = NewParamListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, CqlParserRULE_paramList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1118)
		p.Param()
	}
	p.SetState(1124)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == CqlParserCOMMA {
		{
			p.SetState(1119)
			p.SyntaxComma()
		}
		{
			p.SetState(1120)
			p.Param()
		}

		p.SetState(1126)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReturnModeContext is an interface to support dynamic dispatch.
type IReturnModeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwOn() IKwOnContext
	AllKwNull() []IKwNullContext
	KwNull(i int) IKwNullContext
	KwInput() IKwInputContext
	KwCalled() IKwCalledContext
	KwReturns() IKwReturnsContext

	// IsReturnModeContext differentiates from other interfaces.
	IsReturnModeContext()
}

type ReturnModeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturnModeContext() *ReturnModeContext {
	var p = new(ReturnModeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_returnMode
	return p
}

func InitEmptyReturnModeContext(p *ReturnModeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_returnMode
}

func (*ReturnModeContext) IsReturnModeContext() {}

func NewReturnModeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReturnModeContext {
	var p = new(ReturnModeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_returnMode

	return p
}

func (s *ReturnModeContext) GetParser() antlr.Parser { return s.parser }

func (s *ReturnModeContext) KwOn() IKwOnContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwOnContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwOnContext)
}

func (s *ReturnModeContext) AllKwNull() []IKwNullContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IKwNullContext); ok {
			len++
		}
	}

	tst := make([]IKwNullContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IKwNullContext); ok {
			tst[i] = t.(IKwNullContext)
			i++
		}
	}

	return tst
}

func (s *ReturnModeContext) KwNull(i int) IKwNullContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwNullContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwNullContext)
}

func (s *ReturnModeContext) KwInput() IKwInputContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwInputContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwInputContext)
}

func (s *ReturnModeContext) KwCalled() IKwCalledContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwCalledContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwCalledContext)
}

func (s *ReturnModeContext) KwReturns() IKwReturnsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwReturnsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwReturnsContext)
}

func (s *ReturnModeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReturnModeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReturnModeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterReturnMode(s)
	}
}

func (s *ReturnModeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitReturnMode(s)
	}
}

func (p *CqlParser) ReturnMode() (localctx IReturnModeContext) {
	localctx = NewReturnModeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, CqlParserRULE_returnMode)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(1131)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case CqlParserK_CALLED:
		{
			p.SetState(1127)
			p.KwCalled()
		}

	case CqlParserK_RETURNS:
		{
			p.SetState(1128)
			p.KwReturns()
		}
		{
			p.SetState(1129)
			p.KwNull()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(1133)
		p.KwOn()
	}
	{
		p.SetState(1134)
		p.KwNull()
	}
	{
		p.SetState(1135)
		p.KwInput()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateAggregateContext is an interface to support dynamic dispatch.
type ICreateAggregateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwCreate() IKwCreateContext
	KwAggregate() IKwAggregateContext
	Aggregate() IAggregateContext
	SyntaxBracketLr() ISyntaxBracketLrContext
	AllDataType() []IDataTypeContext
	DataType(i int) IDataTypeContext
	SyntaxBracketRr() ISyntaxBracketRrContext
	KwSfunc() IKwSfuncContext
	AllFunction_() []IFunction_Context
	Function_(i int) IFunction_Context
	KwStype() IKwStypeContext
	OrReplace() IOrReplaceContext
	IfNotExist() IIfNotExistContext
	Keyspace() IKeyspaceContext
	DOT() antlr.TerminalNode
	KwReducefunc() IKwReducefuncContext
	KwFinalfunc() IKwFinalfuncContext
	KwInitcond() IKwInitcondContext
	InitCondDefinition() IInitCondDefinitionContext

	// IsCreateAggregateContext differentiates from other interfaces.
	IsCreateAggregateContext()
}

type CreateAggregateContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateAggregateContext() *CreateAggregateContext {
	var p = new(CreateAggregateContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_createAggregate
	return p
}

func InitEmptyCreateAggregateContext(p *CreateAggregateContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_createAggregate
}

func (*CreateAggregateContext) IsCreateAggregateContext() {}

func NewCreateAggregateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateAggregateContext {
	var p = new(CreateAggregateContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_createAggregate

	return p
}

func (s *CreateAggregateContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateAggregateContext) KwCreate() IKwCreateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwCreateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwCreateContext)
}

func (s *CreateAggregateContext) KwAggregate() IKwAggregateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwAggregateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwAggregateContext)
}

func (s *CreateAggregateContext) Aggregate() IAggregateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAggregateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAggregateContext)
}

func (s *CreateAggregateContext) SyntaxBracketLr() ISyntaxBracketLrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxBracketLrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxBracketLrContext)
}

func (s *CreateAggregateContext) AllDataType() []IDataTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDataTypeContext); ok {
			len++
		}
	}

	tst := make([]IDataTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDataTypeContext); ok {
			tst[i] = t.(IDataTypeContext)
			i++
		}
	}

	return tst
}

func (s *CreateAggregateContext) DataType(i int) IDataTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *CreateAggregateContext) SyntaxBracketRr() ISyntaxBracketRrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxBracketRrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxBracketRrContext)
}

func (s *CreateAggregateContext) KwSfunc() IKwSfuncContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwSfuncContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwSfuncContext)
}

func (s *CreateAggregateContext) AllFunction_() []IFunction_Context {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFunction_Context); ok {
			len++
		}
	}

	tst := make([]IFunction_Context, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFunction_Context); ok {
			tst[i] = t.(IFunction_Context)
			i++
		}
	}

	return tst
}

func (s *CreateAggregateContext) Function_(i int) IFunction_Context {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunction_Context); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunction_Context)
}

func (s *CreateAggregateContext) KwStype() IKwStypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwStypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwStypeContext)
}

func (s *CreateAggregateContext) OrReplace() IOrReplaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrReplaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrReplaceContext)
}

func (s *CreateAggregateContext) IfNotExist() IIfNotExistContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistContext)
}

func (s *CreateAggregateContext) Keyspace() IKeyspaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyspaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyspaceContext)
}

func (s *CreateAggregateContext) DOT() antlr.TerminalNode {
	return s.GetToken(CqlParserDOT, 0)
}

func (s *CreateAggregateContext) KwReducefunc() IKwReducefuncContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwReducefuncContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwReducefuncContext)
}

func (s *CreateAggregateContext) KwFinalfunc() IKwFinalfuncContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwFinalfuncContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwFinalfuncContext)
}

func (s *CreateAggregateContext) KwInitcond() IKwInitcondContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwInitcondContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwInitcondContext)
}

func (s *CreateAggregateContext) InitCondDefinition() IInitCondDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInitCondDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInitCondDefinitionContext)
}

func (s *CreateAggregateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateAggregateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateAggregateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterCreateAggregate(s)
	}
}

func (s *CreateAggregateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitCreateAggregate(s)
	}
}

func (p *CqlParser) CreateAggregate() (localctx ICreateAggregateContext) {
	localctx = NewCreateAggregateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, CqlParserRULE_createAggregate)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1137)
		p.KwCreate()
	}
	p.SetState(1139)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CqlParserK_OR {
		{
			p.SetState(1138)
			p.OrReplace()
		}

	}
	{
		p.SetState(1141)
		p.KwAggregate()
	}
	p.SetState(1143)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CqlParserK_IF {
		{
			p.SetState(1142)
			p.IfNotExist()
		}

	}
	p.SetState(1148)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 49, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1145)
			p.Keyspace()
		}
		{
			p.SetState(1146)
			p.Match(CqlParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1150)
		p.Aggregate()
	}
	{
		p.SetState(1151)
		p.SyntaxBracketLr()
	}
	{
		p.SetState(1152)
		p.DataType()
	}
	{
		p.SetState(1153)
		p.SyntaxBracketRr()
	}
	{
		p.SetState(1154)
		p.KwSfunc()
	}
	{
		p.SetState(1155)
		p.Function_()
	}
	{
		p.SetState(1156)
		p.KwStype()
	}
	{
		p.SetState(1157)
		p.DataType()
	}
	p.SetState(1161)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CqlParserK_REDUCEFUNC {
		{
			p.SetState(1158)
			p.KwReducefunc()
		}
		{
			p.SetState(1159)
			p.Function_()
		}

	}
	p.SetState(1166)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CqlParserK_FINALFUNC {
		{
			p.SetState(1163)
			p.KwFinalfunc()
		}
		{
			p.SetState(1164)
			p.Function_()
		}

	}
	p.SetState(1171)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CqlParserK_INITCOND {
		{
			p.SetState(1168)
			p.KwInitcond()
		}
		{
			p.SetState(1169)
			p.InitCondDefinition()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInitCondDefinitionContext is an interface to support dynamic dispatch.
type IInitCondDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Constant() IConstantContext
	InitCondList() IInitCondListContext
	InitCondListNested() IInitCondListNestedContext
	InitCondHash() IInitCondHashContext

	// IsInitCondDefinitionContext differentiates from other interfaces.
	IsInitCondDefinitionContext()
}

type InitCondDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInitCondDefinitionContext() *InitCondDefinitionContext {
	var p = new(InitCondDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_initCondDefinition
	return p
}

func InitEmptyInitCondDefinitionContext(p *InitCondDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_initCondDefinition
}

func (*InitCondDefinitionContext) IsInitCondDefinitionContext() {}

func NewInitCondDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InitCondDefinitionContext {
	var p = new(InitCondDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_initCondDefinition

	return p
}

func (s *InitCondDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *InitCondDefinitionContext) Constant() IConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *InitCondDefinitionContext) InitCondList() IInitCondListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInitCondListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInitCondListContext)
}

func (s *InitCondDefinitionContext) InitCondListNested() IInitCondListNestedContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInitCondListNestedContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInitCondListNestedContext)
}

func (s *InitCondDefinitionContext) InitCondHash() IInitCondHashContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInitCondHashContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInitCondHashContext)
}

func (s *InitCondDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InitCondDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InitCondDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterInitCondDefinition(s)
	}
}

func (s *InitCondDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitInitCondDefinition(s)
	}
}

func (p *CqlParser) InitCondDefinition() (localctx IInitCondDefinitionContext) {
	localctx = NewInitCondDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, CqlParserRULE_initCondDefinition)
	p.SetState(1177)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 53, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1173)
			p.Constant()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1174)
			p.InitCondList()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1175)
			p.InitCondListNested()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1176)
			p.InitCondHash()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInitCondHashContext is an interface to support dynamic dispatch.
type IInitCondHashContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SyntaxBracketLc() ISyntaxBracketLcContext
	AllInitCondHashItem() []IInitCondHashItemContext
	InitCondHashItem(i int) IInitCondHashItemContext
	SyntaxBracketRc() ISyntaxBracketRcContext
	AllSyntaxComma() []ISyntaxCommaContext
	SyntaxComma(i int) ISyntaxCommaContext

	// IsInitCondHashContext differentiates from other interfaces.
	IsInitCondHashContext()
}

type InitCondHashContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInitCondHashContext() *InitCondHashContext {
	var p = new(InitCondHashContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_initCondHash
	return p
}

func InitEmptyInitCondHashContext(p *InitCondHashContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_initCondHash
}

func (*InitCondHashContext) IsInitCondHashContext() {}

func NewInitCondHashContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InitCondHashContext {
	var p = new(InitCondHashContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_initCondHash

	return p
}

func (s *InitCondHashContext) GetParser() antlr.Parser { return s.parser }

func (s *InitCondHashContext) SyntaxBracketLc() ISyntaxBracketLcContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxBracketLcContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxBracketLcContext)
}

func (s *InitCondHashContext) AllInitCondHashItem() []IInitCondHashItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInitCondHashItemContext); ok {
			len++
		}
	}

	tst := make([]IInitCondHashItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInitCondHashItemContext); ok {
			tst[i] = t.(IInitCondHashItemContext)
			i++
		}
	}

	return tst
}

func (s *InitCondHashContext) InitCondHashItem(i int) IInitCondHashItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInitCondHashItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInitCondHashItemContext)
}

func (s *InitCondHashContext) SyntaxBracketRc() ISyntaxBracketRcContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxBracketRcContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxBracketRcContext)
}

func (s *InitCondHashContext) AllSyntaxComma() []ISyntaxCommaContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			len++
		}
	}

	tst := make([]ISyntaxCommaContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISyntaxCommaContext); ok {
			tst[i] = t.(ISyntaxCommaContext)
			i++
		}
	}

	return tst
}

func (s *InitCondHashContext) SyntaxComma(i int) ISyntaxCommaContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxCommaContext)
}

func (s *InitCondHashContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InitCondHashContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InitCondHashContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterInitCondHash(s)
	}
}

func (s *InitCondHashContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitInitCondHash(s)
	}
}

func (p *CqlParser) InitCondHash() (localctx IInitCondHashContext) {
	localctx = NewInitCondHashContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, CqlParserRULE_initCondHash)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1179)
		p.SyntaxBracketLc()
	}
	{
		p.SetState(1180)
		p.InitCondHashItem()
	}
	p.SetState(1186)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == CqlParserCOMMA {
		{
			p.SetState(1181)
			p.SyntaxComma()
		}
		{
			p.SetState(1182)
			p.InitCondHashItem()
		}

		p.SetState(1188)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1189)
		p.SyntaxBracketRc()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInitCondHashItemContext is an interface to support dynamic dispatch.
type IInitCondHashItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	HashKey() IHashKeyContext
	COLON() antlr.TerminalNode
	InitCondDefinition() IInitCondDefinitionContext

	// IsInitCondHashItemContext differentiates from other interfaces.
	IsInitCondHashItemContext()
}

type InitCondHashItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInitCondHashItemContext() *InitCondHashItemContext {
	var p = new(InitCondHashItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_initCondHashItem
	return p
}

func InitEmptyInitCondHashItemContext(p *InitCondHashItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_initCondHashItem
}

func (*InitCondHashItemContext) IsInitCondHashItemContext() {}

func NewInitCondHashItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InitCondHashItemContext {
	var p = new(InitCondHashItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_initCondHashItem

	return p
}

func (s *InitCondHashItemContext) GetParser() antlr.Parser { return s.parser }

func (s *InitCondHashItemContext) HashKey() IHashKeyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHashKeyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHashKeyContext)
}

func (s *InitCondHashItemContext) COLON() antlr.TerminalNode {
	return s.GetToken(CqlParserCOLON, 0)
}

func (s *InitCondHashItemContext) InitCondDefinition() IInitCondDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInitCondDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInitCondDefinitionContext)
}

func (s *InitCondHashItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InitCondHashItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InitCondHashItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterInitCondHashItem(s)
	}
}

func (s *InitCondHashItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitInitCondHashItem(s)
	}
}

func (p *CqlParser) InitCondHashItem() (localctx IInitCondHashItemContext) {
	localctx = NewInitCondHashItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, CqlParserRULE_initCondHashItem)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1191)
		p.HashKey()
	}
	{
		p.SetState(1192)
		p.Match(CqlParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1193)
		p.InitCondDefinition()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInitCondListNestedContext is an interface to support dynamic dispatch.
type IInitCondListNestedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SyntaxBracketLr() ISyntaxBracketLrContext
	AllInitCondList() []IInitCondListContext
	InitCondList(i int) IInitCondListContext
	SyntaxBracketRr() ISyntaxBracketRrContext
	AllSyntaxComma() []ISyntaxCommaContext
	SyntaxComma(i int) ISyntaxCommaContext
	AllConstant() []IConstantContext
	Constant(i int) IConstantContext

	// IsInitCondListNestedContext differentiates from other interfaces.
	IsInitCondListNestedContext()
}

type InitCondListNestedContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInitCondListNestedContext() *InitCondListNestedContext {
	var p = new(InitCondListNestedContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_initCondListNested
	return p
}

func InitEmptyInitCondListNestedContext(p *InitCondListNestedContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_initCondListNested
}

func (*InitCondListNestedContext) IsInitCondListNestedContext() {}

func NewInitCondListNestedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InitCondListNestedContext {
	var p = new(InitCondListNestedContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_initCondListNested

	return p
}

func (s *InitCondListNestedContext) GetParser() antlr.Parser { return s.parser }

func (s *InitCondListNestedContext) SyntaxBracketLr() ISyntaxBracketLrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxBracketLrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxBracketLrContext)
}

func (s *InitCondListNestedContext) AllInitCondList() []IInitCondListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInitCondListContext); ok {
			len++
		}
	}

	tst := make([]IInitCondListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInitCondListContext); ok {
			tst[i] = t.(IInitCondListContext)
			i++
		}
	}

	return tst
}

func (s *InitCondListNestedContext) InitCondList(i int) IInitCondListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInitCondListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInitCondListContext)
}

func (s *InitCondListNestedContext) SyntaxBracketRr() ISyntaxBracketRrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxBracketRrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxBracketRrContext)
}

func (s *InitCondListNestedContext) AllSyntaxComma() []ISyntaxCommaContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			len++
		}
	}

	tst := make([]ISyntaxCommaContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISyntaxCommaContext); ok {
			tst[i] = t.(ISyntaxCommaContext)
			i++
		}
	}

	return tst
}

func (s *InitCondListNestedContext) SyntaxComma(i int) ISyntaxCommaContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxCommaContext)
}

func (s *InitCondListNestedContext) AllConstant() []IConstantContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IConstantContext); ok {
			len++
		}
	}

	tst := make([]IConstantContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IConstantContext); ok {
			tst[i] = t.(IConstantContext)
			i++
		}
	}

	return tst
}

func (s *InitCondListNestedContext) Constant(i int) IConstantContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *InitCondListNestedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InitCondListNestedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InitCondListNestedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterInitCondListNested(s)
	}
}

func (s *InitCondListNestedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitInitCondListNested(s)
	}
}

func (p *CqlParser) InitCondListNested() (localctx IInitCondListNestedContext) {
	localctx = NewInitCondListNestedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, CqlParserRULE_initCondListNested)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1195)
		p.SyntaxBracketLr()
	}
	{
		p.SetState(1196)
		p.InitCondList()
	}
	p.SetState(1203)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == CqlParserLR_BRACKET || _la == CqlParserCOMMA {
		p.SetState(1201)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case CqlParserCOMMA:
			{
				p.SetState(1197)
				p.SyntaxComma()
			}
			{
				p.SetState(1198)
				p.Constant()
			}

		case CqlParserLR_BRACKET:
			{
				p.SetState(1200)
				p.InitCondList()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(1205)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1206)
		p.SyntaxBracketRr()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInitCondListContext is an interface to support dynamic dispatch.
type IInitCondListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SyntaxBracketLr() ISyntaxBracketLrContext
	AllConstant() []IConstantContext
	Constant(i int) IConstantContext
	SyntaxBracketRr() ISyntaxBracketRrContext
	AllSyntaxComma() []ISyntaxCommaContext
	SyntaxComma(i int) ISyntaxCommaContext

	// IsInitCondListContext differentiates from other interfaces.
	IsInitCondListContext()
}

type InitCondListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInitCondListContext() *InitCondListContext {
	var p = new(InitCondListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_initCondList
	return p
}

func InitEmptyInitCondListContext(p *InitCondListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_initCondList
}

func (*InitCondListContext) IsInitCondListContext() {}

func NewInitCondListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InitCondListContext {
	var p = new(InitCondListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_initCondList

	return p
}

func (s *InitCondListContext) GetParser() antlr.Parser { return s.parser }

func (s *InitCondListContext) SyntaxBracketLr() ISyntaxBracketLrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxBracketLrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxBracketLrContext)
}

func (s *InitCondListContext) AllConstant() []IConstantContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IConstantContext); ok {
			len++
		}
	}

	tst := make([]IConstantContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IConstantContext); ok {
			tst[i] = t.(IConstantContext)
			i++
		}
	}

	return tst
}

func (s *InitCondListContext) Constant(i int) IConstantContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *InitCondListContext) SyntaxBracketRr() ISyntaxBracketRrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxBracketRrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxBracketRrContext)
}

func (s *InitCondListContext) AllSyntaxComma() []ISyntaxCommaContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			len++
		}
	}

	tst := make([]ISyntaxCommaContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISyntaxCommaContext); ok {
			tst[i] = t.(ISyntaxCommaContext)
			i++
		}
	}

	return tst
}

func (s *InitCondListContext) SyntaxComma(i int) ISyntaxCommaContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxCommaContext)
}

func (s *InitCondListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InitCondListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InitCondListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterInitCondList(s)
	}
}

func (s *InitCondListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitInitCondList(s)
	}
}

func (p *CqlParser) InitCondList() (localctx IInitCondListContext) {
	localctx = NewInitCondListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, CqlParserRULE_initCondList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1208)
		p.SyntaxBracketLr()
	}
	{
		p.SetState(1209)
		p.Constant()
	}
	p.SetState(1215)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == CqlParserCOMMA {
		{
			p.SetState(1210)
			p.SyntaxComma()
		}
		{
			p.SetState(1211)
			p.Constant()
		}

		p.SetState(1217)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1218)
		p.SyntaxBracketRr()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOrReplaceContext is an interface to support dynamic dispatch.
type IOrReplaceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwOr() IKwOrContext
	KwReplace() IKwReplaceContext

	// IsOrReplaceContext differentiates from other interfaces.
	IsOrReplaceContext()
}

type OrReplaceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrReplaceContext() *OrReplaceContext {
	var p = new(OrReplaceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_orReplace
	return p
}

func InitEmptyOrReplaceContext(p *OrReplaceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_orReplace
}

func (*OrReplaceContext) IsOrReplaceContext() {}

func NewOrReplaceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OrReplaceContext {
	var p = new(OrReplaceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_orReplace

	return p
}

func (s *OrReplaceContext) GetParser() antlr.Parser { return s.parser }

func (s *OrReplaceContext) KwOr() IKwOrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwOrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwOrContext)
}

func (s *OrReplaceContext) KwReplace() IKwReplaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwReplaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwReplaceContext)
}

func (s *OrReplaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OrReplaceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OrReplaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterOrReplace(s)
	}
}

func (s *OrReplaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitOrReplace(s)
	}
}

func (p *CqlParser) OrReplace() (localctx IOrReplaceContext) {
	localctx = NewOrReplaceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, CqlParserRULE_orReplace)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1220)
		p.KwOr()
	}
	{
		p.SetState(1221)
		p.KwReplace()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterUserContext is an interface to support dynamic dispatch.
type IAlterUserContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwAlter() IKwAlterContext
	KwUser() IKwUserContext
	User() IUserContext
	KwWith() IKwWithContext
	UserPassword() IUserPasswordContext
	UserSuperUser() IUserSuperUserContext

	// IsAlterUserContext differentiates from other interfaces.
	IsAlterUserContext()
}

type AlterUserContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterUserContext() *AlterUserContext {
	var p = new(AlterUserContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_alterUser
	return p
}

func InitEmptyAlterUserContext(p *AlterUserContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_alterUser
}

func (*AlterUserContext) IsAlterUserContext() {}

func NewAlterUserContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterUserContext {
	var p = new(AlterUserContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_alterUser

	return p
}

func (s *AlterUserContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterUserContext) KwAlter() IKwAlterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwAlterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwAlterContext)
}

func (s *AlterUserContext) KwUser() IKwUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwUserContext)
}

func (s *AlterUserContext) User() IUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserContext)
}

func (s *AlterUserContext) KwWith() IKwWithContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwWithContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwWithContext)
}

func (s *AlterUserContext) UserPassword() IUserPasswordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserPasswordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserPasswordContext)
}

func (s *AlterUserContext) UserSuperUser() IUserSuperUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserSuperUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserSuperUserContext)
}

func (s *AlterUserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterUserContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterUserContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterAlterUser(s)
	}
}

func (s *AlterUserContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitAlterUser(s)
	}
}

func (p *CqlParser) AlterUser() (localctx IAlterUserContext) {
	localctx = NewAlterUserContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, CqlParserRULE_alterUser)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1223)
		p.KwAlter()
	}
	{
		p.SetState(1224)
		p.KwUser()
	}
	{
		p.SetState(1225)
		p.User()
	}
	{
		p.SetState(1226)
		p.KwWith()
	}
	{
		p.SetState(1227)
		p.UserPassword()
	}
	p.SetState(1229)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CqlParserK_NOSUPERUSER || _la == CqlParserK_SUPERUSER {
		{
			p.SetState(1228)
			p.UserSuperUser()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUserPasswordContext is an interface to support dynamic dispatch.
type IUserPasswordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwPassword() IKwPasswordContext
	StringLiteral() IStringLiteralContext

	// IsUserPasswordContext differentiates from other interfaces.
	IsUserPasswordContext()
}

type UserPasswordContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUserPasswordContext() *UserPasswordContext {
	var p = new(UserPasswordContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_userPassword
	return p
}

func InitEmptyUserPasswordContext(p *UserPasswordContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_userPassword
}

func (*UserPasswordContext) IsUserPasswordContext() {}

func NewUserPasswordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UserPasswordContext {
	var p = new(UserPasswordContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_userPassword

	return p
}

func (s *UserPasswordContext) GetParser() antlr.Parser { return s.parser }

func (s *UserPasswordContext) KwPassword() IKwPasswordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwPasswordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwPasswordContext)
}

func (s *UserPasswordContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *UserPasswordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserPasswordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UserPasswordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterUserPassword(s)
	}
}

func (s *UserPasswordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitUserPassword(s)
	}
}

func (p *CqlParser) UserPassword() (localctx IUserPasswordContext) {
	localctx = NewUserPasswordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, CqlParserRULE_userPassword)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1231)
		p.KwPassword()
	}
	{
		p.SetState(1232)
		p.StringLiteral()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUserSuperUserContext is an interface to support dynamic dispatch.
type IUserSuperUserContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwSuperuser() IKwSuperuserContext
	KwNosuperuser() IKwNosuperuserContext

	// IsUserSuperUserContext differentiates from other interfaces.
	IsUserSuperUserContext()
}

type UserSuperUserContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUserSuperUserContext() *UserSuperUserContext {
	var p = new(UserSuperUserContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_userSuperUser
	return p
}

func InitEmptyUserSuperUserContext(p *UserSuperUserContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_userSuperUser
}

func (*UserSuperUserContext) IsUserSuperUserContext() {}

func NewUserSuperUserContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UserSuperUserContext {
	var p = new(UserSuperUserContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_userSuperUser

	return p
}

func (s *UserSuperUserContext) GetParser() antlr.Parser { return s.parser }

func (s *UserSuperUserContext) KwSuperuser() IKwSuperuserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwSuperuserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwSuperuserContext)
}

func (s *UserSuperUserContext) KwNosuperuser() IKwNosuperuserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwNosuperuserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwNosuperuserContext)
}

func (s *UserSuperUserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserSuperUserContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UserSuperUserContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterUserSuperUser(s)
	}
}

func (s *UserSuperUserContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitUserSuperUser(s)
	}
}

func (p *CqlParser) UserSuperUser() (localctx IUserSuperUserContext) {
	localctx = NewUserSuperUserContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, CqlParserRULE_userSuperUser)
	p.SetState(1236)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case CqlParserK_SUPERUSER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1234)
			p.KwSuperuser()
		}

	case CqlParserK_NOSUPERUSER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1235)
			p.KwNosuperuser()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterTypeContext is an interface to support dynamic dispatch.
type IAlterTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwAlter() IKwAlterContext
	KwType() IKwTypeContext
	Type_() IType_Context
	AlterTypeOperation() IAlterTypeOperationContext
	Keyspace() IKeyspaceContext
	DOT() antlr.TerminalNode

	// IsAlterTypeContext differentiates from other interfaces.
	IsAlterTypeContext()
}

type AlterTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterTypeContext() *AlterTypeContext {
	var p = new(AlterTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_alterType
	return p
}

func InitEmptyAlterTypeContext(p *AlterTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_alterType
}

func (*AlterTypeContext) IsAlterTypeContext() {}

func NewAlterTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterTypeContext {
	var p = new(AlterTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_alterType

	return p
}

func (s *AlterTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterTypeContext) KwAlter() IKwAlterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwAlterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwAlterContext)
}

func (s *AlterTypeContext) KwType() IKwTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwTypeContext)
}

func (s *AlterTypeContext) Type_() IType_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *AlterTypeContext) AlterTypeOperation() IAlterTypeOperationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterTypeOperationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterTypeOperationContext)
}

func (s *AlterTypeContext) Keyspace() IKeyspaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyspaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyspaceContext)
}

func (s *AlterTypeContext) DOT() antlr.TerminalNode {
	return s.GetToken(CqlParserDOT, 0)
}

func (s *AlterTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterAlterType(s)
	}
}

func (s *AlterTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitAlterType(s)
	}
}

func (p *CqlParser) AlterType() (localctx IAlterTypeContext) {
	localctx = NewAlterTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, CqlParserRULE_alterType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1238)
		p.KwAlter()
	}
	{
		p.SetState(1239)
		p.KwType()
	}
	p.SetState(1243)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 60, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1240)
			p.Keyspace()
		}
		{
			p.SetState(1241)
			p.Match(CqlParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1245)
		p.Type_()
	}
	{
		p.SetState(1246)
		p.AlterTypeOperation()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterTypeOperationContext is an interface to support dynamic dispatch.
type IAlterTypeOperationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AlterTypeAlterType() IAlterTypeAlterTypeContext
	AlterTypeAdd() IAlterTypeAddContext
	AlterTypeRename() IAlterTypeRenameContext

	// IsAlterTypeOperationContext differentiates from other interfaces.
	IsAlterTypeOperationContext()
}

type AlterTypeOperationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterTypeOperationContext() *AlterTypeOperationContext {
	var p = new(AlterTypeOperationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_alterTypeOperation
	return p
}

func InitEmptyAlterTypeOperationContext(p *AlterTypeOperationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_alterTypeOperation
}

func (*AlterTypeOperationContext) IsAlterTypeOperationContext() {}

func NewAlterTypeOperationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterTypeOperationContext {
	var p = new(AlterTypeOperationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_alterTypeOperation

	return p
}

func (s *AlterTypeOperationContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterTypeOperationContext) AlterTypeAlterType() IAlterTypeAlterTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterTypeAlterTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterTypeAlterTypeContext)
}

func (s *AlterTypeOperationContext) AlterTypeAdd() IAlterTypeAddContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterTypeAddContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterTypeAddContext)
}

func (s *AlterTypeOperationContext) AlterTypeRename() IAlterTypeRenameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterTypeRenameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterTypeRenameContext)
}

func (s *AlterTypeOperationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTypeOperationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterTypeOperationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterAlterTypeOperation(s)
	}
}

func (s *AlterTypeOperationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitAlterTypeOperation(s)
	}
}

func (p *CqlParser) AlterTypeOperation() (localctx IAlterTypeOperationContext) {
	localctx = NewAlterTypeOperationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, CqlParserRULE_alterTypeOperation)
	p.SetState(1251)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case CqlParserK_ALTER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1248)
			p.AlterTypeAlterType()
		}

	case CqlParserK_ADD:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1249)
			p.AlterTypeAdd()
		}

	case CqlParserK_RENAME:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1250)
			p.AlterTypeRename()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterTypeRenameContext is an interface to support dynamic dispatch.
type IAlterTypeRenameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwRename() IKwRenameContext
	AlterTypeRenameList() IAlterTypeRenameListContext

	// IsAlterTypeRenameContext differentiates from other interfaces.
	IsAlterTypeRenameContext()
}

type AlterTypeRenameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterTypeRenameContext() *AlterTypeRenameContext {
	var p = new(AlterTypeRenameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_alterTypeRename
	return p
}

func InitEmptyAlterTypeRenameContext(p *AlterTypeRenameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_alterTypeRename
}

func (*AlterTypeRenameContext) IsAlterTypeRenameContext() {}

func NewAlterTypeRenameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterTypeRenameContext {
	var p = new(AlterTypeRenameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_alterTypeRename

	return p
}

func (s *AlterTypeRenameContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterTypeRenameContext) KwRename() IKwRenameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwRenameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwRenameContext)
}

func (s *AlterTypeRenameContext) AlterTypeRenameList() IAlterTypeRenameListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterTypeRenameListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterTypeRenameListContext)
}

func (s *AlterTypeRenameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTypeRenameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterTypeRenameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterAlterTypeRename(s)
	}
}

func (s *AlterTypeRenameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitAlterTypeRename(s)
	}
}

func (p *CqlParser) AlterTypeRename() (localctx IAlterTypeRenameContext) {
	localctx = NewAlterTypeRenameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, CqlParserRULE_alterTypeRename)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1253)
		p.KwRename()
	}
	{
		p.SetState(1254)
		p.AlterTypeRenameList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterTypeRenameListContext is an interface to support dynamic dispatch.
type IAlterTypeRenameListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllAlterTypeRenameItem() []IAlterTypeRenameItemContext
	AlterTypeRenameItem(i int) IAlterTypeRenameItemContext
	AllKwAnd() []IKwAndContext
	KwAnd(i int) IKwAndContext

	// IsAlterTypeRenameListContext differentiates from other interfaces.
	IsAlterTypeRenameListContext()
}

type AlterTypeRenameListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterTypeRenameListContext() *AlterTypeRenameListContext {
	var p = new(AlterTypeRenameListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_alterTypeRenameList
	return p
}

func InitEmptyAlterTypeRenameListContext(p *AlterTypeRenameListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_alterTypeRenameList
}

func (*AlterTypeRenameListContext) IsAlterTypeRenameListContext() {}

func NewAlterTypeRenameListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterTypeRenameListContext {
	var p = new(AlterTypeRenameListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_alterTypeRenameList

	return p
}

func (s *AlterTypeRenameListContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterTypeRenameListContext) AllAlterTypeRenameItem() []IAlterTypeRenameItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAlterTypeRenameItemContext); ok {
			len++
		}
	}

	tst := make([]IAlterTypeRenameItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAlterTypeRenameItemContext); ok {
			tst[i] = t.(IAlterTypeRenameItemContext)
			i++
		}
	}

	return tst
}

func (s *AlterTypeRenameListContext) AlterTypeRenameItem(i int) IAlterTypeRenameItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterTypeRenameItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterTypeRenameItemContext)
}

func (s *AlterTypeRenameListContext) AllKwAnd() []IKwAndContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IKwAndContext); ok {
			len++
		}
	}

	tst := make([]IKwAndContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IKwAndContext); ok {
			tst[i] = t.(IKwAndContext)
			i++
		}
	}

	return tst
}

func (s *AlterTypeRenameListContext) KwAnd(i int) IKwAndContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwAndContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwAndContext)
}

func (s *AlterTypeRenameListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTypeRenameListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterTypeRenameListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterAlterTypeRenameList(s)
	}
}

func (s *AlterTypeRenameListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitAlterTypeRenameList(s)
	}
}

func (p *CqlParser) AlterTypeRenameList() (localctx IAlterTypeRenameListContext) {
	localctx = NewAlterTypeRenameListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, CqlParserRULE_alterTypeRenameList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1256)
		p.AlterTypeRenameItem()
	}
	p.SetState(1262)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == CqlParserK_AND {
		{
			p.SetState(1257)
			p.KwAnd()
		}
		{
			p.SetState(1258)
			p.AlterTypeRenameItem()
		}

		p.SetState(1264)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterTypeRenameItemContext is an interface to support dynamic dispatch.
type IAlterTypeRenameItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllColumn() []IColumnContext
	Column(i int) IColumnContext
	KwTo() IKwToContext

	// IsAlterTypeRenameItemContext differentiates from other interfaces.
	IsAlterTypeRenameItemContext()
}

type AlterTypeRenameItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterTypeRenameItemContext() *AlterTypeRenameItemContext {
	var p = new(AlterTypeRenameItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_alterTypeRenameItem
	return p
}

func InitEmptyAlterTypeRenameItemContext(p *AlterTypeRenameItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_alterTypeRenameItem
}

func (*AlterTypeRenameItemContext) IsAlterTypeRenameItemContext() {}

func NewAlterTypeRenameItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterTypeRenameItemContext {
	var p = new(AlterTypeRenameItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_alterTypeRenameItem

	return p
}

func (s *AlterTypeRenameItemContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterTypeRenameItemContext) AllColumn() []IColumnContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnContext); ok {
			len++
		}
	}

	tst := make([]IColumnContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnContext); ok {
			tst[i] = t.(IColumnContext)
			i++
		}
	}

	return tst
}

func (s *AlterTypeRenameItemContext) Column(i int) IColumnContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnContext)
}

func (s *AlterTypeRenameItemContext) KwTo() IKwToContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwToContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwToContext)
}

func (s *AlterTypeRenameItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTypeRenameItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterTypeRenameItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterAlterTypeRenameItem(s)
	}
}

func (s *AlterTypeRenameItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitAlterTypeRenameItem(s)
	}
}

func (p *CqlParser) AlterTypeRenameItem() (localctx IAlterTypeRenameItemContext) {
	localctx = NewAlterTypeRenameItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, CqlParserRULE_alterTypeRenameItem)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1265)
		p.Column()
	}
	{
		p.SetState(1266)
		p.KwTo()
	}
	{
		p.SetState(1267)
		p.Column()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterTypeAddContext is an interface to support dynamic dispatch.
type IAlterTypeAddContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwAdd() IKwAddContext
	AllColumn() []IColumnContext
	Column(i int) IColumnContext
	AllDataType() []IDataTypeContext
	DataType(i int) IDataTypeContext
	AllSyntaxComma() []ISyntaxCommaContext
	SyntaxComma(i int) ISyntaxCommaContext

	// IsAlterTypeAddContext differentiates from other interfaces.
	IsAlterTypeAddContext()
}

type AlterTypeAddContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterTypeAddContext() *AlterTypeAddContext {
	var p = new(AlterTypeAddContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_alterTypeAdd
	return p
}

func InitEmptyAlterTypeAddContext(p *AlterTypeAddContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_alterTypeAdd
}

func (*AlterTypeAddContext) IsAlterTypeAddContext() {}

func NewAlterTypeAddContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterTypeAddContext {
	var p = new(AlterTypeAddContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_alterTypeAdd

	return p
}

func (s *AlterTypeAddContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterTypeAddContext) KwAdd() IKwAddContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwAddContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwAddContext)
}

func (s *AlterTypeAddContext) AllColumn() []IColumnContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnContext); ok {
			len++
		}
	}

	tst := make([]IColumnContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnContext); ok {
			tst[i] = t.(IColumnContext)
			i++
		}
	}

	return tst
}

func (s *AlterTypeAddContext) Column(i int) IColumnContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnContext)
}

func (s *AlterTypeAddContext) AllDataType() []IDataTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDataTypeContext); ok {
			len++
		}
	}

	tst := make([]IDataTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDataTypeContext); ok {
			tst[i] = t.(IDataTypeContext)
			i++
		}
	}

	return tst
}

func (s *AlterTypeAddContext) DataType(i int) IDataTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *AlterTypeAddContext) AllSyntaxComma() []ISyntaxCommaContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			len++
		}
	}

	tst := make([]ISyntaxCommaContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISyntaxCommaContext); ok {
			tst[i] = t.(ISyntaxCommaContext)
			i++
		}
	}

	return tst
}

func (s *AlterTypeAddContext) SyntaxComma(i int) ISyntaxCommaContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxCommaContext)
}

func (s *AlterTypeAddContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTypeAddContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterTypeAddContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterAlterTypeAdd(s)
	}
}

func (s *AlterTypeAddContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitAlterTypeAdd(s)
	}
}

func (p *CqlParser) AlterTypeAdd() (localctx IAlterTypeAddContext) {
	localctx = NewAlterTypeAddContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, CqlParserRULE_alterTypeAdd)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1269)
		p.KwAdd()
	}
	{
		p.SetState(1270)
		p.Column()
	}
	{
		p.SetState(1271)
		p.DataType()
	}
	p.SetState(1278)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == CqlParserCOMMA {
		{
			p.SetState(1272)
			p.SyntaxComma()
		}
		{
			p.SetState(1273)
			p.Column()
		}
		{
			p.SetState(1274)
			p.DataType()
		}

		p.SetState(1280)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterTypeAlterTypeContext is an interface to support dynamic dispatch.
type IAlterTypeAlterTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwAlter() IKwAlterContext
	Column() IColumnContext
	KwType() IKwTypeContext
	DataType() IDataTypeContext

	// IsAlterTypeAlterTypeContext differentiates from other interfaces.
	IsAlterTypeAlterTypeContext()
}

type AlterTypeAlterTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterTypeAlterTypeContext() *AlterTypeAlterTypeContext {
	var p = new(AlterTypeAlterTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_alterTypeAlterType
	return p
}

func InitEmptyAlterTypeAlterTypeContext(p *AlterTypeAlterTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_alterTypeAlterType
}

func (*AlterTypeAlterTypeContext) IsAlterTypeAlterTypeContext() {}

func NewAlterTypeAlterTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterTypeAlterTypeContext {
	var p = new(AlterTypeAlterTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_alterTypeAlterType

	return p
}

func (s *AlterTypeAlterTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterTypeAlterTypeContext) KwAlter() IKwAlterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwAlterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwAlterContext)
}

func (s *AlterTypeAlterTypeContext) Column() IColumnContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnContext)
}

func (s *AlterTypeAlterTypeContext) KwType() IKwTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwTypeContext)
}

func (s *AlterTypeAlterTypeContext) DataType() IDataTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *AlterTypeAlterTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTypeAlterTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterTypeAlterTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterAlterTypeAlterType(s)
	}
}

func (s *AlterTypeAlterTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitAlterTypeAlterType(s)
	}
}

func (p *CqlParser) AlterTypeAlterType() (localctx IAlterTypeAlterTypeContext) {
	localctx = NewAlterTypeAlterTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, CqlParserRULE_alterTypeAlterType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1281)
		p.KwAlter()
	}
	{
		p.SetState(1282)
		p.Column()
	}
	{
		p.SetState(1283)
		p.KwType()
	}
	{
		p.SetState(1284)
		p.DataType()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterTableContext is an interface to support dynamic dispatch.
type IAlterTableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwAlter() IKwAlterContext
	KwTable() IKwTableContext
	Table() ITableContext
	AlterTableOperation() IAlterTableOperationContext
	Keyspace() IKeyspaceContext
	DOT() antlr.TerminalNode

	// IsAlterTableContext differentiates from other interfaces.
	IsAlterTableContext()
}

type AlterTableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterTableContext() *AlterTableContext {
	var p = new(AlterTableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_alterTable
	return p
}

func InitEmptyAlterTableContext(p *AlterTableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_alterTable
}

func (*AlterTableContext) IsAlterTableContext() {}

func NewAlterTableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterTableContext {
	var p = new(AlterTableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_alterTable

	return p
}

func (s *AlterTableContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterTableContext) KwAlter() IKwAlterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwAlterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwAlterContext)
}

func (s *AlterTableContext) KwTable() IKwTableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwTableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwTableContext)
}

func (s *AlterTableContext) Table() ITableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableContext)
}

func (s *AlterTableContext) AlterTableOperation() IAlterTableOperationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterTableOperationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterTableOperationContext)
}

func (s *AlterTableContext) Keyspace() IKeyspaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyspaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyspaceContext)
}

func (s *AlterTableContext) DOT() antlr.TerminalNode {
	return s.GetToken(CqlParserDOT, 0)
}

func (s *AlterTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterAlterTable(s)
	}
}

func (s *AlterTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitAlterTable(s)
	}
}

func (p *CqlParser) AlterTable() (localctx IAlterTableContext) {
	localctx = NewAlterTableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, CqlParserRULE_alterTable)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1286)
		p.KwAlter()
	}
	{
		p.SetState(1287)
		p.KwTable()
	}
	p.SetState(1291)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 64, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1288)
			p.Keyspace()
		}
		{
			p.SetState(1289)
			p.Match(CqlParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1293)
		p.Table()
	}
	{
		p.SetState(1294)
		p.AlterTableOperation()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterTableOperationContext is an interface to support dynamic dispatch.
type IAlterTableOperationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AlterTableAdd() IAlterTableAddContext
	AlterTableDropColumns() IAlterTableDropColumnsContext
	AlterTableDropCompactStorage() IAlterTableDropCompactStorageContext
	AlterTableRename() IAlterTableRenameContext
	AlterTableWith() IAlterTableWithContext

	// IsAlterTableOperationContext differentiates from other interfaces.
	IsAlterTableOperationContext()
}

type AlterTableOperationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterTableOperationContext() *AlterTableOperationContext {
	var p = new(AlterTableOperationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_alterTableOperation
	return p
}

func InitEmptyAlterTableOperationContext(p *AlterTableOperationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_alterTableOperation
}

func (*AlterTableOperationContext) IsAlterTableOperationContext() {}

func NewAlterTableOperationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterTableOperationContext {
	var p = new(AlterTableOperationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_alterTableOperation

	return p
}

func (s *AlterTableOperationContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterTableOperationContext) AlterTableAdd() IAlterTableAddContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterTableAddContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterTableAddContext)
}

func (s *AlterTableOperationContext) AlterTableDropColumns() IAlterTableDropColumnsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterTableDropColumnsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterTableDropColumnsContext)
}

func (s *AlterTableOperationContext) AlterTableDropCompactStorage() IAlterTableDropCompactStorageContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterTableDropCompactStorageContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterTableDropCompactStorageContext)
}

func (s *AlterTableOperationContext) AlterTableRename() IAlterTableRenameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterTableRenameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterTableRenameContext)
}

func (s *AlterTableOperationContext) AlterTableWith() IAlterTableWithContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterTableWithContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterTableWithContext)
}

func (s *AlterTableOperationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableOperationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterTableOperationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterAlterTableOperation(s)
	}
}

func (s *AlterTableOperationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitAlterTableOperation(s)
	}
}

func (p *CqlParser) AlterTableOperation() (localctx IAlterTableOperationContext) {
	localctx = NewAlterTableOperationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, CqlParserRULE_alterTableOperation)
	p.SetState(1301)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 65, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1296)
			p.AlterTableAdd()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1297)
			p.AlterTableDropColumns()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1298)
			p.AlterTableDropCompactStorage()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1299)
			p.AlterTableRename()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1300)
			p.AlterTableWith()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterTableWithContext is an interface to support dynamic dispatch.
type IAlterTableWithContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwWith() IKwWithContext
	TableOptions() ITableOptionsContext

	// IsAlterTableWithContext differentiates from other interfaces.
	IsAlterTableWithContext()
}

type AlterTableWithContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterTableWithContext() *AlterTableWithContext {
	var p = new(AlterTableWithContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_alterTableWith
	return p
}

func InitEmptyAlterTableWithContext(p *AlterTableWithContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_alterTableWith
}

func (*AlterTableWithContext) IsAlterTableWithContext() {}

func NewAlterTableWithContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterTableWithContext {
	var p = new(AlterTableWithContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_alterTableWith

	return p
}

func (s *AlterTableWithContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterTableWithContext) KwWith() IKwWithContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwWithContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwWithContext)
}

func (s *AlterTableWithContext) TableOptions() ITableOptionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableOptionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableOptionsContext)
}

func (s *AlterTableWithContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableWithContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterTableWithContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterAlterTableWith(s)
	}
}

func (s *AlterTableWithContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitAlterTableWith(s)
	}
}

func (p *CqlParser) AlterTableWith() (localctx IAlterTableWithContext) {
	localctx = NewAlterTableWithContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, CqlParserRULE_alterTableWith)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1303)
		p.KwWith()
	}
	{
		p.SetState(1304)
		p.TableOptions()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterTableRenameContext is an interface to support dynamic dispatch.
type IAlterTableRenameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwRename() IKwRenameContext
	AllColumn() []IColumnContext
	Column(i int) IColumnContext
	KwTo() IKwToContext

	// IsAlterTableRenameContext differentiates from other interfaces.
	IsAlterTableRenameContext()
}

type AlterTableRenameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterTableRenameContext() *AlterTableRenameContext {
	var p = new(AlterTableRenameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_alterTableRename
	return p
}

func InitEmptyAlterTableRenameContext(p *AlterTableRenameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_alterTableRename
}

func (*AlterTableRenameContext) IsAlterTableRenameContext() {}

func NewAlterTableRenameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterTableRenameContext {
	var p = new(AlterTableRenameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_alterTableRename

	return p
}

func (s *AlterTableRenameContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterTableRenameContext) KwRename() IKwRenameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwRenameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwRenameContext)
}

func (s *AlterTableRenameContext) AllColumn() []IColumnContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnContext); ok {
			len++
		}
	}

	tst := make([]IColumnContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnContext); ok {
			tst[i] = t.(IColumnContext)
			i++
		}
	}

	return tst
}

func (s *AlterTableRenameContext) Column(i int) IColumnContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnContext)
}

func (s *AlterTableRenameContext) KwTo() IKwToContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwToContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwToContext)
}

func (s *AlterTableRenameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableRenameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterTableRenameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterAlterTableRename(s)
	}
}

func (s *AlterTableRenameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitAlterTableRename(s)
	}
}

func (p *CqlParser) AlterTableRename() (localctx IAlterTableRenameContext) {
	localctx = NewAlterTableRenameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, CqlParserRULE_alterTableRename)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1306)
		p.KwRename()
	}
	{
		p.SetState(1307)
		p.Column()
	}
	{
		p.SetState(1308)
		p.KwTo()
	}
	{
		p.SetState(1309)
		p.Column()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterTableDropCompactStorageContext is an interface to support dynamic dispatch.
type IAlterTableDropCompactStorageContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwDrop() IKwDropContext
	KwCompact() IKwCompactContext
	KwStorage() IKwStorageContext

	// IsAlterTableDropCompactStorageContext differentiates from other interfaces.
	IsAlterTableDropCompactStorageContext()
}

type AlterTableDropCompactStorageContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterTableDropCompactStorageContext() *AlterTableDropCompactStorageContext {
	var p = new(AlterTableDropCompactStorageContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_alterTableDropCompactStorage
	return p
}

func InitEmptyAlterTableDropCompactStorageContext(p *AlterTableDropCompactStorageContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_alterTableDropCompactStorage
}

func (*AlterTableDropCompactStorageContext) IsAlterTableDropCompactStorageContext() {}

func NewAlterTableDropCompactStorageContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterTableDropCompactStorageContext {
	var p = new(AlterTableDropCompactStorageContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_alterTableDropCompactStorage

	return p
}

func (s *AlterTableDropCompactStorageContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterTableDropCompactStorageContext) KwDrop() IKwDropContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwDropContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwDropContext)
}

func (s *AlterTableDropCompactStorageContext) KwCompact() IKwCompactContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwCompactContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwCompactContext)
}

func (s *AlterTableDropCompactStorageContext) KwStorage() IKwStorageContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwStorageContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwStorageContext)
}

func (s *AlterTableDropCompactStorageContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableDropCompactStorageContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterTableDropCompactStorageContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterAlterTableDropCompactStorage(s)
	}
}

func (s *AlterTableDropCompactStorageContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitAlterTableDropCompactStorage(s)
	}
}

func (p *CqlParser) AlterTableDropCompactStorage() (localctx IAlterTableDropCompactStorageContext) {
	localctx = NewAlterTableDropCompactStorageContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, CqlParserRULE_alterTableDropCompactStorage)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1311)
		p.KwDrop()
	}
	{
		p.SetState(1312)
		p.KwCompact()
	}
	{
		p.SetState(1313)
		p.KwStorage()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterTableDropColumnsContext is an interface to support dynamic dispatch.
type IAlterTableDropColumnsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwDrop() IKwDropContext
	AlterTableDropColumnList() IAlterTableDropColumnListContext

	// IsAlterTableDropColumnsContext differentiates from other interfaces.
	IsAlterTableDropColumnsContext()
}

type AlterTableDropColumnsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterTableDropColumnsContext() *AlterTableDropColumnsContext {
	var p = new(AlterTableDropColumnsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_alterTableDropColumns
	return p
}

func InitEmptyAlterTableDropColumnsContext(p *AlterTableDropColumnsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_alterTableDropColumns
}

func (*AlterTableDropColumnsContext) IsAlterTableDropColumnsContext() {}

func NewAlterTableDropColumnsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterTableDropColumnsContext {
	var p = new(AlterTableDropColumnsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_alterTableDropColumns

	return p
}

func (s *AlterTableDropColumnsContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterTableDropColumnsContext) KwDrop() IKwDropContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwDropContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwDropContext)
}

func (s *AlterTableDropColumnsContext) AlterTableDropColumnList() IAlterTableDropColumnListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterTableDropColumnListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterTableDropColumnListContext)
}

func (s *AlterTableDropColumnsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableDropColumnsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterTableDropColumnsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterAlterTableDropColumns(s)
	}
}

func (s *AlterTableDropColumnsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitAlterTableDropColumns(s)
	}
}

func (p *CqlParser) AlterTableDropColumns() (localctx IAlterTableDropColumnsContext) {
	localctx = NewAlterTableDropColumnsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, CqlParserRULE_alterTableDropColumns)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1315)
		p.KwDrop()
	}
	{
		p.SetState(1316)
		p.AlterTableDropColumnList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterTableDropColumnListContext is an interface to support dynamic dispatch.
type IAlterTableDropColumnListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllColumn() []IColumnContext
	Column(i int) IColumnContext
	AllSyntaxComma() []ISyntaxCommaContext
	SyntaxComma(i int) ISyntaxCommaContext

	// IsAlterTableDropColumnListContext differentiates from other interfaces.
	IsAlterTableDropColumnListContext()
}

type AlterTableDropColumnListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterTableDropColumnListContext() *AlterTableDropColumnListContext {
	var p = new(AlterTableDropColumnListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_alterTableDropColumnList
	return p
}

func InitEmptyAlterTableDropColumnListContext(p *AlterTableDropColumnListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_alterTableDropColumnList
}

func (*AlterTableDropColumnListContext) IsAlterTableDropColumnListContext() {}

func NewAlterTableDropColumnListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterTableDropColumnListContext {
	var p = new(AlterTableDropColumnListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_alterTableDropColumnList

	return p
}

func (s *AlterTableDropColumnListContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterTableDropColumnListContext) AllColumn() []IColumnContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnContext); ok {
			len++
		}
	}

	tst := make([]IColumnContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnContext); ok {
			tst[i] = t.(IColumnContext)
			i++
		}
	}

	return tst
}

func (s *AlterTableDropColumnListContext) Column(i int) IColumnContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnContext)
}

func (s *AlterTableDropColumnListContext) AllSyntaxComma() []ISyntaxCommaContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			len++
		}
	}

	tst := make([]ISyntaxCommaContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISyntaxCommaContext); ok {
			tst[i] = t.(ISyntaxCommaContext)
			i++
		}
	}

	return tst
}

func (s *AlterTableDropColumnListContext) SyntaxComma(i int) ISyntaxCommaContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxCommaContext)
}

func (s *AlterTableDropColumnListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableDropColumnListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterTableDropColumnListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterAlterTableDropColumnList(s)
	}
}

func (s *AlterTableDropColumnListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitAlterTableDropColumnList(s)
	}
}

func (p *CqlParser) AlterTableDropColumnList() (localctx IAlterTableDropColumnListContext) {
	localctx = NewAlterTableDropColumnListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, CqlParserRULE_alterTableDropColumnList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1318)
		p.Column()
	}
	p.SetState(1324)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == CqlParserCOMMA {
		{
			p.SetState(1319)
			p.SyntaxComma()
		}
		{
			p.SetState(1320)
			p.Column()
		}

		p.SetState(1326)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterTableAddContext is an interface to support dynamic dispatch.
type IAlterTableAddContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwAdd() IKwAddContext
	Column() IColumnContext
	DataType() IDataTypeContext
	StaticColumn() IStaticColumnContext
	SyntaxBracketLr() ISyntaxBracketLrContext
	AllColumnDefinition() []IColumnDefinitionContext
	ColumnDefinition(i int) IColumnDefinitionContext
	SyntaxBracketRr() ISyntaxBracketRrContext
	AllSyntaxComma() []ISyntaxCommaContext
	SyntaxComma(i int) ISyntaxCommaContext

	// IsAlterTableAddContext differentiates from other interfaces.
	IsAlterTableAddContext()
}

type AlterTableAddContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterTableAddContext() *AlterTableAddContext {
	var p = new(AlterTableAddContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_alterTableAdd
	return p
}

func InitEmptyAlterTableAddContext(p *AlterTableAddContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_alterTableAdd
}

func (*AlterTableAddContext) IsAlterTableAddContext() {}

func NewAlterTableAddContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterTableAddContext {
	var p = new(AlterTableAddContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_alterTableAdd

	return p
}

func (s *AlterTableAddContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterTableAddContext) KwAdd() IKwAddContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwAddContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwAddContext)
}

func (s *AlterTableAddContext) Column() IColumnContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnContext)
}

func (s *AlterTableAddContext) DataType() IDataTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *AlterTableAddContext) StaticColumn() IStaticColumnContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStaticColumnContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStaticColumnContext)
}

func (s *AlterTableAddContext) SyntaxBracketLr() ISyntaxBracketLrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxBracketLrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxBracketLrContext)
}

func (s *AlterTableAddContext) AllColumnDefinition() []IColumnDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnDefinitionContext); ok {
			len++
		}
	}

	tst := make([]IColumnDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnDefinitionContext); ok {
			tst[i] = t.(IColumnDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *AlterTableAddContext) ColumnDefinition(i int) IColumnDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnDefinitionContext)
}

func (s *AlterTableAddContext) SyntaxBracketRr() ISyntaxBracketRrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxBracketRrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxBracketRrContext)
}

func (s *AlterTableAddContext) AllSyntaxComma() []ISyntaxCommaContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			len++
		}
	}

	tst := make([]ISyntaxCommaContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISyntaxCommaContext); ok {
			tst[i] = t.(ISyntaxCommaContext)
			i++
		}
	}

	return tst
}

func (s *AlterTableAddContext) SyntaxComma(i int) ISyntaxCommaContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxCommaContext)
}

func (s *AlterTableAddContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableAddContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterTableAddContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterAlterTableAdd(s)
	}
}

func (s *AlterTableAddContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitAlterTableAdd(s)
	}
}

func (p *CqlParser) AlterTableAdd() (localctx IAlterTableAddContext) {
	localctx = NewAlterTableAddContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, CqlParserRULE_alterTableAdd)
	var _la int

	p.SetState(1346)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 69, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1327)
			p.KwAdd()
		}
		{
			p.SetState(1328)
			p.Column()
		}
		{
			p.SetState(1329)
			p.DataType()
		}
		p.SetState(1331)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == CqlParserK_STATIC {
			{
				p.SetState(1330)
				p.StaticColumn()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1333)
			p.KwAdd()
		}
		{
			p.SetState(1334)
			p.SyntaxBracketLr()
		}
		{
			p.SetState(1335)
			p.ColumnDefinition()
		}
		p.SetState(1341)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == CqlParserCOMMA {
			{
				p.SetState(1336)
				p.SyntaxComma()
			}
			{
				p.SetState(1337)
				p.ColumnDefinition()
			}

			p.SetState(1343)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1344)
			p.SyntaxBracketRr()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterTableColumnDefinitionContext is an interface to support dynamic dispatch.
type IAlterTableColumnDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllColumn() []IColumnContext
	Column(i int) IColumnContext
	AllDataType() []IDataTypeContext
	DataType(i int) IDataTypeContext
	AllSyntaxComma() []ISyntaxCommaContext
	SyntaxComma(i int) ISyntaxCommaContext

	// IsAlterTableColumnDefinitionContext differentiates from other interfaces.
	IsAlterTableColumnDefinitionContext()
}

type AlterTableColumnDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterTableColumnDefinitionContext() *AlterTableColumnDefinitionContext {
	var p = new(AlterTableColumnDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_alterTableColumnDefinition
	return p
}

func InitEmptyAlterTableColumnDefinitionContext(p *AlterTableColumnDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_alterTableColumnDefinition
}

func (*AlterTableColumnDefinitionContext) IsAlterTableColumnDefinitionContext() {}

func NewAlterTableColumnDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterTableColumnDefinitionContext {
	var p = new(AlterTableColumnDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_alterTableColumnDefinition

	return p
}

func (s *AlterTableColumnDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterTableColumnDefinitionContext) AllColumn() []IColumnContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnContext); ok {
			len++
		}
	}

	tst := make([]IColumnContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnContext); ok {
			tst[i] = t.(IColumnContext)
			i++
		}
	}

	return tst
}

func (s *AlterTableColumnDefinitionContext) Column(i int) IColumnContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnContext)
}

func (s *AlterTableColumnDefinitionContext) AllDataType() []IDataTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDataTypeContext); ok {
			len++
		}
	}

	tst := make([]IDataTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDataTypeContext); ok {
			tst[i] = t.(IDataTypeContext)
			i++
		}
	}

	return tst
}

func (s *AlterTableColumnDefinitionContext) DataType(i int) IDataTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *AlterTableColumnDefinitionContext) AllSyntaxComma() []ISyntaxCommaContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			len++
		}
	}

	tst := make([]ISyntaxCommaContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISyntaxCommaContext); ok {
			tst[i] = t.(ISyntaxCommaContext)
			i++
		}
	}

	return tst
}

func (s *AlterTableColumnDefinitionContext) SyntaxComma(i int) ISyntaxCommaContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxCommaContext)
}

func (s *AlterTableColumnDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableColumnDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterTableColumnDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterAlterTableColumnDefinition(s)
	}
}

func (s *AlterTableColumnDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitAlterTableColumnDefinition(s)
	}
}

func (p *CqlParser) AlterTableColumnDefinition() (localctx IAlterTableColumnDefinitionContext) {
	localctx = NewAlterTableColumnDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, CqlParserRULE_alterTableColumnDefinition)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1348)
		p.Column()
	}
	{
		p.SetState(1349)
		p.DataType()
	}
	p.SetState(1356)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == CqlParserCOMMA {
		{
			p.SetState(1350)
			p.SyntaxComma()
		}
		{
			p.SetState(1351)
			p.Column()
		}
		{
			p.SetState(1352)
			p.DataType()
		}

		p.SetState(1358)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterRoleContext is an interface to support dynamic dispatch.
type IAlterRoleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwAlter() IKwAlterContext
	KwRole() IKwRoleContext
	Role() IRoleContext
	RoleWith() IRoleWithContext

	// IsAlterRoleContext differentiates from other interfaces.
	IsAlterRoleContext()
}

type AlterRoleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterRoleContext() *AlterRoleContext {
	var p = new(AlterRoleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_alterRole
	return p
}

func InitEmptyAlterRoleContext(p *AlterRoleContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_alterRole
}

func (*AlterRoleContext) IsAlterRoleContext() {}

func NewAlterRoleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterRoleContext {
	var p = new(AlterRoleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_alterRole

	return p
}

func (s *AlterRoleContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterRoleContext) KwAlter() IKwAlterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwAlterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwAlterContext)
}

func (s *AlterRoleContext) KwRole() IKwRoleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwRoleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwRoleContext)
}

func (s *AlterRoleContext) Role() IRoleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleContext)
}

func (s *AlterRoleContext) RoleWith() IRoleWithContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleWithContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleWithContext)
}

func (s *AlterRoleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterRoleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterRoleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterAlterRole(s)
	}
}

func (s *AlterRoleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitAlterRole(s)
	}
}

func (p *CqlParser) AlterRole() (localctx IAlterRoleContext) {
	localctx = NewAlterRoleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, CqlParserRULE_alterRole)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1359)
		p.KwAlter()
	}
	{
		p.SetState(1360)
		p.KwRole()
	}
	{
		p.SetState(1361)
		p.Role()
	}
	p.SetState(1363)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CqlParserK_WITH {
		{
			p.SetState(1362)
			p.RoleWith()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRoleWithContext is an interface to support dynamic dispatch.
type IRoleWithContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwWith() IKwWithContext
	AllRoleWithOptions() []IRoleWithOptionsContext
	RoleWithOptions(i int) IRoleWithOptionsContext
	AllKwAnd() []IKwAndContext
	KwAnd(i int) IKwAndContext

	// IsRoleWithContext differentiates from other interfaces.
	IsRoleWithContext()
}

type RoleWithContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRoleWithContext() *RoleWithContext {
	var p = new(RoleWithContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_roleWith
	return p
}

func InitEmptyRoleWithContext(p *RoleWithContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_roleWith
}

func (*RoleWithContext) IsRoleWithContext() {}

func NewRoleWithContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RoleWithContext {
	var p = new(RoleWithContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_roleWith

	return p
}

func (s *RoleWithContext) GetParser() antlr.Parser { return s.parser }

func (s *RoleWithContext) KwWith() IKwWithContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwWithContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwWithContext)
}

func (s *RoleWithContext) AllRoleWithOptions() []IRoleWithOptionsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRoleWithOptionsContext); ok {
			len++
		}
	}

	tst := make([]IRoleWithOptionsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRoleWithOptionsContext); ok {
			tst[i] = t.(IRoleWithOptionsContext)
			i++
		}
	}

	return tst
}

func (s *RoleWithContext) RoleWithOptions(i int) IRoleWithOptionsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleWithOptionsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleWithOptionsContext)
}

func (s *RoleWithContext) AllKwAnd() []IKwAndContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IKwAndContext); ok {
			len++
		}
	}

	tst := make([]IKwAndContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IKwAndContext); ok {
			tst[i] = t.(IKwAndContext)
			i++
		}
	}

	return tst
}

func (s *RoleWithContext) KwAnd(i int) IKwAndContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwAndContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwAndContext)
}

func (s *RoleWithContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RoleWithContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RoleWithContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterRoleWith(s)
	}
}

func (s *RoleWithContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitRoleWith(s)
	}
}

func (p *CqlParser) RoleWith() (localctx IRoleWithContext) {
	localctx = NewRoleWithContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, CqlParserRULE_roleWith)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1365)
		p.KwWith()
	}

	{
		p.SetState(1366)
		p.RoleWithOptions()
	}
	p.SetState(1372)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == CqlParserK_AND {
		{
			p.SetState(1367)
			p.KwAnd()
		}
		{
			p.SetState(1368)
			p.RoleWithOptions()
		}

		p.SetState(1374)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRoleWithOptionsContext is an interface to support dynamic dispatch.
type IRoleWithOptionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwPassword() IKwPasswordContext
	OPERATOR_EQ() antlr.TerminalNode
	StringLiteral() IStringLiteralContext
	KwHashed() IKwHashedContext
	KwLogin() IKwLoginContext
	BooleanLiteral() IBooleanLiteralContext
	KwSuperuser() IKwSuperuserContext
	KwOptions() IKwOptionsContext
	OptionHash() IOptionHashContext
	KwNologin() IKwNologinContext

	// IsRoleWithOptionsContext differentiates from other interfaces.
	IsRoleWithOptionsContext()
}

type RoleWithOptionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRoleWithOptionsContext() *RoleWithOptionsContext {
	var p = new(RoleWithOptionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_roleWithOptions
	return p
}

func InitEmptyRoleWithOptionsContext(p *RoleWithOptionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_roleWithOptions
}

func (*RoleWithOptionsContext) IsRoleWithOptionsContext() {}

func NewRoleWithOptionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RoleWithOptionsContext {
	var p = new(RoleWithOptionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_roleWithOptions

	return p
}

func (s *RoleWithOptionsContext) GetParser() antlr.Parser { return s.parser }

func (s *RoleWithOptionsContext) KwPassword() IKwPasswordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwPasswordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwPasswordContext)
}

func (s *RoleWithOptionsContext) OPERATOR_EQ() antlr.TerminalNode {
	return s.GetToken(CqlParserOPERATOR_EQ, 0)
}

func (s *RoleWithOptionsContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *RoleWithOptionsContext) KwHashed() IKwHashedContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwHashedContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwHashedContext)
}

func (s *RoleWithOptionsContext) KwLogin() IKwLoginContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwLoginContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwLoginContext)
}

func (s *RoleWithOptionsContext) BooleanLiteral() IBooleanLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanLiteralContext)
}

func (s *RoleWithOptionsContext) KwSuperuser() IKwSuperuserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwSuperuserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwSuperuserContext)
}

func (s *RoleWithOptionsContext) KwOptions() IKwOptionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwOptionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwOptionsContext)
}

func (s *RoleWithOptionsContext) OptionHash() IOptionHashContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOptionHashContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOptionHashContext)
}

func (s *RoleWithOptionsContext) KwNologin() IKwNologinContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwNologinContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwNologinContext)
}

func (s *RoleWithOptionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RoleWithOptionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RoleWithOptionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterRoleWithOptions(s)
	}
}

func (s *RoleWithOptionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitRoleWithOptions(s)
	}
}

func (p *CqlParser) RoleWithOptions() (localctx IRoleWithOptionsContext) {
	localctx = NewRoleWithOptionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, CqlParserRULE_roleWithOptions)
	p.SetState(1400)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case CqlParserK_PASSWORD:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1375)
			p.KwPassword()
		}
		{
			p.SetState(1376)
			p.Match(CqlParserOPERATOR_EQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1377)
			p.StringLiteral()
		}

	case CqlParserK_HASHED:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1379)
			p.KwHashed()
		}
		{
			p.SetState(1380)
			p.KwPassword()
		}
		{
			p.SetState(1381)
			p.Match(CqlParserOPERATOR_EQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1382)
			p.StringLiteral()
		}

	case CqlParserK_LOGIN:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1384)
			p.KwLogin()
		}
		{
			p.SetState(1385)
			p.Match(CqlParserOPERATOR_EQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1386)
			p.BooleanLiteral()
		}

	case CqlParserK_SUPERUSER:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1388)
			p.KwSuperuser()
		}
		{
			p.SetState(1389)
			p.Match(CqlParserOPERATOR_EQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1390)
			p.BooleanLiteral()
		}

	case CqlParserK_OPTIONS:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1392)
			p.KwOptions()
		}
		{
			p.SetState(1393)
			p.Match(CqlParserOPERATOR_EQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1394)
			p.OptionHash()
		}

	case CqlParserK_NOLOGIN:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1396)
			p.KwNologin()
		}
		{
			p.SetState(1397)
			p.Match(CqlParserOPERATOR_EQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1398)
			p.BooleanLiteral()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterMaterializedViewContext is an interface to support dynamic dispatch.
type IAlterMaterializedViewContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwAlter() IKwAlterContext
	KwMaterialized() IKwMaterializedContext
	KwView() IKwViewContext
	MaterializedView() IMaterializedViewContext
	Keyspace() IKeyspaceContext
	DOT() antlr.TerminalNode
	KwWith() IKwWithContext
	TableOptions() ITableOptionsContext

	// IsAlterMaterializedViewContext differentiates from other interfaces.
	IsAlterMaterializedViewContext()
}

type AlterMaterializedViewContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterMaterializedViewContext() *AlterMaterializedViewContext {
	var p = new(AlterMaterializedViewContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_alterMaterializedView
	return p
}

func InitEmptyAlterMaterializedViewContext(p *AlterMaterializedViewContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_alterMaterializedView
}

func (*AlterMaterializedViewContext) IsAlterMaterializedViewContext() {}

func NewAlterMaterializedViewContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterMaterializedViewContext {
	var p = new(AlterMaterializedViewContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_alterMaterializedView

	return p
}

func (s *AlterMaterializedViewContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterMaterializedViewContext) KwAlter() IKwAlterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwAlterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwAlterContext)
}

func (s *AlterMaterializedViewContext) KwMaterialized() IKwMaterializedContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwMaterializedContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwMaterializedContext)
}

func (s *AlterMaterializedViewContext) KwView() IKwViewContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwViewContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwViewContext)
}

func (s *AlterMaterializedViewContext) MaterializedView() IMaterializedViewContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMaterializedViewContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMaterializedViewContext)
}

func (s *AlterMaterializedViewContext) Keyspace() IKeyspaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyspaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyspaceContext)
}

func (s *AlterMaterializedViewContext) DOT() antlr.TerminalNode {
	return s.GetToken(CqlParserDOT, 0)
}

func (s *AlterMaterializedViewContext) KwWith() IKwWithContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwWithContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwWithContext)
}

func (s *AlterMaterializedViewContext) TableOptions() ITableOptionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableOptionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableOptionsContext)
}

func (s *AlterMaterializedViewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterMaterializedViewContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterMaterializedViewContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterAlterMaterializedView(s)
	}
}

func (s *AlterMaterializedViewContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitAlterMaterializedView(s)
	}
}

func (p *CqlParser) AlterMaterializedView() (localctx IAlterMaterializedViewContext) {
	localctx = NewAlterMaterializedViewContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, CqlParserRULE_alterMaterializedView)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1402)
		p.KwAlter()
	}
	{
		p.SetState(1403)
		p.KwMaterialized()
	}
	{
		p.SetState(1404)
		p.KwView()
	}
	p.SetState(1408)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 74, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1405)
			p.Keyspace()
		}
		{
			p.SetState(1406)
			p.Match(CqlParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1410)
		p.MaterializedView()
	}
	p.SetState(1414)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CqlParserK_WITH {
		{
			p.SetState(1411)
			p.KwWith()
		}
		{
			p.SetState(1412)
			p.TableOptions()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropUserContext is an interface to support dynamic dispatch.
type IDropUserContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwDrop() IKwDropContext
	KwUser() IKwUserContext
	User() IUserContext
	IfExist() IIfExistContext

	// IsDropUserContext differentiates from other interfaces.
	IsDropUserContext()
}

type DropUserContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropUserContext() *DropUserContext {
	var p = new(DropUserContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_dropUser
	return p
}

func InitEmptyDropUserContext(p *DropUserContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_dropUser
}

func (*DropUserContext) IsDropUserContext() {}

func NewDropUserContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropUserContext {
	var p = new(DropUserContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_dropUser

	return p
}

func (s *DropUserContext) GetParser() antlr.Parser { return s.parser }

func (s *DropUserContext) KwDrop() IKwDropContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwDropContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwDropContext)
}

func (s *DropUserContext) KwUser() IKwUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwUserContext)
}

func (s *DropUserContext) User() IUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserContext)
}

func (s *DropUserContext) IfExist() IIfExistContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistContext)
}

func (s *DropUserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropUserContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropUserContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterDropUser(s)
	}
}

func (s *DropUserContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitDropUser(s)
	}
}

func (p *CqlParser) DropUser() (localctx IDropUserContext) {
	localctx = NewDropUserContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, CqlParserRULE_dropUser)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1416)
		p.KwDrop()
	}
	{
		p.SetState(1417)
		p.KwUser()
	}
	p.SetState(1419)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CqlParserK_IF {
		{
			p.SetState(1418)
			p.IfExist()
		}

	}
	{
		p.SetState(1421)
		p.User()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropTypeContext is an interface to support dynamic dispatch.
type IDropTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwDrop() IKwDropContext
	KwType() IKwTypeContext
	Type_() IType_Context
	IfExist() IIfExistContext
	Keyspace() IKeyspaceContext
	DOT() antlr.TerminalNode

	// IsDropTypeContext differentiates from other interfaces.
	IsDropTypeContext()
}

type DropTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropTypeContext() *DropTypeContext {
	var p = new(DropTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_dropType
	return p
}

func InitEmptyDropTypeContext(p *DropTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_dropType
}

func (*DropTypeContext) IsDropTypeContext() {}

func NewDropTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropTypeContext {
	var p = new(DropTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_dropType

	return p
}

func (s *DropTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *DropTypeContext) KwDrop() IKwDropContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwDropContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwDropContext)
}

func (s *DropTypeContext) KwType() IKwTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwTypeContext)
}

func (s *DropTypeContext) Type_() IType_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *DropTypeContext) IfExist() IIfExistContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistContext)
}

func (s *DropTypeContext) Keyspace() IKeyspaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyspaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyspaceContext)
}

func (s *DropTypeContext) DOT() antlr.TerminalNode {
	return s.GetToken(CqlParserDOT, 0)
}

func (s *DropTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterDropType(s)
	}
}

func (s *DropTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitDropType(s)
	}
}

func (p *CqlParser) DropType() (localctx IDropTypeContext) {
	localctx = NewDropTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, CqlParserRULE_dropType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1423)
		p.KwDrop()
	}
	{
		p.SetState(1424)
		p.KwType()
	}
	p.SetState(1426)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CqlParserK_IF {
		{
			p.SetState(1425)
			p.IfExist()
		}

	}
	p.SetState(1431)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 78, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1428)
			p.Keyspace()
		}
		{
			p.SetState(1429)
			p.Match(CqlParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1433)
		p.Type_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropMaterializedViewContext is an interface to support dynamic dispatch.
type IDropMaterializedViewContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwDrop() IKwDropContext
	KwMaterialized() IKwMaterializedContext
	KwView() IKwViewContext
	MaterializedView() IMaterializedViewContext
	IfExist() IIfExistContext
	Keyspace() IKeyspaceContext
	DOT() antlr.TerminalNode

	// IsDropMaterializedViewContext differentiates from other interfaces.
	IsDropMaterializedViewContext()
}

type DropMaterializedViewContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropMaterializedViewContext() *DropMaterializedViewContext {
	var p = new(DropMaterializedViewContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_dropMaterializedView
	return p
}

func InitEmptyDropMaterializedViewContext(p *DropMaterializedViewContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_dropMaterializedView
}

func (*DropMaterializedViewContext) IsDropMaterializedViewContext() {}

func NewDropMaterializedViewContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropMaterializedViewContext {
	var p = new(DropMaterializedViewContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_dropMaterializedView

	return p
}

func (s *DropMaterializedViewContext) GetParser() antlr.Parser { return s.parser }

func (s *DropMaterializedViewContext) KwDrop() IKwDropContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwDropContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwDropContext)
}

func (s *DropMaterializedViewContext) KwMaterialized() IKwMaterializedContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwMaterializedContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwMaterializedContext)
}

func (s *DropMaterializedViewContext) KwView() IKwViewContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwViewContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwViewContext)
}

func (s *DropMaterializedViewContext) MaterializedView() IMaterializedViewContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMaterializedViewContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMaterializedViewContext)
}

func (s *DropMaterializedViewContext) IfExist() IIfExistContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistContext)
}

func (s *DropMaterializedViewContext) Keyspace() IKeyspaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyspaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyspaceContext)
}

func (s *DropMaterializedViewContext) DOT() antlr.TerminalNode {
	return s.GetToken(CqlParserDOT, 0)
}

func (s *DropMaterializedViewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropMaterializedViewContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropMaterializedViewContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterDropMaterializedView(s)
	}
}

func (s *DropMaterializedViewContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitDropMaterializedView(s)
	}
}

func (p *CqlParser) DropMaterializedView() (localctx IDropMaterializedViewContext) {
	localctx = NewDropMaterializedViewContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, CqlParserRULE_dropMaterializedView)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1435)
		p.KwDrop()
	}
	{
		p.SetState(1436)
		p.KwMaterialized()
	}
	{
		p.SetState(1437)
		p.KwView()
	}
	p.SetState(1439)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CqlParserK_IF {
		{
			p.SetState(1438)
			p.IfExist()
		}

	}
	p.SetState(1444)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 80, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1441)
			p.Keyspace()
		}
		{
			p.SetState(1442)
			p.Match(CqlParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1446)
		p.MaterializedView()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropAggregateContext is an interface to support dynamic dispatch.
type IDropAggregateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwDrop() IKwDropContext
	KwAggregate() IKwAggregateContext
	Aggregate() IAggregateContext
	IfExist() IIfExistContext
	Keyspace() IKeyspaceContext
	DOT() antlr.TerminalNode
	SyntaxBracketLr() ISyntaxBracketLrContext
	DataType() IDataTypeContext
	SyntaxBracketRr() ISyntaxBracketRrContext

	// IsDropAggregateContext differentiates from other interfaces.
	IsDropAggregateContext()
}

type DropAggregateContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropAggregateContext() *DropAggregateContext {
	var p = new(DropAggregateContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_dropAggregate
	return p
}

func InitEmptyDropAggregateContext(p *DropAggregateContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_dropAggregate
}

func (*DropAggregateContext) IsDropAggregateContext() {}

func NewDropAggregateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropAggregateContext {
	var p = new(DropAggregateContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_dropAggregate

	return p
}

func (s *DropAggregateContext) GetParser() antlr.Parser { return s.parser }

func (s *DropAggregateContext) KwDrop() IKwDropContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwDropContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwDropContext)
}

func (s *DropAggregateContext) KwAggregate() IKwAggregateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwAggregateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwAggregateContext)
}

func (s *DropAggregateContext) Aggregate() IAggregateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAggregateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAggregateContext)
}

func (s *DropAggregateContext) IfExist() IIfExistContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistContext)
}

func (s *DropAggregateContext) Keyspace() IKeyspaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyspaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyspaceContext)
}

func (s *DropAggregateContext) DOT() antlr.TerminalNode {
	return s.GetToken(CqlParserDOT, 0)
}

func (s *DropAggregateContext) SyntaxBracketLr() ISyntaxBracketLrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxBracketLrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxBracketLrContext)
}

func (s *DropAggregateContext) DataType() IDataTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *DropAggregateContext) SyntaxBracketRr() ISyntaxBracketRrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxBracketRrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxBracketRrContext)
}

func (s *DropAggregateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropAggregateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropAggregateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterDropAggregate(s)
	}
}

func (s *DropAggregateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitDropAggregate(s)
	}
}

func (p *CqlParser) DropAggregate() (localctx IDropAggregateContext) {
	localctx = NewDropAggregateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, CqlParserRULE_dropAggregate)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1448)
		p.KwDrop()
	}
	{
		p.SetState(1449)
		p.KwAggregate()
	}
	p.SetState(1451)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CqlParserK_IF {
		{
			p.SetState(1450)
			p.IfExist()
		}

	}
	p.SetState(1456)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 82, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1453)
			p.Keyspace()
		}
		{
			p.SetState(1454)
			p.Match(CqlParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1458)
		p.Aggregate()
	}
	p.SetState(1463)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CqlParserLR_BRACKET {
		{
			p.SetState(1459)
			p.SyntaxBracketLr()
		}
		{
			p.SetState(1460)
			p.DataType()
		}
		{
			p.SetState(1461)
			p.SyntaxBracketRr()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropFunctionContext is an interface to support dynamic dispatch.
type IDropFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwDrop() IKwDropContext
	KwFunction() IKwFunctionContext
	Function_() IFunction_Context
	IfExist() IIfExistContext
	Keyspace() IKeyspaceContext
	DOT() antlr.TerminalNode

	// IsDropFunctionContext differentiates from other interfaces.
	IsDropFunctionContext()
}

type DropFunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropFunctionContext() *DropFunctionContext {
	var p = new(DropFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_dropFunction
	return p
}

func InitEmptyDropFunctionContext(p *DropFunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_dropFunction
}

func (*DropFunctionContext) IsDropFunctionContext() {}

func NewDropFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropFunctionContext {
	var p = new(DropFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_dropFunction

	return p
}

func (s *DropFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *DropFunctionContext) KwDrop() IKwDropContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwDropContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwDropContext)
}

func (s *DropFunctionContext) KwFunction() IKwFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwFunctionContext)
}

func (s *DropFunctionContext) Function_() IFunction_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunction_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunction_Context)
}

func (s *DropFunctionContext) IfExist() IIfExistContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistContext)
}

func (s *DropFunctionContext) Keyspace() IKeyspaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyspaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyspaceContext)
}

func (s *DropFunctionContext) DOT() antlr.TerminalNode {
	return s.GetToken(CqlParserDOT, 0)
}

func (s *DropFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterDropFunction(s)
	}
}

func (s *DropFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitDropFunction(s)
	}
}

func (p *CqlParser) DropFunction() (localctx IDropFunctionContext) {
	localctx = NewDropFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, CqlParserRULE_dropFunction)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1465)
		p.KwDrop()
	}
	{
		p.SetState(1466)
		p.KwFunction()
	}
	p.SetState(1468)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CqlParserK_IF {
		{
			p.SetState(1467)
			p.IfExist()
		}

	}
	p.SetState(1473)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 85, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1470)
			p.Keyspace()
		}
		{
			p.SetState(1471)
			p.Match(CqlParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1475)
		p.Function_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropTriggerContext is an interface to support dynamic dispatch.
type IDropTriggerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwDrop() IKwDropContext
	KwTrigger() IKwTriggerContext
	Trigger() ITriggerContext
	KwOn() IKwOnContext
	Table() ITableContext
	IfExist() IIfExistContext
	Keyspace() IKeyspaceContext
	DOT() antlr.TerminalNode

	// IsDropTriggerContext differentiates from other interfaces.
	IsDropTriggerContext()
}

type DropTriggerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropTriggerContext() *DropTriggerContext {
	var p = new(DropTriggerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_dropTrigger
	return p
}

func InitEmptyDropTriggerContext(p *DropTriggerContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_dropTrigger
}

func (*DropTriggerContext) IsDropTriggerContext() {}

func NewDropTriggerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropTriggerContext {
	var p = new(DropTriggerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_dropTrigger

	return p
}

func (s *DropTriggerContext) GetParser() antlr.Parser { return s.parser }

func (s *DropTriggerContext) KwDrop() IKwDropContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwDropContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwDropContext)
}

func (s *DropTriggerContext) KwTrigger() IKwTriggerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwTriggerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwTriggerContext)
}

func (s *DropTriggerContext) Trigger() ITriggerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITriggerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITriggerContext)
}

func (s *DropTriggerContext) KwOn() IKwOnContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwOnContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwOnContext)
}

func (s *DropTriggerContext) Table() ITableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableContext)
}

func (s *DropTriggerContext) IfExist() IIfExistContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistContext)
}

func (s *DropTriggerContext) Keyspace() IKeyspaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyspaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyspaceContext)
}

func (s *DropTriggerContext) DOT() antlr.TerminalNode {
	return s.GetToken(CqlParserDOT, 0)
}

func (s *DropTriggerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropTriggerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropTriggerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterDropTrigger(s)
	}
}

func (s *DropTriggerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitDropTrigger(s)
	}
}

func (p *CqlParser) DropTrigger() (localctx IDropTriggerContext) {
	localctx = NewDropTriggerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, CqlParserRULE_dropTrigger)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1477)
		p.KwDrop()
	}
	{
		p.SetState(1478)
		p.KwTrigger()
	}
	p.SetState(1480)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CqlParserK_IF {
		{
			p.SetState(1479)
			p.IfExist()
		}

	}
	{
		p.SetState(1482)
		p.Trigger()
	}
	{
		p.SetState(1483)
		p.KwOn()
	}
	p.SetState(1487)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 87, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1484)
			p.Keyspace()
		}
		{
			p.SetState(1485)
			p.Match(CqlParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1489)
		p.Table()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropRoleContext is an interface to support dynamic dispatch.
type IDropRoleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwDrop() IKwDropContext
	KwRole() IKwRoleContext
	Role() IRoleContext
	IfExist() IIfExistContext

	// IsDropRoleContext differentiates from other interfaces.
	IsDropRoleContext()
}

type DropRoleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropRoleContext() *DropRoleContext {
	var p = new(DropRoleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_dropRole
	return p
}

func InitEmptyDropRoleContext(p *DropRoleContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_dropRole
}

func (*DropRoleContext) IsDropRoleContext() {}

func NewDropRoleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropRoleContext {
	var p = new(DropRoleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_dropRole

	return p
}

func (s *DropRoleContext) GetParser() antlr.Parser { return s.parser }

func (s *DropRoleContext) KwDrop() IKwDropContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwDropContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwDropContext)
}

func (s *DropRoleContext) KwRole() IKwRoleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwRoleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwRoleContext)
}

func (s *DropRoleContext) Role() IRoleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleContext)
}

func (s *DropRoleContext) IfExist() IIfExistContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistContext)
}

func (s *DropRoleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropRoleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropRoleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterDropRole(s)
	}
}

func (s *DropRoleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitDropRole(s)
	}
}

func (p *CqlParser) DropRole() (localctx IDropRoleContext) {
	localctx = NewDropRoleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, CqlParserRULE_dropRole)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1491)
		p.KwDrop()
	}
	{
		p.SetState(1492)
		p.KwRole()
	}
	p.SetState(1494)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CqlParserK_IF {
		{
			p.SetState(1493)
			p.IfExist()
		}

	}
	{
		p.SetState(1496)
		p.Role()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropTableContext is an interface to support dynamic dispatch.
type IDropTableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwDrop() IKwDropContext
	KwTable() IKwTableContext
	Table() ITableContext
	IfExist() IIfExistContext
	Keyspace() IKeyspaceContext
	DOT() antlr.TerminalNode

	// IsDropTableContext differentiates from other interfaces.
	IsDropTableContext()
}

type DropTableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropTableContext() *DropTableContext {
	var p = new(DropTableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_dropTable
	return p
}

func InitEmptyDropTableContext(p *DropTableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_dropTable
}

func (*DropTableContext) IsDropTableContext() {}

func NewDropTableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropTableContext {
	var p = new(DropTableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_dropTable

	return p
}

func (s *DropTableContext) GetParser() antlr.Parser { return s.parser }

func (s *DropTableContext) KwDrop() IKwDropContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwDropContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwDropContext)
}

func (s *DropTableContext) KwTable() IKwTableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwTableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwTableContext)
}

func (s *DropTableContext) Table() ITableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableContext)
}

func (s *DropTableContext) IfExist() IIfExistContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistContext)
}

func (s *DropTableContext) Keyspace() IKeyspaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyspaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyspaceContext)
}

func (s *DropTableContext) DOT() antlr.TerminalNode {
	return s.GetToken(CqlParserDOT, 0)
}

func (s *DropTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropTableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterDropTable(s)
	}
}

func (s *DropTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitDropTable(s)
	}
}

func (p *CqlParser) DropTable() (localctx IDropTableContext) {
	localctx = NewDropTableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, CqlParserRULE_dropTable)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1498)
		p.KwDrop()
	}
	{
		p.SetState(1499)
		p.KwTable()
	}
	p.SetState(1501)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CqlParserK_IF {
		{
			p.SetState(1500)
			p.IfExist()
		}

	}
	p.SetState(1506)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 90, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1503)
			p.Keyspace()
		}
		{
			p.SetState(1504)
			p.Match(CqlParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1508)
		p.Table()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropKeyspaceContext is an interface to support dynamic dispatch.
type IDropKeyspaceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwDrop() IKwDropContext
	KwKeyspace() IKwKeyspaceContext
	Keyspace() IKeyspaceContext
	IfExist() IIfExistContext

	// IsDropKeyspaceContext differentiates from other interfaces.
	IsDropKeyspaceContext()
}

type DropKeyspaceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropKeyspaceContext() *DropKeyspaceContext {
	var p = new(DropKeyspaceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_dropKeyspace
	return p
}

func InitEmptyDropKeyspaceContext(p *DropKeyspaceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_dropKeyspace
}

func (*DropKeyspaceContext) IsDropKeyspaceContext() {}

func NewDropKeyspaceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropKeyspaceContext {
	var p = new(DropKeyspaceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_dropKeyspace

	return p
}

func (s *DropKeyspaceContext) GetParser() antlr.Parser { return s.parser }

func (s *DropKeyspaceContext) KwDrop() IKwDropContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwDropContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwDropContext)
}

func (s *DropKeyspaceContext) KwKeyspace() IKwKeyspaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwKeyspaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwKeyspaceContext)
}

func (s *DropKeyspaceContext) Keyspace() IKeyspaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyspaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyspaceContext)
}

func (s *DropKeyspaceContext) IfExist() IIfExistContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistContext)
}

func (s *DropKeyspaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropKeyspaceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropKeyspaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterDropKeyspace(s)
	}
}

func (s *DropKeyspaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitDropKeyspace(s)
	}
}

func (p *CqlParser) DropKeyspace() (localctx IDropKeyspaceContext) {
	localctx = NewDropKeyspaceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, CqlParserRULE_dropKeyspace)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1510)
		p.KwDrop()
	}
	{
		p.SetState(1511)
		p.KwKeyspace()
	}
	p.SetState(1513)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CqlParserK_IF {
		{
			p.SetState(1512)
			p.IfExist()
		}

	}
	{
		p.SetState(1515)
		p.Keyspace()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropIndexContext is an interface to support dynamic dispatch.
type IDropIndexContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwDrop() IKwDropContext
	KwIndex() IKwIndexContext
	IndexName() IIndexNameContext
	IfExist() IIfExistContext
	Keyspace() IKeyspaceContext
	DOT() antlr.TerminalNode

	// IsDropIndexContext differentiates from other interfaces.
	IsDropIndexContext()
}

type DropIndexContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropIndexContext() *DropIndexContext {
	var p = new(DropIndexContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_dropIndex
	return p
}

func InitEmptyDropIndexContext(p *DropIndexContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_dropIndex
}

func (*DropIndexContext) IsDropIndexContext() {}

func NewDropIndexContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropIndexContext {
	var p = new(DropIndexContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_dropIndex

	return p
}

func (s *DropIndexContext) GetParser() antlr.Parser { return s.parser }

func (s *DropIndexContext) KwDrop() IKwDropContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwDropContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwDropContext)
}

func (s *DropIndexContext) KwIndex() IKwIndexContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwIndexContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwIndexContext)
}

func (s *DropIndexContext) IndexName() IIndexNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexNameContext)
}

func (s *DropIndexContext) IfExist() IIfExistContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistContext)
}

func (s *DropIndexContext) Keyspace() IKeyspaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyspaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyspaceContext)
}

func (s *DropIndexContext) DOT() antlr.TerminalNode {
	return s.GetToken(CqlParserDOT, 0)
}

func (s *DropIndexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropIndexContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropIndexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterDropIndex(s)
	}
}

func (s *DropIndexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitDropIndex(s)
	}
}

func (p *CqlParser) DropIndex() (localctx IDropIndexContext) {
	localctx = NewDropIndexContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, CqlParserRULE_dropIndex)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1517)
		p.KwDrop()
	}
	{
		p.SetState(1518)
		p.KwIndex()
	}
	p.SetState(1520)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CqlParserK_IF {
		{
			p.SetState(1519)
			p.IfExist()
		}

	}
	p.SetState(1525)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 93, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1522)
			p.Keyspace()
		}
		{
			p.SetState(1523)
			p.Match(CqlParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1527)
		p.IndexName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateTableContext is an interface to support dynamic dispatch.
type ICreateTableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwCreate() IKwCreateContext
	KwTable() IKwTableContext
	Table() ITableContext
	SyntaxBracketLr() ISyntaxBracketLrContext
	ColumnDefinitionList() IColumnDefinitionListContext
	SyntaxBracketRr() ISyntaxBracketRrContext
	IfNotExist() IIfNotExistContext
	Keyspace() IKeyspaceContext
	DOT() antlr.TerminalNode
	WithElement() IWithElementContext

	// IsCreateTableContext differentiates from other interfaces.
	IsCreateTableContext()
}

type CreateTableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateTableContext() *CreateTableContext {
	var p = new(CreateTableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_createTable
	return p
}

func InitEmptyCreateTableContext(p *CreateTableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_createTable
}

func (*CreateTableContext) IsCreateTableContext() {}

func NewCreateTableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateTableContext {
	var p = new(CreateTableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_createTable

	return p
}

func (s *CreateTableContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateTableContext) KwCreate() IKwCreateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwCreateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwCreateContext)
}

func (s *CreateTableContext) KwTable() IKwTableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwTableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwTableContext)
}

func (s *CreateTableContext) Table() ITableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableContext)
}

func (s *CreateTableContext) SyntaxBracketLr() ISyntaxBracketLrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxBracketLrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxBracketLrContext)
}

func (s *CreateTableContext) ColumnDefinitionList() IColumnDefinitionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnDefinitionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnDefinitionListContext)
}

func (s *CreateTableContext) SyntaxBracketRr() ISyntaxBracketRrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxBracketRrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxBracketRrContext)
}

func (s *CreateTableContext) IfNotExist() IIfNotExistContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistContext)
}

func (s *CreateTableContext) Keyspace() IKeyspaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyspaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyspaceContext)
}

func (s *CreateTableContext) DOT() antlr.TerminalNode {
	return s.GetToken(CqlParserDOT, 0)
}

func (s *CreateTableContext) WithElement() IWithElementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWithElementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWithElementContext)
}

func (s *CreateTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateTableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterCreateTable(s)
	}
}

func (s *CreateTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitCreateTable(s)
	}
}

func (p *CqlParser) CreateTable() (localctx ICreateTableContext) {
	localctx = NewCreateTableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, CqlParserRULE_createTable)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1529)
		p.KwCreate()
	}
	{
		p.SetState(1530)
		p.KwTable()
	}
	p.SetState(1532)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CqlParserK_IF {
		{
			p.SetState(1531)
			p.IfNotExist()
		}

	}
	p.SetState(1537)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 95, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1534)
			p.Keyspace()
		}
		{
			p.SetState(1535)
			p.Match(CqlParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1539)
		p.Table()
	}
	{
		p.SetState(1540)
		p.SyntaxBracketLr()
	}
	{
		p.SetState(1541)
		p.ColumnDefinitionList()
	}
	{
		p.SetState(1542)
		p.SyntaxBracketRr()
	}
	p.SetState(1544)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CqlParserK_WITH {
		{
			p.SetState(1543)
			p.WithElement()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWithElementContext is an interface to support dynamic dispatch.
type IWithElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwWith() IKwWithContext
	TableOptions() ITableOptionsContext

	// IsWithElementContext differentiates from other interfaces.
	IsWithElementContext()
}

type WithElementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWithElementContext() *WithElementContext {
	var p = new(WithElementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_withElement
	return p
}

func InitEmptyWithElementContext(p *WithElementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_withElement
}

func (*WithElementContext) IsWithElementContext() {}

func NewWithElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WithElementContext {
	var p = new(WithElementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_withElement

	return p
}

func (s *WithElementContext) GetParser() antlr.Parser { return s.parser }

func (s *WithElementContext) KwWith() IKwWithContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwWithContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwWithContext)
}

func (s *WithElementContext) TableOptions() ITableOptionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableOptionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableOptionsContext)
}

func (s *WithElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WithElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WithElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterWithElement(s)
	}
}

func (s *WithElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitWithElement(s)
	}
}

func (p *CqlParser) WithElement() (localctx IWithElementContext) {
	localctx = NewWithElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, CqlParserRULE_withElement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1546)
		p.KwWith()
	}
	{
		p.SetState(1547)
		p.TableOptions()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableOptionsContext is an interface to support dynamic dispatch.
type ITableOptionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwCompact() IKwCompactContext
	KwStorage() IKwStorageContext
	AllKwAnd() []IKwAndContext
	KwAnd(i int) IKwAndContext
	TableOptions() ITableOptionsContext
	ClusteringOrder() IClusteringOrderContext
	AllTableOptionItem() []ITableOptionItemContext
	TableOptionItem(i int) ITableOptionItemContext

	// IsTableOptionsContext differentiates from other interfaces.
	IsTableOptionsContext()
}

type TableOptionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableOptionsContext() *TableOptionsContext {
	var p = new(TableOptionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_tableOptions
	return p
}

func InitEmptyTableOptionsContext(p *TableOptionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_tableOptions
}

func (*TableOptionsContext) IsTableOptionsContext() {}

func NewTableOptionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableOptionsContext {
	var p = new(TableOptionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_tableOptions

	return p
}

func (s *TableOptionsContext) GetParser() antlr.Parser { return s.parser }

func (s *TableOptionsContext) KwCompact() IKwCompactContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwCompactContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwCompactContext)
}

func (s *TableOptionsContext) KwStorage() IKwStorageContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwStorageContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwStorageContext)
}

func (s *TableOptionsContext) AllKwAnd() []IKwAndContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IKwAndContext); ok {
			len++
		}
	}

	tst := make([]IKwAndContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IKwAndContext); ok {
			tst[i] = t.(IKwAndContext)
			i++
		}
	}

	return tst
}

func (s *TableOptionsContext) KwAnd(i int) IKwAndContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwAndContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwAndContext)
}

func (s *TableOptionsContext) TableOptions() ITableOptionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableOptionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableOptionsContext)
}

func (s *TableOptionsContext) ClusteringOrder() IClusteringOrderContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClusteringOrderContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClusteringOrderContext)
}

func (s *TableOptionsContext) AllTableOptionItem() []ITableOptionItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITableOptionItemContext); ok {
			len++
		}
	}

	tst := make([]ITableOptionItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITableOptionItemContext); ok {
			tst[i] = t.(ITableOptionItemContext)
			i++
		}
	}

	return tst
}

func (s *TableOptionsContext) TableOptionItem(i int) ITableOptionItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableOptionItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableOptionItemContext)
}

func (s *TableOptionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableOptionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterTableOptions(s)
	}
}

func (s *TableOptionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitTableOptions(s)
	}
}

func (p *CqlParser) TableOptions() (localctx ITableOptionsContext) {
	localctx = NewTableOptionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, CqlParserRULE_tableOptions)
	var _alt int

	p.SetState(1571)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case CqlParserK_COMPACT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1549)
			p.KwCompact()
		}
		{
			p.SetState(1550)
			p.KwStorage()
		}
		p.SetState(1554)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 97, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1551)
				p.KwAnd()
			}
			{
				p.SetState(1552)
				p.TableOptions()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case CqlParserK_CLUSTERING:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1556)
			p.ClusteringOrder()
		}
		p.SetState(1560)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 98, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1557)
				p.KwAnd()
			}
			{
				p.SetState(1558)
				p.TableOptions()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case CqlParserOBJECT_NAME:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1562)
			p.TableOptionItem()
		}
		p.SetState(1568)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 99, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1563)
					p.KwAnd()
				}
				{
					p.SetState(1564)
					p.TableOptionItem()
				}

			}
			p.SetState(1570)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 99, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClusteringOrderContext is an interface to support dynamic dispatch.
type IClusteringOrderContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwClustering() IKwClusteringContext
	KwOrder() IKwOrderContext
	KwBy() IKwByContext
	SyntaxBracketLr() ISyntaxBracketLrContext
	SyntaxBracketRr() ISyntaxBracketRrContext
	AllColumn() []IColumnContext
	Column(i int) IColumnContext
	AllSyntaxComma() []ISyntaxCommaContext
	SyntaxComma(i int) ISyntaxCommaContext
	AllOrderDirection() []IOrderDirectionContext
	OrderDirection(i int) IOrderDirectionContext

	// IsClusteringOrderContext differentiates from other interfaces.
	IsClusteringOrderContext()
}

type ClusteringOrderContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClusteringOrderContext() *ClusteringOrderContext {
	var p = new(ClusteringOrderContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_clusteringOrder
	return p
}

func InitEmptyClusteringOrderContext(p *ClusteringOrderContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_clusteringOrder
}

func (*ClusteringOrderContext) IsClusteringOrderContext() {}

func NewClusteringOrderContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClusteringOrderContext {
	var p = new(ClusteringOrderContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_clusteringOrder

	return p
}

func (s *ClusteringOrderContext) GetParser() antlr.Parser { return s.parser }

func (s *ClusteringOrderContext) KwClustering() IKwClusteringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwClusteringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwClusteringContext)
}

func (s *ClusteringOrderContext) KwOrder() IKwOrderContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwOrderContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwOrderContext)
}

func (s *ClusteringOrderContext) KwBy() IKwByContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwByContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwByContext)
}

func (s *ClusteringOrderContext) SyntaxBracketLr() ISyntaxBracketLrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxBracketLrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxBracketLrContext)
}

func (s *ClusteringOrderContext) SyntaxBracketRr() ISyntaxBracketRrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxBracketRrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxBracketRrContext)
}

func (s *ClusteringOrderContext) AllColumn() []IColumnContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnContext); ok {
			len++
		}
	}

	tst := make([]IColumnContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnContext); ok {
			tst[i] = t.(IColumnContext)
			i++
		}
	}

	return tst
}

func (s *ClusteringOrderContext) Column(i int) IColumnContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnContext)
}

func (s *ClusteringOrderContext) AllSyntaxComma() []ISyntaxCommaContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			len++
		}
	}

	tst := make([]ISyntaxCommaContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISyntaxCommaContext); ok {
			tst[i] = t.(ISyntaxCommaContext)
			i++
		}
	}

	return tst
}

func (s *ClusteringOrderContext) SyntaxComma(i int) ISyntaxCommaContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxCommaContext)
}

func (s *ClusteringOrderContext) AllOrderDirection() []IOrderDirectionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOrderDirectionContext); ok {
			len++
		}
	}

	tst := make([]IOrderDirectionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOrderDirectionContext); ok {
			tst[i] = t.(IOrderDirectionContext)
			i++
		}
	}

	return tst
}

func (s *ClusteringOrderContext) OrderDirection(i int) IOrderDirectionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderDirectionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderDirectionContext)
}

func (s *ClusteringOrderContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClusteringOrderContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClusteringOrderContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterClusteringOrder(s)
	}
}

func (s *ClusteringOrderContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitClusteringOrder(s)
	}
}

func (p *CqlParser) ClusteringOrder() (localctx IClusteringOrderContext) {
	localctx = NewClusteringOrderContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, CqlParserRULE_clusteringOrder)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1573)
		p.KwClustering()
	}
	{
		p.SetState(1574)
		p.KwOrder()
	}
	{
		p.SetState(1575)
		p.KwBy()
	}
	{
		p.SetState(1576)
		p.SyntaxBracketLr()
	}

	{
		p.SetState(1577)
		p.Column()
	}
	p.SetState(1579)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CqlParserK_ASC || _la == CqlParserK_DESC {
		{
			p.SetState(1578)
			p.OrderDirection()
		}

	}

	p.SetState(1588)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == CqlParserCOMMA {
		{
			p.SetState(1581)
			p.SyntaxComma()
		}
		{
			p.SetState(1582)
			p.Column()
		}
		p.SetState(1584)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == CqlParserK_ASC || _la == CqlParserK_DESC {
			{
				p.SetState(1583)
				p.OrderDirection()
			}

		}

		p.SetState(1590)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1591)
		p.SyntaxBracketRr()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableOptionItemContext is an interface to support dynamic dispatch.
type ITableOptionItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TableOptionName() ITableOptionNameContext
	OPERATOR_EQ() antlr.TerminalNode
	TableOptionValue() ITableOptionValueContext
	OptionHash() IOptionHashContext

	// IsTableOptionItemContext differentiates from other interfaces.
	IsTableOptionItemContext()
}

type TableOptionItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableOptionItemContext() *TableOptionItemContext {
	var p = new(TableOptionItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_tableOptionItem
	return p
}

func InitEmptyTableOptionItemContext(p *TableOptionItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_tableOptionItem
}

func (*TableOptionItemContext) IsTableOptionItemContext() {}

func NewTableOptionItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableOptionItemContext {
	var p = new(TableOptionItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_tableOptionItem

	return p
}

func (s *TableOptionItemContext) GetParser() antlr.Parser { return s.parser }

func (s *TableOptionItemContext) TableOptionName() ITableOptionNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableOptionNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableOptionNameContext)
}

func (s *TableOptionItemContext) OPERATOR_EQ() antlr.TerminalNode {
	return s.GetToken(CqlParserOPERATOR_EQ, 0)
}

func (s *TableOptionItemContext) TableOptionValue() ITableOptionValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableOptionValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableOptionValueContext)
}

func (s *TableOptionItemContext) OptionHash() IOptionHashContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOptionHashContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOptionHashContext)
}

func (s *TableOptionItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableOptionItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterTableOptionItem(s)
	}
}

func (s *TableOptionItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitTableOptionItem(s)
	}
}

func (p *CqlParser) TableOptionItem() (localctx ITableOptionItemContext) {
	localctx = NewTableOptionItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, CqlParserRULE_tableOptionItem)
	p.SetState(1601)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 104, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1593)
			p.TableOptionName()
		}
		{
			p.SetState(1594)
			p.Match(CqlParserOPERATOR_EQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1595)
			p.TableOptionValue()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1597)
			p.TableOptionName()
		}
		{
			p.SetState(1598)
			p.Match(CqlParserOPERATOR_EQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1599)
			p.OptionHash()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableOptionNameContext is an interface to support dynamic dispatch.
type ITableOptionNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OBJECT_NAME() antlr.TerminalNode

	// IsTableOptionNameContext differentiates from other interfaces.
	IsTableOptionNameContext()
}

type TableOptionNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableOptionNameContext() *TableOptionNameContext {
	var p = new(TableOptionNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_tableOptionName
	return p
}

func InitEmptyTableOptionNameContext(p *TableOptionNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_tableOptionName
}

func (*TableOptionNameContext) IsTableOptionNameContext() {}

func NewTableOptionNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableOptionNameContext {
	var p = new(TableOptionNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_tableOptionName

	return p
}

func (s *TableOptionNameContext) GetParser() antlr.Parser { return s.parser }

func (s *TableOptionNameContext) OBJECT_NAME() antlr.TerminalNode {
	return s.GetToken(CqlParserOBJECT_NAME, 0)
}

func (s *TableOptionNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableOptionNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterTableOptionName(s)
	}
}

func (s *TableOptionNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitTableOptionName(s)
	}
}

func (p *CqlParser) TableOptionName() (localctx ITableOptionNameContext) {
	localctx = NewTableOptionNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, CqlParserRULE_tableOptionName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1603)
		p.Match(CqlParserOBJECT_NAME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableOptionValueContext is an interface to support dynamic dispatch.
type ITableOptionValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	StringLiteral() IStringLiteralContext
	FloatLiteral() IFloatLiteralContext

	// IsTableOptionValueContext differentiates from other interfaces.
	IsTableOptionValueContext()
}

type TableOptionValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableOptionValueContext() *TableOptionValueContext {
	var p = new(TableOptionValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_tableOptionValue
	return p
}

func InitEmptyTableOptionValueContext(p *TableOptionValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_tableOptionValue
}

func (*TableOptionValueContext) IsTableOptionValueContext() {}

func NewTableOptionValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableOptionValueContext {
	var p = new(TableOptionValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_tableOptionValue

	return p
}

func (s *TableOptionValueContext) GetParser() antlr.Parser { return s.parser }

func (s *TableOptionValueContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *TableOptionValueContext) FloatLiteral() IFloatLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFloatLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFloatLiteralContext)
}

func (s *TableOptionValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableOptionValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterTableOptionValue(s)
	}
}

func (s *TableOptionValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitTableOptionValue(s)
	}
}

func (p *CqlParser) TableOptionValue() (localctx ITableOptionValueContext) {
	localctx = NewTableOptionValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, CqlParserRULE_tableOptionValue)
	p.SetState(1607)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case CqlParserSTRING_LITERAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1605)
			p.StringLiteral()
		}

	case CqlParserDECIMAL_LITERAL, CqlParserFLOAT_LITERAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1606)
			p.FloatLiteral()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOptionHashContext is an interface to support dynamic dispatch.
type IOptionHashContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SyntaxBracketLc() ISyntaxBracketLcContext
	AllOptionHashItem() []IOptionHashItemContext
	OptionHashItem(i int) IOptionHashItemContext
	SyntaxBracketRc() ISyntaxBracketRcContext
	AllSyntaxComma() []ISyntaxCommaContext
	SyntaxComma(i int) ISyntaxCommaContext

	// IsOptionHashContext differentiates from other interfaces.
	IsOptionHashContext()
}

type OptionHashContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOptionHashContext() *OptionHashContext {
	var p = new(OptionHashContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_optionHash
	return p
}

func InitEmptyOptionHashContext(p *OptionHashContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_optionHash
}

func (*OptionHashContext) IsOptionHashContext() {}

func NewOptionHashContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OptionHashContext {
	var p = new(OptionHashContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_optionHash

	return p
}

func (s *OptionHashContext) GetParser() antlr.Parser { return s.parser }

func (s *OptionHashContext) SyntaxBracketLc() ISyntaxBracketLcContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxBracketLcContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxBracketLcContext)
}

func (s *OptionHashContext) AllOptionHashItem() []IOptionHashItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOptionHashItemContext); ok {
			len++
		}
	}

	tst := make([]IOptionHashItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOptionHashItemContext); ok {
			tst[i] = t.(IOptionHashItemContext)
			i++
		}
	}

	return tst
}

func (s *OptionHashContext) OptionHashItem(i int) IOptionHashItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOptionHashItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOptionHashItemContext)
}

func (s *OptionHashContext) SyntaxBracketRc() ISyntaxBracketRcContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxBracketRcContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxBracketRcContext)
}

func (s *OptionHashContext) AllSyntaxComma() []ISyntaxCommaContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			len++
		}
	}

	tst := make([]ISyntaxCommaContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISyntaxCommaContext); ok {
			tst[i] = t.(ISyntaxCommaContext)
			i++
		}
	}

	return tst
}

func (s *OptionHashContext) SyntaxComma(i int) ISyntaxCommaContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxCommaContext)
}

func (s *OptionHashContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OptionHashContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OptionHashContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterOptionHash(s)
	}
}

func (s *OptionHashContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitOptionHash(s)
	}
}

func (p *CqlParser) OptionHash() (localctx IOptionHashContext) {
	localctx = NewOptionHashContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, CqlParserRULE_optionHash)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1609)
		p.SyntaxBracketLc()
	}
	{
		p.SetState(1610)
		p.OptionHashItem()
	}
	p.SetState(1616)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == CqlParserCOMMA {
		{
			p.SetState(1611)
			p.SyntaxComma()
		}
		{
			p.SetState(1612)
			p.OptionHashItem()
		}

		p.SetState(1618)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1619)
		p.SyntaxBracketRc()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOptionHashItemContext is an interface to support dynamic dispatch.
type IOptionHashItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OptionHashKey() IOptionHashKeyContext
	COLON() antlr.TerminalNode
	OptionHashValue() IOptionHashValueContext

	// IsOptionHashItemContext differentiates from other interfaces.
	IsOptionHashItemContext()
}

type OptionHashItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOptionHashItemContext() *OptionHashItemContext {
	var p = new(OptionHashItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_optionHashItem
	return p
}

func InitEmptyOptionHashItemContext(p *OptionHashItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_optionHashItem
}

func (*OptionHashItemContext) IsOptionHashItemContext() {}

func NewOptionHashItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OptionHashItemContext {
	var p = new(OptionHashItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_optionHashItem

	return p
}

func (s *OptionHashItemContext) GetParser() antlr.Parser { return s.parser }

func (s *OptionHashItemContext) OptionHashKey() IOptionHashKeyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOptionHashKeyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOptionHashKeyContext)
}

func (s *OptionHashItemContext) COLON() antlr.TerminalNode {
	return s.GetToken(CqlParserCOLON, 0)
}

func (s *OptionHashItemContext) OptionHashValue() IOptionHashValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOptionHashValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOptionHashValueContext)
}

func (s *OptionHashItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OptionHashItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OptionHashItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterOptionHashItem(s)
	}
}

func (s *OptionHashItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitOptionHashItem(s)
	}
}

func (p *CqlParser) OptionHashItem() (localctx IOptionHashItemContext) {
	localctx = NewOptionHashItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, CqlParserRULE_optionHashItem)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1621)
		p.OptionHashKey()
	}
	{
		p.SetState(1622)
		p.Match(CqlParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1623)
		p.OptionHashValue()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOptionHashKeyContext is an interface to support dynamic dispatch.
type IOptionHashKeyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	StringLiteral() IStringLiteralContext

	// IsOptionHashKeyContext differentiates from other interfaces.
	IsOptionHashKeyContext()
}

type OptionHashKeyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOptionHashKeyContext() *OptionHashKeyContext {
	var p = new(OptionHashKeyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_optionHashKey
	return p
}

func InitEmptyOptionHashKeyContext(p *OptionHashKeyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_optionHashKey
}

func (*OptionHashKeyContext) IsOptionHashKeyContext() {}

func NewOptionHashKeyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OptionHashKeyContext {
	var p = new(OptionHashKeyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_optionHashKey

	return p
}

func (s *OptionHashKeyContext) GetParser() antlr.Parser { return s.parser }

func (s *OptionHashKeyContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *OptionHashKeyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OptionHashKeyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OptionHashKeyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterOptionHashKey(s)
	}
}

func (s *OptionHashKeyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitOptionHashKey(s)
	}
}

func (p *CqlParser) OptionHashKey() (localctx IOptionHashKeyContext) {
	localctx = NewOptionHashKeyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, CqlParserRULE_optionHashKey)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1625)
		p.StringLiteral()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOptionHashValueContext is an interface to support dynamic dispatch.
type IOptionHashValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	StringLiteral() IStringLiteralContext
	FloatLiteral() IFloatLiteralContext
	BooleanLiteral() IBooleanLiteralContext
	DecimalLiteral() IDecimalLiteralContext

	// IsOptionHashValueContext differentiates from other interfaces.
	IsOptionHashValueContext()
}

type OptionHashValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOptionHashValueContext() *OptionHashValueContext {
	var p = new(OptionHashValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_optionHashValue
	return p
}

func InitEmptyOptionHashValueContext(p *OptionHashValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_optionHashValue
}

func (*OptionHashValueContext) IsOptionHashValueContext() {}

func NewOptionHashValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OptionHashValueContext {
	var p = new(OptionHashValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_optionHashValue

	return p
}

func (s *OptionHashValueContext) GetParser() antlr.Parser { return s.parser }

func (s *OptionHashValueContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *OptionHashValueContext) FloatLiteral() IFloatLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFloatLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFloatLiteralContext)
}

func (s *OptionHashValueContext) BooleanLiteral() IBooleanLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanLiteralContext)
}

func (s *OptionHashValueContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *OptionHashValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OptionHashValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OptionHashValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterOptionHashValue(s)
	}
}

func (s *OptionHashValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitOptionHashValue(s)
	}
}

func (p *CqlParser) OptionHashValue() (localctx IOptionHashValueContext) {
	localctx = NewOptionHashValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, CqlParserRULE_optionHashValue)
	p.SetState(1631)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 107, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1627)
			p.StringLiteral()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1628)
			p.FloatLiteral()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1629)
			p.BooleanLiteral()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1630)
			p.DecimalLiteral()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnDefinitionListContext is an interface to support dynamic dispatch.
type IColumnDefinitionListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllColumnDefinition() []IColumnDefinitionContext
	ColumnDefinition(i int) IColumnDefinitionContext
	AllSyntaxComma() []ISyntaxCommaContext
	SyntaxComma(i int) ISyntaxCommaContext
	PrimaryKeyElement() IPrimaryKeyElementContext

	// IsColumnDefinitionListContext differentiates from other interfaces.
	IsColumnDefinitionListContext()
}

type ColumnDefinitionListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnDefinitionListContext() *ColumnDefinitionListContext {
	var p = new(ColumnDefinitionListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_columnDefinitionList
	return p
}

func InitEmptyColumnDefinitionListContext(p *ColumnDefinitionListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_columnDefinitionList
}

func (*ColumnDefinitionListContext) IsColumnDefinitionListContext() {}

func NewColumnDefinitionListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnDefinitionListContext {
	var p = new(ColumnDefinitionListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_columnDefinitionList

	return p
}

func (s *ColumnDefinitionListContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnDefinitionListContext) AllColumnDefinition() []IColumnDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnDefinitionContext); ok {
			len++
		}
	}

	tst := make([]IColumnDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnDefinitionContext); ok {
			tst[i] = t.(IColumnDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *ColumnDefinitionListContext) ColumnDefinition(i int) IColumnDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnDefinitionContext)
}

func (s *ColumnDefinitionListContext) AllSyntaxComma() []ISyntaxCommaContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			len++
		}
	}

	tst := make([]ISyntaxCommaContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISyntaxCommaContext); ok {
			tst[i] = t.(ISyntaxCommaContext)
			i++
		}
	}

	return tst
}

func (s *ColumnDefinitionListContext) SyntaxComma(i int) ISyntaxCommaContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxCommaContext)
}

func (s *ColumnDefinitionListContext) PrimaryKeyElement() IPrimaryKeyElementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryKeyElementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryKeyElementContext)
}

func (s *ColumnDefinitionListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnDefinitionListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnDefinitionListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterColumnDefinitionList(s)
	}
}

func (s *ColumnDefinitionListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitColumnDefinitionList(s)
	}
}

func (p *CqlParser) ColumnDefinitionList() (localctx IColumnDefinitionListContext) {
	localctx = NewColumnDefinitionListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, CqlParserRULE_columnDefinitionList)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1633)
		p.ColumnDefinition()
	}

	p.SetState(1639)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 108, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1634)
				p.SyntaxComma()
			}
			{
				p.SetState(1635)
				p.ColumnDefinition()
			}

		}
		p.SetState(1641)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 108, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1645)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CqlParserCOMMA {
		{
			p.SetState(1642)
			p.SyntaxComma()
		}
		{
			p.SetState(1643)
			p.PrimaryKeyElement()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnDefinitionContext is an interface to support dynamic dispatch.
type IColumnDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Column() IColumnContext
	DataType() IDataTypeContext
	StaticColumn() IStaticColumnContext
	PrimaryKeyColumn() IPrimaryKeyColumnContext

	// IsColumnDefinitionContext differentiates from other interfaces.
	IsColumnDefinitionContext()
}

type ColumnDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnDefinitionContext() *ColumnDefinitionContext {
	var p = new(ColumnDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_columnDefinition
	return p
}

func InitEmptyColumnDefinitionContext(p *ColumnDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_columnDefinition
}

func (*ColumnDefinitionContext) IsColumnDefinitionContext() {}

func NewColumnDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnDefinitionContext {
	var p = new(ColumnDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_columnDefinition

	return p
}

func (s *ColumnDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnDefinitionContext) Column() IColumnContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnContext)
}

func (s *ColumnDefinitionContext) DataType() IDataTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *ColumnDefinitionContext) StaticColumn() IStaticColumnContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStaticColumnContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStaticColumnContext)
}

func (s *ColumnDefinitionContext) PrimaryKeyColumn() IPrimaryKeyColumnContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryKeyColumnContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryKeyColumnContext)
}

func (s *ColumnDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterColumnDefinition(s)
	}
}

func (s *ColumnDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitColumnDefinition(s)
	}
}

func (p *CqlParser) ColumnDefinition() (localctx IColumnDefinitionContext) {
	localctx = NewColumnDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, CqlParserRULE_columnDefinition)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1647)
		p.Column()
	}
	{
		p.SetState(1648)
		p.DataType()
	}
	p.SetState(1650)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CqlParserK_STATIC {
		{
			p.SetState(1649)
			p.StaticColumn()
		}

	}
	p.SetState(1653)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CqlParserK_PRIMARY {
		{
			p.SetState(1652)
			p.PrimaryKeyColumn()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrimaryKeyColumnContext is an interface to support dynamic dispatch.
type IPrimaryKeyColumnContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwPrimary() IKwPrimaryContext
	KwKey() IKwKeyContext

	// IsPrimaryKeyColumnContext differentiates from other interfaces.
	IsPrimaryKeyColumnContext()
}

type PrimaryKeyColumnContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimaryKeyColumnContext() *PrimaryKeyColumnContext {
	var p = new(PrimaryKeyColumnContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_primaryKeyColumn
	return p
}

func InitEmptyPrimaryKeyColumnContext(p *PrimaryKeyColumnContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_primaryKeyColumn
}

func (*PrimaryKeyColumnContext) IsPrimaryKeyColumnContext() {}

func NewPrimaryKeyColumnContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimaryKeyColumnContext {
	var p = new(PrimaryKeyColumnContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_primaryKeyColumn

	return p
}

func (s *PrimaryKeyColumnContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimaryKeyColumnContext) KwPrimary() IKwPrimaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwPrimaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwPrimaryContext)
}

func (s *PrimaryKeyColumnContext) KwKey() IKwKeyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwKeyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwKeyContext)
}

func (s *PrimaryKeyColumnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryKeyColumnContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrimaryKeyColumnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterPrimaryKeyColumn(s)
	}
}

func (s *PrimaryKeyColumnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitPrimaryKeyColumn(s)
	}
}

func (p *CqlParser) PrimaryKeyColumn() (localctx IPrimaryKeyColumnContext) {
	localctx = NewPrimaryKeyColumnContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, CqlParserRULE_primaryKeyColumn)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1655)
		p.KwPrimary()
	}
	{
		p.SetState(1656)
		p.KwKey()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStaticColumnContext is an interface to support dynamic dispatch.
type IStaticColumnContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwStatic() IKwStaticContext

	// IsStaticColumnContext differentiates from other interfaces.
	IsStaticColumnContext()
}

type StaticColumnContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStaticColumnContext() *StaticColumnContext {
	var p = new(StaticColumnContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_staticColumn
	return p
}

func InitEmptyStaticColumnContext(p *StaticColumnContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_staticColumn
}

func (*StaticColumnContext) IsStaticColumnContext() {}

func NewStaticColumnContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StaticColumnContext {
	var p = new(StaticColumnContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_staticColumn

	return p
}

func (s *StaticColumnContext) GetParser() antlr.Parser { return s.parser }

func (s *StaticColumnContext) KwStatic() IKwStaticContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwStaticContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwStaticContext)
}

func (s *StaticColumnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StaticColumnContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StaticColumnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterStaticColumn(s)
	}
}

func (s *StaticColumnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitStaticColumn(s)
	}
}

func (p *CqlParser) StaticColumn() (localctx IStaticColumnContext) {
	localctx = NewStaticColumnContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, CqlParserRULE_staticColumn)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1658)
		p.KwStatic()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrimaryKeyElementContext is an interface to support dynamic dispatch.
type IPrimaryKeyElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwPrimary() IKwPrimaryContext
	KwKey() IKwKeyContext
	SyntaxBracketLr() ISyntaxBracketLrContext
	PrimaryKeyDefinition() IPrimaryKeyDefinitionContext
	SyntaxBracketRr() ISyntaxBracketRrContext

	// IsPrimaryKeyElementContext differentiates from other interfaces.
	IsPrimaryKeyElementContext()
}

type PrimaryKeyElementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimaryKeyElementContext() *PrimaryKeyElementContext {
	var p = new(PrimaryKeyElementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_primaryKeyElement
	return p
}

func InitEmptyPrimaryKeyElementContext(p *PrimaryKeyElementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_primaryKeyElement
}

func (*PrimaryKeyElementContext) IsPrimaryKeyElementContext() {}

func NewPrimaryKeyElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimaryKeyElementContext {
	var p = new(PrimaryKeyElementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_primaryKeyElement

	return p
}

func (s *PrimaryKeyElementContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimaryKeyElementContext) KwPrimary() IKwPrimaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwPrimaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwPrimaryContext)
}

func (s *PrimaryKeyElementContext) KwKey() IKwKeyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwKeyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwKeyContext)
}

func (s *PrimaryKeyElementContext) SyntaxBracketLr() ISyntaxBracketLrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxBracketLrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxBracketLrContext)
}

func (s *PrimaryKeyElementContext) PrimaryKeyDefinition() IPrimaryKeyDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryKeyDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryKeyDefinitionContext)
}

func (s *PrimaryKeyElementContext) SyntaxBracketRr() ISyntaxBracketRrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxBracketRrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxBracketRrContext)
}

func (s *PrimaryKeyElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryKeyElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrimaryKeyElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterPrimaryKeyElement(s)
	}
}

func (s *PrimaryKeyElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitPrimaryKeyElement(s)
	}
}

func (p *CqlParser) PrimaryKeyElement() (localctx IPrimaryKeyElementContext) {
	localctx = NewPrimaryKeyElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, CqlParserRULE_primaryKeyElement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1660)
		p.KwPrimary()
	}
	{
		p.SetState(1661)
		p.KwKey()
	}
	{
		p.SetState(1662)
		p.SyntaxBracketLr()
	}
	{
		p.SetState(1663)
		p.PrimaryKeyDefinition()
	}
	{
		p.SetState(1664)
		p.SyntaxBracketRr()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrimaryKeyDefinitionContext is an interface to support dynamic dispatch.
type IPrimaryKeyDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SinglePrimaryKey() ISinglePrimaryKeyContext
	CompoundKey() ICompoundKeyContext
	CompositeKey() ICompositeKeyContext

	// IsPrimaryKeyDefinitionContext differentiates from other interfaces.
	IsPrimaryKeyDefinitionContext()
}

type PrimaryKeyDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimaryKeyDefinitionContext() *PrimaryKeyDefinitionContext {
	var p = new(PrimaryKeyDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_primaryKeyDefinition
	return p
}

func InitEmptyPrimaryKeyDefinitionContext(p *PrimaryKeyDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_primaryKeyDefinition
}

func (*PrimaryKeyDefinitionContext) IsPrimaryKeyDefinitionContext() {}

func NewPrimaryKeyDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimaryKeyDefinitionContext {
	var p = new(PrimaryKeyDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_primaryKeyDefinition

	return p
}

func (s *PrimaryKeyDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimaryKeyDefinitionContext) SinglePrimaryKey() ISinglePrimaryKeyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISinglePrimaryKeyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISinglePrimaryKeyContext)
}

func (s *PrimaryKeyDefinitionContext) CompoundKey() ICompoundKeyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompoundKeyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompoundKeyContext)
}

func (s *PrimaryKeyDefinitionContext) CompositeKey() ICompositeKeyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompositeKeyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompositeKeyContext)
}

func (s *PrimaryKeyDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryKeyDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrimaryKeyDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterPrimaryKeyDefinition(s)
	}
}

func (s *PrimaryKeyDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitPrimaryKeyDefinition(s)
	}
}

func (p *CqlParser) PrimaryKeyDefinition() (localctx IPrimaryKeyDefinitionContext) {
	localctx = NewPrimaryKeyDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, CqlParserRULE_primaryKeyDefinition)
	p.SetState(1669)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 112, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1666)
			p.SinglePrimaryKey()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1667)
			p.CompoundKey()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1668)
			p.CompositeKey()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISinglePrimaryKeyContext is an interface to support dynamic dispatch.
type ISinglePrimaryKeyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Column() IColumnContext

	// IsSinglePrimaryKeyContext differentiates from other interfaces.
	IsSinglePrimaryKeyContext()
}

type SinglePrimaryKeyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySinglePrimaryKeyContext() *SinglePrimaryKeyContext {
	var p = new(SinglePrimaryKeyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_singlePrimaryKey
	return p
}

func InitEmptySinglePrimaryKeyContext(p *SinglePrimaryKeyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_singlePrimaryKey
}

func (*SinglePrimaryKeyContext) IsSinglePrimaryKeyContext() {}

func NewSinglePrimaryKeyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SinglePrimaryKeyContext {
	var p = new(SinglePrimaryKeyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_singlePrimaryKey

	return p
}

func (s *SinglePrimaryKeyContext) GetParser() antlr.Parser { return s.parser }

func (s *SinglePrimaryKeyContext) Column() IColumnContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnContext)
}

func (s *SinglePrimaryKeyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SinglePrimaryKeyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SinglePrimaryKeyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterSinglePrimaryKey(s)
	}
}

func (s *SinglePrimaryKeyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitSinglePrimaryKey(s)
	}
}

func (p *CqlParser) SinglePrimaryKey() (localctx ISinglePrimaryKeyContext) {
	localctx = NewSinglePrimaryKeyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, CqlParserRULE_singlePrimaryKey)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1671)
		p.Column()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICompoundKeyContext is an interface to support dynamic dispatch.
type ICompoundKeyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PartitionKey() IPartitionKeyContext
	SyntaxComma() ISyntaxCommaContext
	ClusteringKeyList() IClusteringKeyListContext

	// IsCompoundKeyContext differentiates from other interfaces.
	IsCompoundKeyContext()
}

type CompoundKeyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCompoundKeyContext() *CompoundKeyContext {
	var p = new(CompoundKeyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_compoundKey
	return p
}

func InitEmptyCompoundKeyContext(p *CompoundKeyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_compoundKey
}

func (*CompoundKeyContext) IsCompoundKeyContext() {}

func NewCompoundKeyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CompoundKeyContext {
	var p = new(CompoundKeyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_compoundKey

	return p
}

func (s *CompoundKeyContext) GetParser() antlr.Parser { return s.parser }

func (s *CompoundKeyContext) PartitionKey() IPartitionKeyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionKeyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionKeyContext)
}

func (s *CompoundKeyContext) SyntaxComma() ISyntaxCommaContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxCommaContext)
}

func (s *CompoundKeyContext) ClusteringKeyList() IClusteringKeyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClusteringKeyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClusteringKeyListContext)
}

func (s *CompoundKeyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CompoundKeyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CompoundKeyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterCompoundKey(s)
	}
}

func (s *CompoundKeyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitCompoundKey(s)
	}
}

func (p *CqlParser) CompoundKey() (localctx ICompoundKeyContext) {
	localctx = NewCompoundKeyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, CqlParserRULE_compoundKey)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1673)
		p.PartitionKey()
	}

	{
		p.SetState(1674)
		p.SyntaxComma()
	}
	{
		p.SetState(1675)
		p.ClusteringKeyList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICompositeKeyContext is an interface to support dynamic dispatch.
type ICompositeKeyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SyntaxBracketLr() ISyntaxBracketLrContext
	PartitionKeyList() IPartitionKeyListContext
	SyntaxBracketRr() ISyntaxBracketRrContext
	SyntaxComma() ISyntaxCommaContext
	ClusteringKeyList() IClusteringKeyListContext

	// IsCompositeKeyContext differentiates from other interfaces.
	IsCompositeKeyContext()
}

type CompositeKeyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCompositeKeyContext() *CompositeKeyContext {
	var p = new(CompositeKeyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_compositeKey
	return p
}

func InitEmptyCompositeKeyContext(p *CompositeKeyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_compositeKey
}

func (*CompositeKeyContext) IsCompositeKeyContext() {}

func NewCompositeKeyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CompositeKeyContext {
	var p = new(CompositeKeyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_compositeKey

	return p
}

func (s *CompositeKeyContext) GetParser() antlr.Parser { return s.parser }

func (s *CompositeKeyContext) SyntaxBracketLr() ISyntaxBracketLrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxBracketLrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxBracketLrContext)
}

func (s *CompositeKeyContext) PartitionKeyList() IPartitionKeyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionKeyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionKeyListContext)
}

func (s *CompositeKeyContext) SyntaxBracketRr() ISyntaxBracketRrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxBracketRrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxBracketRrContext)
}

func (s *CompositeKeyContext) SyntaxComma() ISyntaxCommaContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxCommaContext)
}

func (s *CompositeKeyContext) ClusteringKeyList() IClusteringKeyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClusteringKeyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClusteringKeyListContext)
}

func (s *CompositeKeyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CompositeKeyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CompositeKeyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterCompositeKey(s)
	}
}

func (s *CompositeKeyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitCompositeKey(s)
	}
}

func (p *CqlParser) CompositeKey() (localctx ICompositeKeyContext) {
	localctx = NewCompositeKeyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, CqlParserRULE_compositeKey)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1677)
		p.SyntaxBracketLr()
	}
	{
		p.SetState(1678)
		p.PartitionKeyList()
	}
	{
		p.SetState(1679)
		p.SyntaxBracketRr()
	}

	{
		p.SetState(1680)
		p.SyntaxComma()
	}
	{
		p.SetState(1681)
		p.ClusteringKeyList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionKeyListContext is an interface to support dynamic dispatch.
type IPartitionKeyListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllPartitionKey() []IPartitionKeyContext
	PartitionKey(i int) IPartitionKeyContext
	AllSyntaxComma() []ISyntaxCommaContext
	SyntaxComma(i int) ISyntaxCommaContext

	// IsPartitionKeyListContext differentiates from other interfaces.
	IsPartitionKeyListContext()
}

type PartitionKeyListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionKeyListContext() *PartitionKeyListContext {
	var p = new(PartitionKeyListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_partitionKeyList
	return p
}

func InitEmptyPartitionKeyListContext(p *PartitionKeyListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_partitionKeyList
}

func (*PartitionKeyListContext) IsPartitionKeyListContext() {}

func NewPartitionKeyListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionKeyListContext {
	var p = new(PartitionKeyListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_partitionKeyList

	return p
}

func (s *PartitionKeyListContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionKeyListContext) AllPartitionKey() []IPartitionKeyContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionKeyContext); ok {
			len++
		}
	}

	tst := make([]IPartitionKeyContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionKeyContext); ok {
			tst[i] = t.(IPartitionKeyContext)
			i++
		}
	}

	return tst
}

func (s *PartitionKeyListContext) PartitionKey(i int) IPartitionKeyContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionKeyContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionKeyContext)
}

func (s *PartitionKeyListContext) AllSyntaxComma() []ISyntaxCommaContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			len++
		}
	}

	tst := make([]ISyntaxCommaContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISyntaxCommaContext); ok {
			tst[i] = t.(ISyntaxCommaContext)
			i++
		}
	}

	return tst
}

func (s *PartitionKeyListContext) SyntaxComma(i int) ISyntaxCommaContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxCommaContext)
}

func (s *PartitionKeyListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionKeyListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionKeyListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterPartitionKeyList(s)
	}
}

func (s *PartitionKeyListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitPartitionKeyList(s)
	}
}

func (p *CqlParser) PartitionKeyList() (localctx IPartitionKeyListContext) {
	localctx = NewPartitionKeyListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, CqlParserRULE_partitionKeyList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1683)
		p.PartitionKey()
	}

	p.SetState(1689)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == CqlParserCOMMA {
		{
			p.SetState(1684)
			p.SyntaxComma()
		}
		{
			p.SetState(1685)
			p.PartitionKey()
		}

		p.SetState(1691)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClusteringKeyListContext is an interface to support dynamic dispatch.
type IClusteringKeyListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllClusteringKey() []IClusteringKeyContext
	ClusteringKey(i int) IClusteringKeyContext
	AllSyntaxComma() []ISyntaxCommaContext
	SyntaxComma(i int) ISyntaxCommaContext

	// IsClusteringKeyListContext differentiates from other interfaces.
	IsClusteringKeyListContext()
}

type ClusteringKeyListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClusteringKeyListContext() *ClusteringKeyListContext {
	var p = new(ClusteringKeyListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_clusteringKeyList
	return p
}

func InitEmptyClusteringKeyListContext(p *ClusteringKeyListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_clusteringKeyList
}

func (*ClusteringKeyListContext) IsClusteringKeyListContext() {}

func NewClusteringKeyListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClusteringKeyListContext {
	var p = new(ClusteringKeyListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_clusteringKeyList

	return p
}

func (s *ClusteringKeyListContext) GetParser() antlr.Parser { return s.parser }

func (s *ClusteringKeyListContext) AllClusteringKey() []IClusteringKeyContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IClusteringKeyContext); ok {
			len++
		}
	}

	tst := make([]IClusteringKeyContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IClusteringKeyContext); ok {
			tst[i] = t.(IClusteringKeyContext)
			i++
		}
	}

	return tst
}

func (s *ClusteringKeyListContext) ClusteringKey(i int) IClusteringKeyContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClusteringKeyContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClusteringKeyContext)
}

func (s *ClusteringKeyListContext) AllSyntaxComma() []ISyntaxCommaContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			len++
		}
	}

	tst := make([]ISyntaxCommaContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISyntaxCommaContext); ok {
			tst[i] = t.(ISyntaxCommaContext)
			i++
		}
	}

	return tst
}

func (s *ClusteringKeyListContext) SyntaxComma(i int) ISyntaxCommaContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxCommaContext)
}

func (s *ClusteringKeyListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClusteringKeyListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClusteringKeyListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterClusteringKeyList(s)
	}
}

func (s *ClusteringKeyListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitClusteringKeyList(s)
	}
}

func (p *CqlParser) ClusteringKeyList() (localctx IClusteringKeyListContext) {
	localctx = NewClusteringKeyListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, CqlParserRULE_clusteringKeyList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1692)
		p.ClusteringKey()
	}

	p.SetState(1698)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == CqlParserCOMMA {
		{
			p.SetState(1693)
			p.SyntaxComma()
		}
		{
			p.SetState(1694)
			p.ClusteringKey()
		}

		p.SetState(1700)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionKeyContext is an interface to support dynamic dispatch.
type IPartitionKeyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Column() IColumnContext

	// IsPartitionKeyContext differentiates from other interfaces.
	IsPartitionKeyContext()
}

type PartitionKeyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionKeyContext() *PartitionKeyContext {
	var p = new(PartitionKeyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_partitionKey
	return p
}

func InitEmptyPartitionKeyContext(p *PartitionKeyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_partitionKey
}

func (*PartitionKeyContext) IsPartitionKeyContext() {}

func NewPartitionKeyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionKeyContext {
	var p = new(PartitionKeyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_partitionKey

	return p
}

func (s *PartitionKeyContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionKeyContext) Column() IColumnContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnContext)
}

func (s *PartitionKeyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionKeyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionKeyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterPartitionKey(s)
	}
}

func (s *PartitionKeyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitPartitionKey(s)
	}
}

func (p *CqlParser) PartitionKey() (localctx IPartitionKeyContext) {
	localctx = NewPartitionKeyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, CqlParserRULE_partitionKey)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1701)
		p.Column()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClusteringKeyContext is an interface to support dynamic dispatch.
type IClusteringKeyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Column() IColumnContext

	// IsClusteringKeyContext differentiates from other interfaces.
	IsClusteringKeyContext()
}

type ClusteringKeyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClusteringKeyContext() *ClusteringKeyContext {
	var p = new(ClusteringKeyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_clusteringKey
	return p
}

func InitEmptyClusteringKeyContext(p *ClusteringKeyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_clusteringKey
}

func (*ClusteringKeyContext) IsClusteringKeyContext() {}

func NewClusteringKeyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClusteringKeyContext {
	var p = new(ClusteringKeyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_clusteringKey

	return p
}

func (s *ClusteringKeyContext) GetParser() antlr.Parser { return s.parser }

func (s *ClusteringKeyContext) Column() IColumnContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnContext)
}

func (s *ClusteringKeyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClusteringKeyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClusteringKeyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterClusteringKey(s)
	}
}

func (s *ClusteringKeyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitClusteringKey(s)
	}
}

func (p *CqlParser) ClusteringKey() (localctx IClusteringKeyContext) {
	localctx = NewClusteringKeyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, CqlParserRULE_clusteringKey)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1703)
		p.Column()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IApplyBatchContext is an interface to support dynamic dispatch.
type IApplyBatchContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwApply() IKwApplyContext
	KwBatch() IKwBatchContext

	// IsApplyBatchContext differentiates from other interfaces.
	IsApplyBatchContext()
}

type ApplyBatchContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyApplyBatchContext() *ApplyBatchContext {
	var p = new(ApplyBatchContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_applyBatch
	return p
}

func InitEmptyApplyBatchContext(p *ApplyBatchContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_applyBatch
}

func (*ApplyBatchContext) IsApplyBatchContext() {}

func NewApplyBatchContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ApplyBatchContext {
	var p = new(ApplyBatchContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_applyBatch

	return p
}

func (s *ApplyBatchContext) GetParser() antlr.Parser { return s.parser }

func (s *ApplyBatchContext) KwApply() IKwApplyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwApplyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwApplyContext)
}

func (s *ApplyBatchContext) KwBatch() IKwBatchContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwBatchContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwBatchContext)
}

func (s *ApplyBatchContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ApplyBatchContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ApplyBatchContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterApplyBatch(s)
	}
}

func (s *ApplyBatchContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitApplyBatch(s)
	}
}

func (p *CqlParser) ApplyBatch() (localctx IApplyBatchContext) {
	localctx = NewApplyBatchContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, CqlParserRULE_applyBatch)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1705)
		p.KwApply()
	}
	{
		p.SetState(1706)
		p.KwBatch()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBatchContext is an interface to support dynamic dispatch.
type IBatchContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwBegin() IKwBeginContext
	AllKwBatch() []IKwBatchContext
	KwBatch(i int) IKwBatchContext
	KwApply() IKwApplyContext
	BatchType() IBatchTypeContext
	UsingTimestampSpec() IUsingTimestampSpecContext
	BatchStatementList() IBatchStatementListContext

	// IsBatchContext differentiates from other interfaces.
	IsBatchContext()
}

type BatchContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBatchContext() *BatchContext {
	var p = new(BatchContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_batch
	return p
}

func InitEmptyBatchContext(p *BatchContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_batch
}

func (*BatchContext) IsBatchContext() {}

func NewBatchContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BatchContext {
	var p = new(BatchContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_batch

	return p
}

func (s *BatchContext) GetParser() antlr.Parser { return s.parser }

func (s *BatchContext) KwBegin() IKwBeginContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwBeginContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwBeginContext)
}

func (s *BatchContext) AllKwBatch() []IKwBatchContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IKwBatchContext); ok {
			len++
		}
	}

	tst := make([]IKwBatchContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IKwBatchContext); ok {
			tst[i] = t.(IKwBatchContext)
			i++
		}
	}

	return tst
}

func (s *BatchContext) KwBatch(i int) IKwBatchContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwBatchContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwBatchContext)
}

func (s *BatchContext) KwApply() IKwApplyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwApplyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwApplyContext)
}

func (s *BatchContext) BatchType() IBatchTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBatchTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBatchTypeContext)
}

func (s *BatchContext) UsingTimestampSpec() IUsingTimestampSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUsingTimestampSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUsingTimestampSpecContext)
}

func (s *BatchContext) BatchStatementList() IBatchStatementListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBatchStatementListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBatchStatementListContext)
}

func (s *BatchContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BatchContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BatchContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterBatch(s)
	}
}

func (s *BatchContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitBatch(s)
	}
}

func (p *CqlParser) Batch() (localctx IBatchContext) {
	localctx = NewBatchContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, CqlParserRULE_batch)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1708)
		p.KwBegin()
	}
	p.SetState(1710)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-83)) & ^0x3f) == 0 && ((int64(1)<<(_la-83))&-9223090561878065151) != 0 {
		{
			p.SetState(1709)
			p.BatchType()
		}

	}
	{
		p.SetState(1712)
		p.KwBatch()
	}
	p.SetState(1714)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CqlParserK_USING {
		{
			p.SetState(1713)
			p.UsingTimestampSpec()
		}

	}
	p.SetState(1717)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CqlParserK_DELETE || _la == CqlParserK_INSERT || _la == CqlParserK_UPDATE {
		{
			p.SetState(1716)
			p.BatchStatementList()
		}

	}
	{
		p.SetState(1719)
		p.KwApply()
	}
	{
		p.SetState(1720)
		p.KwBatch()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBatchStatementListContext is an interface to support dynamic dispatch.
type IBatchStatementListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllBatchStatement() []IBatchStatementContext
	BatchStatement(i int) IBatchStatementContext

	// IsBatchStatementListContext differentiates from other interfaces.
	IsBatchStatementListContext()
}

type BatchStatementListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBatchStatementListContext() *BatchStatementListContext {
	var p = new(BatchStatementListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_batchStatementList
	return p
}

func InitEmptyBatchStatementListContext(p *BatchStatementListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_batchStatementList
}

func (*BatchStatementListContext) IsBatchStatementListContext() {}

func NewBatchStatementListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BatchStatementListContext {
	var p = new(BatchStatementListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_batchStatementList

	return p
}

func (s *BatchStatementListContext) GetParser() antlr.Parser { return s.parser }

func (s *BatchStatementListContext) AllBatchStatement() []IBatchStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBatchStatementContext); ok {
			len++
		}
	}

	tst := make([]IBatchStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBatchStatementContext); ok {
			tst[i] = t.(IBatchStatementContext)
			i++
		}
	}

	return tst
}

func (s *BatchStatementListContext) BatchStatement(i int) IBatchStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBatchStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBatchStatementContext)
}

func (s *BatchStatementListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BatchStatementListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BatchStatementListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterBatchStatementList(s)
	}
}

func (s *BatchStatementListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitBatchStatementList(s)
	}
}

func (p *CqlParser) BatchStatementList() (localctx IBatchStatementListContext) {
	localctx = NewBatchStatementListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, CqlParserRULE_batchStatementList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1723)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == CqlParserK_DELETE || _la == CqlParserK_INSERT || _la == CqlParserK_UPDATE {
		{
			p.SetState(1722)
			p.BatchStatement()
		}

		p.SetState(1725)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBatchStatementContext is an interface to support dynamic dispatch.
type IBatchStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BatchInsert() IBatchInsertContext
	BatchUpdate() IBatchUpdateContext
	BatchDelete() IBatchDeleteContext

	// IsBatchStatementContext differentiates from other interfaces.
	IsBatchStatementContext()
}

type BatchStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBatchStatementContext() *BatchStatementContext {
	var p = new(BatchStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_batchStatement
	return p
}

func InitEmptyBatchStatementContext(p *BatchStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_batchStatement
}

func (*BatchStatementContext) IsBatchStatementContext() {}

func NewBatchStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BatchStatementContext {
	var p = new(BatchStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_batchStatement

	return p
}

func (s *BatchStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *BatchStatementContext) BatchInsert() IBatchInsertContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBatchInsertContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBatchInsertContext)
}

func (s *BatchStatementContext) BatchUpdate() IBatchUpdateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBatchUpdateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBatchUpdateContext)
}

func (s *BatchStatementContext) BatchDelete() IBatchDeleteContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBatchDeleteContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBatchDeleteContext)
}

func (s *BatchStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BatchStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BatchStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterBatchStatement(s)
	}
}

func (s *BatchStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitBatchStatement(s)
	}
}

func (p *CqlParser) BatchStatement() (localctx IBatchStatementContext) {
	localctx = NewBatchStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, CqlParserRULE_batchStatement)
	p.SetState(1730)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case CqlParserK_INSERT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1727)
			p.BatchInsert()
		}

	case CqlParserK_UPDATE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1728)
			p.BatchUpdate()
		}

	case CqlParserK_DELETE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1729)
			p.BatchDelete()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBatchInsertContext is an interface to support dynamic dispatch.
type IBatchInsertContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwInsert() IKwInsertContext
	KwInto() IKwIntoContext
	Table() ITableContext
	InsertValuesSpec() IInsertValuesSpecContext
	Keyspace() IKeyspaceContext
	DOT() antlr.TerminalNode
	InsertColumnSpec() IInsertColumnSpecContext
	IfNotExist() IIfNotExistContext
	UsingTtlTimestamp() IUsingTtlTimestampContext

	// IsBatchInsertContext differentiates from other interfaces.
	IsBatchInsertContext()
}

type BatchInsertContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBatchInsertContext() *BatchInsertContext {
	var p = new(BatchInsertContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_batchInsert
	return p
}

func InitEmptyBatchInsertContext(p *BatchInsertContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_batchInsert
}

func (*BatchInsertContext) IsBatchInsertContext() {}

func NewBatchInsertContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BatchInsertContext {
	var p = new(BatchInsertContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_batchInsert

	return p
}

func (s *BatchInsertContext) GetParser() antlr.Parser { return s.parser }

func (s *BatchInsertContext) KwInsert() IKwInsertContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwInsertContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwInsertContext)
}

func (s *BatchInsertContext) KwInto() IKwIntoContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwIntoContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwIntoContext)
}

func (s *BatchInsertContext) Table() ITableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableContext)
}

func (s *BatchInsertContext) InsertValuesSpec() IInsertValuesSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsertValuesSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsertValuesSpecContext)
}

func (s *BatchInsertContext) Keyspace() IKeyspaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyspaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyspaceContext)
}

func (s *BatchInsertContext) DOT() antlr.TerminalNode {
	return s.GetToken(CqlParserDOT, 0)
}

func (s *BatchInsertContext) InsertColumnSpec() IInsertColumnSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsertColumnSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsertColumnSpecContext)
}

func (s *BatchInsertContext) IfNotExist() IIfNotExistContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistContext)
}

func (s *BatchInsertContext) UsingTtlTimestamp() IUsingTtlTimestampContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUsingTtlTimestampContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUsingTtlTimestampContext)
}

func (s *BatchInsertContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BatchInsertContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BatchInsertContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterBatchInsert(s)
	}
}

func (s *BatchInsertContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitBatchInsert(s)
	}
}

func (p *CqlParser) BatchInsert() (localctx IBatchInsertContext) {
	localctx = NewBatchInsertContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, CqlParserRULE_batchInsert)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1732)
		p.KwInsert()
	}
	{
		p.SetState(1733)
		p.KwInto()
	}
	p.SetState(1737)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 120, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1734)
			p.Keyspace()
		}
		{
			p.SetState(1735)
			p.Match(CqlParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1739)
		p.Table()
	}
	p.SetState(1741)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CqlParserLR_BRACKET {
		{
			p.SetState(1740)
			p.InsertColumnSpec()
		}

	}
	{
		p.SetState(1743)
		p.InsertValuesSpec()
	}
	p.SetState(1745)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CqlParserK_IF {
		{
			p.SetState(1744)
			p.IfNotExist()
		}

	}
	p.SetState(1748)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CqlParserK_USING {
		{
			p.SetState(1747)
			p.UsingTtlTimestamp()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBatchUpdateContext is an interface to support dynamic dispatch.
type IBatchUpdateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwUpdate() IKwUpdateContext
	Table() ITableContext
	KwSet() IKwSetContext
	Assignments() IAssignmentsContext
	WhereSpec() IWhereSpecContext
	Keyspace() IKeyspaceContext
	DOT() antlr.TerminalNode
	UsingTtlTimestamp() IUsingTtlTimestampContext
	IfExist() IIfExistContext
	IfSpec() IIfSpecContext

	// IsBatchUpdateContext differentiates from other interfaces.
	IsBatchUpdateContext()
}

type BatchUpdateContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBatchUpdateContext() *BatchUpdateContext {
	var p = new(BatchUpdateContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_batchUpdate
	return p
}

func InitEmptyBatchUpdateContext(p *BatchUpdateContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_batchUpdate
}

func (*BatchUpdateContext) IsBatchUpdateContext() {}

func NewBatchUpdateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BatchUpdateContext {
	var p = new(BatchUpdateContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_batchUpdate

	return p
}

func (s *BatchUpdateContext) GetParser() antlr.Parser { return s.parser }

func (s *BatchUpdateContext) KwUpdate() IKwUpdateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwUpdateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwUpdateContext)
}

func (s *BatchUpdateContext) Table() ITableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableContext)
}

func (s *BatchUpdateContext) KwSet() IKwSetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwSetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwSetContext)
}

func (s *BatchUpdateContext) Assignments() IAssignmentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentsContext)
}

func (s *BatchUpdateContext) WhereSpec() IWhereSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhereSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhereSpecContext)
}

func (s *BatchUpdateContext) Keyspace() IKeyspaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyspaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyspaceContext)
}

func (s *BatchUpdateContext) DOT() antlr.TerminalNode {
	return s.GetToken(CqlParserDOT, 0)
}

func (s *BatchUpdateContext) UsingTtlTimestamp() IUsingTtlTimestampContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUsingTtlTimestampContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUsingTtlTimestampContext)
}

func (s *BatchUpdateContext) IfExist() IIfExistContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistContext)
}

func (s *BatchUpdateContext) IfSpec() IIfSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfSpecContext)
}

func (s *BatchUpdateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BatchUpdateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BatchUpdateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterBatchUpdate(s)
	}
}

func (s *BatchUpdateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitBatchUpdate(s)
	}
}

func (p *CqlParser) BatchUpdate() (localctx IBatchUpdateContext) {
	localctx = NewBatchUpdateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, CqlParserRULE_batchUpdate)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1750)
		p.KwUpdate()
	}
	p.SetState(1754)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 124, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1751)
			p.Keyspace()
		}
		{
			p.SetState(1752)
			p.Match(CqlParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1756)
		p.Table()
	}
	p.SetState(1758)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CqlParserK_USING {
		{
			p.SetState(1757)
			p.UsingTtlTimestamp()
		}

	}
	{
		p.SetState(1760)
		p.KwSet()
	}
	{
		p.SetState(1761)
		p.Assignments()
	}
	{
		p.SetState(1762)
		p.WhereSpec()
	}
	p.SetState(1765)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 126, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1763)
			p.IfExist()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 126, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(1764)
			p.IfSpec()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBatchDeleteContext is an interface to support dynamic dispatch.
type IBatchDeleteContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwDelete() IKwDeleteContext
	FromSpec() IFromSpecContext
	WhereSpec() IWhereSpecContext
	DeleteColumnList() IDeleteColumnListContext
	UsingTimestampSpec() IUsingTimestampSpecContext
	IfExist() IIfExistContext
	IfSpec() IIfSpecContext

	// IsBatchDeleteContext differentiates from other interfaces.
	IsBatchDeleteContext()
}

type BatchDeleteContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBatchDeleteContext() *BatchDeleteContext {
	var p = new(BatchDeleteContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_batchDelete
	return p
}

func InitEmptyBatchDeleteContext(p *BatchDeleteContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_batchDelete
}

func (*BatchDeleteContext) IsBatchDeleteContext() {}

func NewBatchDeleteContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BatchDeleteContext {
	var p = new(BatchDeleteContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_batchDelete

	return p
}

func (s *BatchDeleteContext) GetParser() antlr.Parser { return s.parser }

func (s *BatchDeleteContext) KwDelete() IKwDeleteContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwDeleteContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwDeleteContext)
}

func (s *BatchDeleteContext) FromSpec() IFromSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFromSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFromSpecContext)
}

func (s *BatchDeleteContext) WhereSpec() IWhereSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhereSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhereSpecContext)
}

func (s *BatchDeleteContext) DeleteColumnList() IDeleteColumnListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeleteColumnListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeleteColumnListContext)
}

func (s *BatchDeleteContext) UsingTimestampSpec() IUsingTimestampSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUsingTimestampSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUsingTimestampSpecContext)
}

func (s *BatchDeleteContext) IfExist() IIfExistContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistContext)
}

func (s *BatchDeleteContext) IfSpec() IIfSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfSpecContext)
}

func (s *BatchDeleteContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BatchDeleteContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BatchDeleteContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterBatchDelete(s)
	}
}

func (s *BatchDeleteContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitBatchDelete(s)
	}
}

func (p *CqlParser) BatchDelete() (localctx IBatchDeleteContext) {
	localctx = NewBatchDeleteContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, CqlParserRULE_batchDelete)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1767)
		p.KwDelete()
	}
	p.SetState(1769)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CqlParserOBJECT_NAME {
		{
			p.SetState(1768)
			p.DeleteColumnList()
		}

	}
	{
		p.SetState(1771)
		p.FromSpec()
	}
	p.SetState(1773)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CqlParserK_USING {
		{
			p.SetState(1772)
			p.UsingTimestampSpec()
		}

	}
	{
		p.SetState(1775)
		p.WhereSpec()
	}
	p.SetState(1778)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 129, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1776)
			p.IfExist()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 129, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(1777)
			p.IfSpec()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBeginBatchContext is an interface to support dynamic dispatch.
type IBeginBatchContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwBegin() IKwBeginContext
	KwBatch() IKwBatchContext
	BatchType() IBatchTypeContext
	UsingTimestampSpec() IUsingTimestampSpecContext

	// IsBeginBatchContext differentiates from other interfaces.
	IsBeginBatchContext()
}

type BeginBatchContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBeginBatchContext() *BeginBatchContext {
	var p = new(BeginBatchContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_beginBatch
	return p
}

func InitEmptyBeginBatchContext(p *BeginBatchContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_beginBatch
}

func (*BeginBatchContext) IsBeginBatchContext() {}

func NewBeginBatchContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BeginBatchContext {
	var p = new(BeginBatchContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_beginBatch

	return p
}

func (s *BeginBatchContext) GetParser() antlr.Parser { return s.parser }

func (s *BeginBatchContext) KwBegin() IKwBeginContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwBeginContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwBeginContext)
}

func (s *BeginBatchContext) KwBatch() IKwBatchContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwBatchContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwBatchContext)
}

func (s *BeginBatchContext) BatchType() IBatchTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBatchTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBatchTypeContext)
}

func (s *BeginBatchContext) UsingTimestampSpec() IUsingTimestampSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUsingTimestampSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUsingTimestampSpecContext)
}

func (s *BeginBatchContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BeginBatchContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BeginBatchContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterBeginBatch(s)
	}
}

func (s *BeginBatchContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitBeginBatch(s)
	}
}

func (p *CqlParser) BeginBatch() (localctx IBeginBatchContext) {
	localctx = NewBeginBatchContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, CqlParserRULE_beginBatch)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1780)
		p.KwBegin()
	}
	p.SetState(1782)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-83)) & ^0x3f) == 0 && ((int64(1)<<(_la-83))&-9223090561878065151) != 0 {
		{
			p.SetState(1781)
			p.BatchType()
		}

	}
	{
		p.SetState(1784)
		p.KwBatch()
	}
	p.SetState(1786)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CqlParserK_USING {
		{
			p.SetState(1785)
			p.UsingTimestampSpec()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBatchTypeContext is an interface to support dynamic dispatch.
type IBatchTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwLogged() IKwLoggedContext
	KwUnlogged() IKwUnloggedContext
	KwCounter() IKwCounterContext

	// IsBatchTypeContext differentiates from other interfaces.
	IsBatchTypeContext()
}

type BatchTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBatchTypeContext() *BatchTypeContext {
	var p = new(BatchTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_batchType
	return p
}

func InitEmptyBatchTypeContext(p *BatchTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_batchType
}

func (*BatchTypeContext) IsBatchTypeContext() {}

func NewBatchTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BatchTypeContext {
	var p = new(BatchTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_batchType

	return p
}

func (s *BatchTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *BatchTypeContext) KwLogged() IKwLoggedContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwLoggedContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwLoggedContext)
}

func (s *BatchTypeContext) KwUnlogged() IKwUnloggedContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwUnloggedContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwUnloggedContext)
}

func (s *BatchTypeContext) KwCounter() IKwCounterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwCounterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwCounterContext)
}

func (s *BatchTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BatchTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BatchTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterBatchType(s)
	}
}

func (s *BatchTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitBatchType(s)
	}
}

func (p *CqlParser) BatchType() (localctx IBatchTypeContext) {
	localctx = NewBatchTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, CqlParserRULE_batchType)
	p.SetState(1791)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case CqlParserK_LOGGED:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1788)
			p.KwLogged()
		}

	case CqlParserK_UNLOGGED:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1789)
			p.KwUnlogged()
		}

	case CqlParserK_COUNTER:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1790)
			p.KwCounter()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterKeyspaceContext is an interface to support dynamic dispatch.
type IAlterKeyspaceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwAlter() IKwAlterContext
	KwKeyspace() IKwKeyspaceContext
	Keyspace() IKeyspaceContext
	KwWith() IKwWithContext
	KwReplication() IKwReplicationContext
	OPERATOR_EQ() antlr.TerminalNode
	SyntaxBracketLc() ISyntaxBracketLcContext
	ReplicationList() IReplicationListContext
	SyntaxBracketRc() ISyntaxBracketRcContext
	KwAnd() IKwAndContext
	DurableWrites() IDurableWritesContext

	// IsAlterKeyspaceContext differentiates from other interfaces.
	IsAlterKeyspaceContext()
}

type AlterKeyspaceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterKeyspaceContext() *AlterKeyspaceContext {
	var p = new(AlterKeyspaceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_alterKeyspace
	return p
}

func InitEmptyAlterKeyspaceContext(p *AlterKeyspaceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_alterKeyspace
}

func (*AlterKeyspaceContext) IsAlterKeyspaceContext() {}

func NewAlterKeyspaceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterKeyspaceContext {
	var p = new(AlterKeyspaceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_alterKeyspace

	return p
}

func (s *AlterKeyspaceContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterKeyspaceContext) KwAlter() IKwAlterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwAlterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwAlterContext)
}

func (s *AlterKeyspaceContext) KwKeyspace() IKwKeyspaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwKeyspaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwKeyspaceContext)
}

func (s *AlterKeyspaceContext) Keyspace() IKeyspaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyspaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyspaceContext)
}

func (s *AlterKeyspaceContext) KwWith() IKwWithContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwWithContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwWithContext)
}

func (s *AlterKeyspaceContext) KwReplication() IKwReplicationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwReplicationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwReplicationContext)
}

func (s *AlterKeyspaceContext) OPERATOR_EQ() antlr.TerminalNode {
	return s.GetToken(CqlParserOPERATOR_EQ, 0)
}

func (s *AlterKeyspaceContext) SyntaxBracketLc() ISyntaxBracketLcContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxBracketLcContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxBracketLcContext)
}

func (s *AlterKeyspaceContext) ReplicationList() IReplicationListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReplicationListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReplicationListContext)
}

func (s *AlterKeyspaceContext) SyntaxBracketRc() ISyntaxBracketRcContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxBracketRcContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxBracketRcContext)
}

func (s *AlterKeyspaceContext) KwAnd() IKwAndContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwAndContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwAndContext)
}

func (s *AlterKeyspaceContext) DurableWrites() IDurableWritesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDurableWritesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDurableWritesContext)
}

func (s *AlterKeyspaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterKeyspaceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterKeyspaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterAlterKeyspace(s)
	}
}

func (s *AlterKeyspaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitAlterKeyspace(s)
	}
}

func (p *CqlParser) AlterKeyspace() (localctx IAlterKeyspaceContext) {
	localctx = NewAlterKeyspaceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, CqlParserRULE_alterKeyspace)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1793)
		p.KwAlter()
	}
	{
		p.SetState(1794)
		p.KwKeyspace()
	}
	{
		p.SetState(1795)
		p.Keyspace()
	}
	{
		p.SetState(1796)
		p.KwWith()
	}
	{
		p.SetState(1797)
		p.KwReplication()
	}
	{
		p.SetState(1798)
		p.Match(CqlParserOPERATOR_EQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1799)
		p.SyntaxBracketLc()
	}
	{
		p.SetState(1800)
		p.ReplicationList()
	}
	{
		p.SetState(1801)
		p.SyntaxBracketRc()
	}
	p.SetState(1805)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CqlParserK_AND {
		{
			p.SetState(1802)
			p.KwAnd()
		}
		{
			p.SetState(1803)
			p.DurableWrites()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReplicationListContext is an interface to support dynamic dispatch.
type IReplicationListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllReplicationListItem() []IReplicationListItemContext
	ReplicationListItem(i int) IReplicationListItemContext
	AllSyntaxComma() []ISyntaxCommaContext
	SyntaxComma(i int) ISyntaxCommaContext

	// IsReplicationListContext differentiates from other interfaces.
	IsReplicationListContext()
}

type ReplicationListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReplicationListContext() *ReplicationListContext {
	var p = new(ReplicationListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_replicationList
	return p
}

func InitEmptyReplicationListContext(p *ReplicationListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_replicationList
}

func (*ReplicationListContext) IsReplicationListContext() {}

func NewReplicationListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReplicationListContext {
	var p = new(ReplicationListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_replicationList

	return p
}

func (s *ReplicationListContext) GetParser() antlr.Parser { return s.parser }

func (s *ReplicationListContext) AllReplicationListItem() []IReplicationListItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IReplicationListItemContext); ok {
			len++
		}
	}

	tst := make([]IReplicationListItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IReplicationListItemContext); ok {
			tst[i] = t.(IReplicationListItemContext)
			i++
		}
	}

	return tst
}

func (s *ReplicationListContext) ReplicationListItem(i int) IReplicationListItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReplicationListItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReplicationListItemContext)
}

func (s *ReplicationListContext) AllSyntaxComma() []ISyntaxCommaContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			len++
		}
	}

	tst := make([]ISyntaxCommaContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISyntaxCommaContext); ok {
			tst[i] = t.(ISyntaxCommaContext)
			i++
		}
	}

	return tst
}

func (s *ReplicationListContext) SyntaxComma(i int) ISyntaxCommaContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxCommaContext)
}

func (s *ReplicationListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReplicationListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReplicationListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterReplicationList(s)
	}
}

func (s *ReplicationListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitReplicationList(s)
	}
}

func (p *CqlParser) ReplicationList() (localctx IReplicationListContext) {
	localctx = NewReplicationListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, CqlParserRULE_replicationList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1807)
		p.ReplicationListItem()
	}

	p.SetState(1813)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == CqlParserCOMMA {
		{
			p.SetState(1808)
			p.SyntaxComma()
		}
		{
			p.SetState(1809)
			p.ReplicationListItem()
		}

		p.SetState(1815)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReplicationListItemContext is an interface to support dynamic dispatch.
type IReplicationListItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSTRING_LITERAL() []antlr.TerminalNode
	STRING_LITERAL(i int) antlr.TerminalNode
	COLON() antlr.TerminalNode
	DECIMAL_LITERAL() antlr.TerminalNode

	// IsReplicationListItemContext differentiates from other interfaces.
	IsReplicationListItemContext()
}

type ReplicationListItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReplicationListItemContext() *ReplicationListItemContext {
	var p = new(ReplicationListItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_replicationListItem
	return p
}

func InitEmptyReplicationListItemContext(p *ReplicationListItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_replicationListItem
}

func (*ReplicationListItemContext) IsReplicationListItemContext() {}

func NewReplicationListItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReplicationListItemContext {
	var p = new(ReplicationListItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_replicationListItem

	return p
}

func (s *ReplicationListItemContext) GetParser() antlr.Parser { return s.parser }

func (s *ReplicationListItemContext) AllSTRING_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(CqlParserSTRING_LITERAL)
}

func (s *ReplicationListItemContext) STRING_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(CqlParserSTRING_LITERAL, i)
}

func (s *ReplicationListItemContext) COLON() antlr.TerminalNode {
	return s.GetToken(CqlParserCOLON, 0)
}

func (s *ReplicationListItemContext) DECIMAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(CqlParserDECIMAL_LITERAL, 0)
}

func (s *ReplicationListItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReplicationListItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReplicationListItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterReplicationListItem(s)
	}
}

func (s *ReplicationListItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitReplicationListItem(s)
	}
}

func (p *CqlParser) ReplicationListItem() (localctx IReplicationListItemContext) {
	localctx = NewReplicationListItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, CqlParserRULE_replicationListItem)
	p.SetState(1822)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 135, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1816)
			p.Match(CqlParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1817)
			p.Match(CqlParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1818)
			p.Match(CqlParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1819)
			p.Match(CqlParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1820)
			p.Match(CqlParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1821)
			p.Match(CqlParserDECIMAL_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDurableWritesContext is an interface to support dynamic dispatch.
type IDurableWritesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwDurableWrites() IKwDurableWritesContext
	OPERATOR_EQ() antlr.TerminalNode
	BooleanLiteral() IBooleanLiteralContext

	// IsDurableWritesContext differentiates from other interfaces.
	IsDurableWritesContext()
}

type DurableWritesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDurableWritesContext() *DurableWritesContext {
	var p = new(DurableWritesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_durableWrites
	return p
}

func InitEmptyDurableWritesContext(p *DurableWritesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_durableWrites
}

func (*DurableWritesContext) IsDurableWritesContext() {}

func NewDurableWritesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DurableWritesContext {
	var p = new(DurableWritesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_durableWrites

	return p
}

func (s *DurableWritesContext) GetParser() antlr.Parser { return s.parser }

func (s *DurableWritesContext) KwDurableWrites() IKwDurableWritesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwDurableWritesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwDurableWritesContext)
}

func (s *DurableWritesContext) OPERATOR_EQ() antlr.TerminalNode {
	return s.GetToken(CqlParserOPERATOR_EQ, 0)
}

func (s *DurableWritesContext) BooleanLiteral() IBooleanLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanLiteralContext)
}

func (s *DurableWritesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DurableWritesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DurableWritesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterDurableWrites(s)
	}
}

func (s *DurableWritesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitDurableWrites(s)
	}
}

func (p *CqlParser) DurableWrites() (localctx IDurableWritesContext) {
	localctx = NewDurableWritesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, CqlParserRULE_durableWrites)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1824)
		p.KwDurableWrites()
	}
	{
		p.SetState(1825)
		p.Match(CqlParserOPERATOR_EQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1826)
		p.BooleanLiteral()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITabletsSpecContext is an interface to support dynamic dispatch.
type ITabletsSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwTablets() IKwTabletsContext
	OPERATOR_EQ() antlr.TerminalNode
	SyntaxBracketLc() ISyntaxBracketLcContext
	TabletsOptions() ITabletsOptionsContext
	SyntaxBracketRc() ISyntaxBracketRcContext

	// IsTabletsSpecContext differentiates from other interfaces.
	IsTabletsSpecContext()
}

type TabletsSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTabletsSpecContext() *TabletsSpecContext {
	var p = new(TabletsSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_tabletsSpec
	return p
}

func InitEmptyTabletsSpecContext(p *TabletsSpecContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_tabletsSpec
}

func (*TabletsSpecContext) IsTabletsSpecContext() {}

func NewTabletsSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TabletsSpecContext {
	var p = new(TabletsSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_tabletsSpec

	return p
}

func (s *TabletsSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *TabletsSpecContext) KwTablets() IKwTabletsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwTabletsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwTabletsContext)
}

func (s *TabletsSpecContext) OPERATOR_EQ() antlr.TerminalNode {
	return s.GetToken(CqlParserOPERATOR_EQ, 0)
}

func (s *TabletsSpecContext) SyntaxBracketLc() ISyntaxBracketLcContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxBracketLcContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxBracketLcContext)
}

func (s *TabletsSpecContext) TabletsOptions() ITabletsOptionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITabletsOptionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITabletsOptionsContext)
}

func (s *TabletsSpecContext) SyntaxBracketRc() ISyntaxBracketRcContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxBracketRcContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxBracketRcContext)
}

func (s *TabletsSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TabletsSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TabletsSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterTabletsSpec(s)
	}
}

func (s *TabletsSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitTabletsSpec(s)
	}
}

func (p *CqlParser) TabletsSpec() (localctx ITabletsSpecContext) {
	localctx = NewTabletsSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 212, CqlParserRULE_tabletsSpec)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1828)
		p.KwTablets()
	}
	{
		p.SetState(1829)
		p.Match(CqlParserOPERATOR_EQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1830)
		p.SyntaxBracketLc()
	}
	{
		p.SetState(1831)
		p.TabletsOptions()
	}
	{
		p.SetState(1832)
		p.SyntaxBracketRc()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITabletsOptionsContext is an interface to support dynamic dispatch.
type ITabletsOptionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTabletsOption() []ITabletsOptionContext
	TabletsOption(i int) ITabletsOptionContext
	AllSyntaxComma() []ISyntaxCommaContext
	SyntaxComma(i int) ISyntaxCommaContext

	// IsTabletsOptionsContext differentiates from other interfaces.
	IsTabletsOptionsContext()
}

type TabletsOptionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTabletsOptionsContext() *TabletsOptionsContext {
	var p = new(TabletsOptionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_tabletsOptions
	return p
}

func InitEmptyTabletsOptionsContext(p *TabletsOptionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_tabletsOptions
}

func (*TabletsOptionsContext) IsTabletsOptionsContext() {}

func NewTabletsOptionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TabletsOptionsContext {
	var p = new(TabletsOptionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_tabletsOptions

	return p
}

func (s *TabletsOptionsContext) GetParser() antlr.Parser { return s.parser }

func (s *TabletsOptionsContext) AllTabletsOption() []ITabletsOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITabletsOptionContext); ok {
			len++
		}
	}

	tst := make([]ITabletsOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITabletsOptionContext); ok {
			tst[i] = t.(ITabletsOptionContext)
			i++
		}
	}

	return tst
}

func (s *TabletsOptionsContext) TabletsOption(i int) ITabletsOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITabletsOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITabletsOptionContext)
}

func (s *TabletsOptionsContext) AllSyntaxComma() []ISyntaxCommaContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			len++
		}
	}

	tst := make([]ISyntaxCommaContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISyntaxCommaContext); ok {
			tst[i] = t.(ISyntaxCommaContext)
			i++
		}
	}

	return tst
}

func (s *TabletsOptionsContext) SyntaxComma(i int) ISyntaxCommaContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxCommaContext)
}

func (s *TabletsOptionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TabletsOptionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TabletsOptionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterTabletsOptions(s)
	}
}

func (s *TabletsOptionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitTabletsOptions(s)
	}
}

func (p *CqlParser) TabletsOptions() (localctx ITabletsOptionsContext) {
	localctx = NewTabletsOptionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 214, CqlParserRULE_tabletsOptions)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1834)
		p.TabletsOption()
	}
	p.SetState(1840)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == CqlParserCOMMA {
		{
			p.SetState(1835)
			p.SyntaxComma()
		}
		{
			p.SetState(1836)
			p.TabletsOption()
		}

		p.SetState(1842)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITabletsOptionContext is an interface to support dynamic dispatch.
type ITabletsOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllStringLiteral() []IStringLiteralContext
	StringLiteral(i int) IStringLiteralContext
	COLON() antlr.TerminalNode
	BooleanLiteral() IBooleanLiteralContext
	DecimalLiteral() IDecimalLiteralContext

	// IsTabletsOptionContext differentiates from other interfaces.
	IsTabletsOptionContext()
}

type TabletsOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTabletsOptionContext() *TabletsOptionContext {
	var p = new(TabletsOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_tabletsOption
	return p
}

func InitEmptyTabletsOptionContext(p *TabletsOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_tabletsOption
}

func (*TabletsOptionContext) IsTabletsOptionContext() {}

func NewTabletsOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TabletsOptionContext {
	var p = new(TabletsOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_tabletsOption

	return p
}

func (s *TabletsOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *TabletsOptionContext) AllStringLiteral() []IStringLiteralContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringLiteralContext); ok {
			len++
		}
	}

	tst := make([]IStringLiteralContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringLiteralContext); ok {
			tst[i] = t.(IStringLiteralContext)
			i++
		}
	}

	return tst
}

func (s *TabletsOptionContext) StringLiteral(i int) IStringLiteralContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *TabletsOptionContext) COLON() antlr.TerminalNode {
	return s.GetToken(CqlParserCOLON, 0)
}

func (s *TabletsOptionContext) BooleanLiteral() IBooleanLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanLiteralContext)
}

func (s *TabletsOptionContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *TabletsOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TabletsOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TabletsOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterTabletsOption(s)
	}
}

func (s *TabletsOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitTabletsOption(s)
	}
}

func (p *CqlParser) TabletsOption() (localctx ITabletsOptionContext) {
	localctx = NewTabletsOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 216, CqlParserRULE_tabletsOption)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1843)
		p.StringLiteral()
	}
	{
		p.SetState(1844)
		p.Match(CqlParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1848)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case CqlParserSTRING_LITERAL:
		{
			p.SetState(1845)
			p.StringLiteral()
		}

	case CqlParserK_FALSE, CqlParserK_TRUE:
		{
			p.SetState(1846)
			p.BooleanLiteral()
		}

	case CqlParserDECIMAL_LITERAL:
		{
			p.SetState(1847)
			p.DecimalLiteral()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUse_Context is an interface to support dynamic dispatch.
type IUse_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwUse() IKwUseContext
	Keyspace() IKeyspaceContext

	// IsUse_Context differentiates from other interfaces.
	IsUse_Context()
}

type Use_Context struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUse_Context() *Use_Context {
	var p = new(Use_Context)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_use_
	return p
}

func InitEmptyUse_Context(p *Use_Context) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_use_
}

func (*Use_Context) IsUse_Context() {}

func NewUse_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Use_Context {
	var p = new(Use_Context)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_use_

	return p
}

func (s *Use_Context) GetParser() antlr.Parser { return s.parser }

func (s *Use_Context) KwUse() IKwUseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwUseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwUseContext)
}

func (s *Use_Context) Keyspace() IKeyspaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyspaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyspaceContext)
}

func (s *Use_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Use_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Use_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterUse_(s)
	}
}

func (s *Use_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitUse_(s)
	}
}

func (p *CqlParser) Use_() (localctx IUse_Context) {
	localctx = NewUse_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 218, CqlParserRULE_use_)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1850)
		p.KwUse()
	}
	{
		p.SetState(1851)
		p.Keyspace()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITruncateContext is an interface to support dynamic dispatch.
type ITruncateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwTruncate() IKwTruncateContext
	Table() ITableContext
	KwTable() IKwTableContext
	Keyspace() IKeyspaceContext
	DOT() antlr.TerminalNode

	// IsTruncateContext differentiates from other interfaces.
	IsTruncateContext()
}

type TruncateContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTruncateContext() *TruncateContext {
	var p = new(TruncateContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_truncate
	return p
}

func InitEmptyTruncateContext(p *TruncateContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_truncate
}

func (*TruncateContext) IsTruncateContext() {}

func NewTruncateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TruncateContext {
	var p = new(TruncateContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_truncate

	return p
}

func (s *TruncateContext) GetParser() antlr.Parser { return s.parser }

func (s *TruncateContext) KwTruncate() IKwTruncateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwTruncateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwTruncateContext)
}

func (s *TruncateContext) Table() ITableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableContext)
}

func (s *TruncateContext) KwTable() IKwTableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwTableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwTableContext)
}

func (s *TruncateContext) Keyspace() IKeyspaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyspaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyspaceContext)
}

func (s *TruncateContext) DOT() antlr.TerminalNode {
	return s.GetToken(CqlParserDOT, 0)
}

func (s *TruncateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TruncateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TruncateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterTruncate(s)
	}
}

func (s *TruncateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitTruncate(s)
	}
}

func (p *CqlParser) Truncate() (localctx ITruncateContext) {
	localctx = NewTruncateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 220, CqlParserRULE_truncate)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1853)
		p.KwTruncate()
	}
	p.SetState(1855)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CqlParserK_TABLE {
		{
			p.SetState(1854)
			p.KwTable()
		}

	}
	p.SetState(1860)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 139, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1857)
			p.Keyspace()
		}
		{
			p.SetState(1858)
			p.Match(CqlParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1862)
		p.Table()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateIndexContext is an interface to support dynamic dispatch.
type ICreateIndexContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwCreate() IKwCreateContext
	KwIndex() IKwIndexContext
	KwOn() IKwOnContext
	Table() ITableContext
	SyntaxBracketLr() ISyntaxBracketLrContext
	IndexColumnSpec() IIndexColumnSpecContext
	SyntaxBracketRr() ISyntaxBracketRrContext
	KwCustom() IKwCustomContext
	IfNotExist() IIfNotExistContext
	OBJECT_NAME() antlr.TerminalNode
	Keyspace() IKeyspaceContext
	DOT() antlr.TerminalNode
	IndexUsing() IIndexUsingContext

	// IsCreateIndexContext differentiates from other interfaces.
	IsCreateIndexContext()
}

type CreateIndexContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateIndexContext() *CreateIndexContext {
	var p = new(CreateIndexContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_createIndex
	return p
}

func InitEmptyCreateIndexContext(p *CreateIndexContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_createIndex
}

func (*CreateIndexContext) IsCreateIndexContext() {}

func NewCreateIndexContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateIndexContext {
	var p = new(CreateIndexContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_createIndex

	return p
}

func (s *CreateIndexContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateIndexContext) KwCreate() IKwCreateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwCreateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwCreateContext)
}

func (s *CreateIndexContext) KwIndex() IKwIndexContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwIndexContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwIndexContext)
}

func (s *CreateIndexContext) KwOn() IKwOnContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwOnContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwOnContext)
}

func (s *CreateIndexContext) Table() ITableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableContext)
}

func (s *CreateIndexContext) SyntaxBracketLr() ISyntaxBracketLrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxBracketLrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxBracketLrContext)
}

func (s *CreateIndexContext) IndexColumnSpec() IIndexColumnSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexColumnSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexColumnSpecContext)
}

func (s *CreateIndexContext) SyntaxBracketRr() ISyntaxBracketRrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxBracketRrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxBracketRrContext)
}

func (s *CreateIndexContext) KwCustom() IKwCustomContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwCustomContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwCustomContext)
}

func (s *CreateIndexContext) IfNotExist() IIfNotExistContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistContext)
}

func (s *CreateIndexContext) OBJECT_NAME() antlr.TerminalNode {
	return s.GetToken(CqlParserOBJECT_NAME, 0)
}

func (s *CreateIndexContext) Keyspace() IKeyspaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyspaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyspaceContext)
}

func (s *CreateIndexContext) DOT() antlr.TerminalNode {
	return s.GetToken(CqlParserDOT, 0)
}

func (s *CreateIndexContext) IndexUsing() IIndexUsingContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexUsingContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexUsingContext)
}

func (s *CreateIndexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateIndexContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateIndexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterCreateIndex(s)
	}
}

func (s *CreateIndexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitCreateIndex(s)
	}
}

func (p *CqlParser) CreateIndex() (localctx ICreateIndexContext) {
	localctx = NewCreateIndexContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 222, CqlParserRULE_createIndex)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1864)
		p.KwCreate()
	}
	p.SetState(1866)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CqlParserK_CUSTOM {
		{
			p.SetState(1865)
			p.KwCustom()
		}

	}
	{
		p.SetState(1868)
		p.KwIndex()
	}
	p.SetState(1870)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CqlParserK_IF {
		{
			p.SetState(1869)
			p.IfNotExist()
		}

	}
	p.SetState(1873)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CqlParserOBJECT_NAME {
		{
			p.SetState(1872)
			p.Match(CqlParserOBJECT_NAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1875)
		p.KwOn()
	}
	p.SetState(1879)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 143, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1876)
			p.Keyspace()
		}
		{
			p.SetState(1877)
			p.Match(CqlParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1881)
		p.Table()
	}
	{
		p.SetState(1882)
		p.SyntaxBracketLr()
	}
	{
		p.SetState(1883)
		p.IndexColumnSpec()
	}
	{
		p.SetState(1884)
		p.SyntaxBracketRr()
	}
	p.SetState(1886)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CqlParserK_USING {
		{
			p.SetState(1885)
			p.IndexUsing()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndexUsingContext is an interface to support dynamic dispatch.
type IIndexUsingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwUsing() IKwUsingContext
	StringLiteral() IStringLiteralContext
	IndexOptions() IIndexOptionsContext

	// IsIndexUsingContext differentiates from other interfaces.
	IsIndexUsingContext()
}

type IndexUsingContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexUsingContext() *IndexUsingContext {
	var p = new(IndexUsingContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_indexUsing
	return p
}

func InitEmptyIndexUsingContext(p *IndexUsingContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_indexUsing
}

func (*IndexUsingContext) IsIndexUsingContext() {}

func NewIndexUsingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexUsingContext {
	var p = new(IndexUsingContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_indexUsing

	return p
}

func (s *IndexUsingContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexUsingContext) KwUsing() IKwUsingContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwUsingContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwUsingContext)
}

func (s *IndexUsingContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *IndexUsingContext) IndexOptions() IIndexOptionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexOptionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexOptionsContext)
}

func (s *IndexUsingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexUsingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexUsingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterIndexUsing(s)
	}
}

func (s *IndexUsingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitIndexUsing(s)
	}
}

func (p *CqlParser) IndexUsing() (localctx IIndexUsingContext) {
	localctx = NewIndexUsingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 224, CqlParserRULE_indexUsing)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1888)
		p.KwUsing()
	}
	{
		p.SetState(1889)
		p.StringLiteral()
	}
	p.SetState(1891)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CqlParserK_WITH {
		{
			p.SetState(1890)
			p.IndexOptions()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndexOptionsContext is an interface to support dynamic dispatch.
type IIndexOptionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwWith() IKwWithContext
	KwOptions() IKwOptionsContext
	OPERATOR_EQ() antlr.TerminalNode
	OptionHash() IOptionHashContext

	// IsIndexOptionsContext differentiates from other interfaces.
	IsIndexOptionsContext()
}

type IndexOptionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexOptionsContext() *IndexOptionsContext {
	var p = new(IndexOptionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_indexOptions
	return p
}

func InitEmptyIndexOptionsContext(p *IndexOptionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_indexOptions
}

func (*IndexOptionsContext) IsIndexOptionsContext() {}

func NewIndexOptionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexOptionsContext {
	var p = new(IndexOptionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_indexOptions

	return p
}

func (s *IndexOptionsContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexOptionsContext) KwWith() IKwWithContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwWithContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwWithContext)
}

func (s *IndexOptionsContext) KwOptions() IKwOptionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwOptionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwOptionsContext)
}

func (s *IndexOptionsContext) OPERATOR_EQ() antlr.TerminalNode {
	return s.GetToken(CqlParserOPERATOR_EQ, 0)
}

func (s *IndexOptionsContext) OptionHash() IOptionHashContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOptionHashContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOptionHashContext)
}

func (s *IndexOptionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexOptionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexOptionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterIndexOptions(s)
	}
}

func (s *IndexOptionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitIndexOptions(s)
	}
}

func (p *CqlParser) IndexOptions() (localctx IIndexOptionsContext) {
	localctx = NewIndexOptionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 226, CqlParserRULE_indexOptions)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1893)
		p.KwWith()
	}
	{
		p.SetState(1894)
		p.KwOptions()
	}
	{
		p.SetState(1895)
		p.Match(CqlParserOPERATOR_EQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1896)
		p.OptionHash()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndexNameContext is an interface to support dynamic dispatch.
type IIndexNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OBJECT_NAME() antlr.TerminalNode
	StringLiteral() IStringLiteralContext

	// IsIndexNameContext differentiates from other interfaces.
	IsIndexNameContext()
}

type IndexNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexNameContext() *IndexNameContext {
	var p = new(IndexNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_indexName
	return p
}

func InitEmptyIndexNameContext(p *IndexNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_indexName
}

func (*IndexNameContext) IsIndexNameContext() {}

func NewIndexNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexNameContext {
	var p = new(IndexNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_indexName

	return p
}

func (s *IndexNameContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexNameContext) OBJECT_NAME() antlr.TerminalNode {
	return s.GetToken(CqlParserOBJECT_NAME, 0)
}

func (s *IndexNameContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *IndexNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterIndexName(s)
	}
}

func (s *IndexNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitIndexName(s)
	}
}

func (p *CqlParser) IndexName() (localctx IIndexNameContext) {
	localctx = NewIndexNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 228, CqlParserRULE_indexName)
	p.SetState(1900)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case CqlParserOBJECT_NAME:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1898)
			p.Match(CqlParserOBJECT_NAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case CqlParserSTRING_LITERAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1899)
			p.StringLiteral()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndexColumnSpecContext is an interface to support dynamic dispatch.
type IIndexColumnSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Column() IColumnContext
	IndexKeysSpec() IIndexKeysSpecContext
	IndexEntriesSSpec() IIndexEntriesSSpecContext
	IndexFullSpec() IIndexFullSpecContext

	// IsIndexColumnSpecContext differentiates from other interfaces.
	IsIndexColumnSpecContext()
}

type IndexColumnSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexColumnSpecContext() *IndexColumnSpecContext {
	var p = new(IndexColumnSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_indexColumnSpec
	return p
}

func InitEmptyIndexColumnSpecContext(p *IndexColumnSpecContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_indexColumnSpec
}

func (*IndexColumnSpecContext) IsIndexColumnSpecContext() {}

func NewIndexColumnSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexColumnSpecContext {
	var p = new(IndexColumnSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_indexColumnSpec

	return p
}

func (s *IndexColumnSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexColumnSpecContext) Column() IColumnContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnContext)
}

func (s *IndexColumnSpecContext) IndexKeysSpec() IIndexKeysSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexKeysSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexKeysSpecContext)
}

func (s *IndexColumnSpecContext) IndexEntriesSSpec() IIndexEntriesSSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexEntriesSSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexEntriesSSpecContext)
}

func (s *IndexColumnSpecContext) IndexFullSpec() IIndexFullSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexFullSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexFullSpecContext)
}

func (s *IndexColumnSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexColumnSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexColumnSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterIndexColumnSpec(s)
	}
}

func (s *IndexColumnSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitIndexColumnSpec(s)
	}
}

func (p *CqlParser) IndexColumnSpec() (localctx IIndexColumnSpecContext) {
	localctx = NewIndexColumnSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 230, CqlParserRULE_indexColumnSpec)
	p.SetState(1906)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case CqlParserDQUOTE, CqlParserK_KEY, CqlParserK_PASSWORD, CqlParserK_ROLE, CqlParserK_STATIC, CqlParserK_TIMESTAMP, CqlParserK_TWO, CqlParserK_TYPE, CqlParserK_USER, CqlParserK_UUID, CqlParserK_VALUES, CqlParserK_TEXT, CqlParserK_TIME, CqlParserK_VALUE, CqlParserOBJECT_NAME:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1902)
			p.Column()
		}

	case CqlParserK_KEYS:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1903)
			p.IndexKeysSpec()
		}

	case CqlParserK_ENTRIES:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1904)
			p.IndexEntriesSSpec()
		}

	case CqlParserK_FULL:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1905)
			p.IndexFullSpec()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndexKeysSpecContext is an interface to support dynamic dispatch.
type IIndexKeysSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwKeys() IKwKeysContext
	SyntaxBracketLr() ISyntaxBracketLrContext
	OBJECT_NAME() antlr.TerminalNode
	SyntaxBracketRr() ISyntaxBracketRrContext

	// IsIndexKeysSpecContext differentiates from other interfaces.
	IsIndexKeysSpecContext()
}

type IndexKeysSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexKeysSpecContext() *IndexKeysSpecContext {
	var p = new(IndexKeysSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_indexKeysSpec
	return p
}

func InitEmptyIndexKeysSpecContext(p *IndexKeysSpecContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_indexKeysSpec
}

func (*IndexKeysSpecContext) IsIndexKeysSpecContext() {}

func NewIndexKeysSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexKeysSpecContext {
	var p = new(IndexKeysSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_indexKeysSpec

	return p
}

func (s *IndexKeysSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexKeysSpecContext) KwKeys() IKwKeysContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwKeysContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwKeysContext)
}

func (s *IndexKeysSpecContext) SyntaxBracketLr() ISyntaxBracketLrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxBracketLrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxBracketLrContext)
}

func (s *IndexKeysSpecContext) OBJECT_NAME() antlr.TerminalNode {
	return s.GetToken(CqlParserOBJECT_NAME, 0)
}

func (s *IndexKeysSpecContext) SyntaxBracketRr() ISyntaxBracketRrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxBracketRrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxBracketRrContext)
}

func (s *IndexKeysSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexKeysSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexKeysSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterIndexKeysSpec(s)
	}
}

func (s *IndexKeysSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitIndexKeysSpec(s)
	}
}

func (p *CqlParser) IndexKeysSpec() (localctx IIndexKeysSpecContext) {
	localctx = NewIndexKeysSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 232, CqlParserRULE_indexKeysSpec)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1908)
		p.KwKeys()
	}
	{
		p.SetState(1909)
		p.SyntaxBracketLr()
	}
	{
		p.SetState(1910)
		p.Match(CqlParserOBJECT_NAME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1911)
		p.SyntaxBracketRr()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndexEntriesSSpecContext is an interface to support dynamic dispatch.
type IIndexEntriesSSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwEntries() IKwEntriesContext
	SyntaxBracketLr() ISyntaxBracketLrContext
	OBJECT_NAME() antlr.TerminalNode
	SyntaxBracketRr() ISyntaxBracketRrContext

	// IsIndexEntriesSSpecContext differentiates from other interfaces.
	IsIndexEntriesSSpecContext()
}

type IndexEntriesSSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexEntriesSSpecContext() *IndexEntriesSSpecContext {
	var p = new(IndexEntriesSSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_indexEntriesSSpec
	return p
}

func InitEmptyIndexEntriesSSpecContext(p *IndexEntriesSSpecContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_indexEntriesSSpec
}

func (*IndexEntriesSSpecContext) IsIndexEntriesSSpecContext() {}

func NewIndexEntriesSSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexEntriesSSpecContext {
	var p = new(IndexEntriesSSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_indexEntriesSSpec

	return p
}

func (s *IndexEntriesSSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexEntriesSSpecContext) KwEntries() IKwEntriesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwEntriesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwEntriesContext)
}

func (s *IndexEntriesSSpecContext) SyntaxBracketLr() ISyntaxBracketLrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxBracketLrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxBracketLrContext)
}

func (s *IndexEntriesSSpecContext) OBJECT_NAME() antlr.TerminalNode {
	return s.GetToken(CqlParserOBJECT_NAME, 0)
}

func (s *IndexEntriesSSpecContext) SyntaxBracketRr() ISyntaxBracketRrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxBracketRrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxBracketRrContext)
}

func (s *IndexEntriesSSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexEntriesSSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexEntriesSSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterIndexEntriesSSpec(s)
	}
}

func (s *IndexEntriesSSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitIndexEntriesSSpec(s)
	}
}

func (p *CqlParser) IndexEntriesSSpec() (localctx IIndexEntriesSSpecContext) {
	localctx = NewIndexEntriesSSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 234, CqlParserRULE_indexEntriesSSpec)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1913)
		p.KwEntries()
	}
	{
		p.SetState(1914)
		p.SyntaxBracketLr()
	}
	{
		p.SetState(1915)
		p.Match(CqlParserOBJECT_NAME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1916)
		p.SyntaxBracketRr()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndexFullSpecContext is an interface to support dynamic dispatch.
type IIndexFullSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwFull() IKwFullContext
	SyntaxBracketLr() ISyntaxBracketLrContext
	OBJECT_NAME() antlr.TerminalNode
	SyntaxBracketRr() ISyntaxBracketRrContext

	// IsIndexFullSpecContext differentiates from other interfaces.
	IsIndexFullSpecContext()
}

type IndexFullSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexFullSpecContext() *IndexFullSpecContext {
	var p = new(IndexFullSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_indexFullSpec
	return p
}

func InitEmptyIndexFullSpecContext(p *IndexFullSpecContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_indexFullSpec
}

func (*IndexFullSpecContext) IsIndexFullSpecContext() {}

func NewIndexFullSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexFullSpecContext {
	var p = new(IndexFullSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_indexFullSpec

	return p
}

func (s *IndexFullSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexFullSpecContext) KwFull() IKwFullContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwFullContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwFullContext)
}

func (s *IndexFullSpecContext) SyntaxBracketLr() ISyntaxBracketLrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxBracketLrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxBracketLrContext)
}

func (s *IndexFullSpecContext) OBJECT_NAME() antlr.TerminalNode {
	return s.GetToken(CqlParserOBJECT_NAME, 0)
}

func (s *IndexFullSpecContext) SyntaxBracketRr() ISyntaxBracketRrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxBracketRrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxBracketRrContext)
}

func (s *IndexFullSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexFullSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexFullSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterIndexFullSpec(s)
	}
}

func (s *IndexFullSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitIndexFullSpec(s)
	}
}

func (p *CqlParser) IndexFullSpec() (localctx IIndexFullSpecContext) {
	localctx = NewIndexFullSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 236, CqlParserRULE_indexFullSpec)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1918)
		p.KwFull()
	}
	{
		p.SetState(1919)
		p.SyntaxBracketLr()
	}
	{
		p.SetState(1920)
		p.Match(CqlParserOBJECT_NAME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1921)
		p.SyntaxBracketRr()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDelete_Context is an interface to support dynamic dispatch.
type IDelete_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwDelete() IKwDeleteContext
	FromSpec() IFromSpecContext
	WhereSpec() IWhereSpecContext
	BeginBatch() IBeginBatchContext
	DeleteColumnList() IDeleteColumnListContext
	UsingTimestampSpec() IUsingTimestampSpecContext
	IfExist() IIfExistContext
	IfSpec() IIfSpecContext

	// IsDelete_Context differentiates from other interfaces.
	IsDelete_Context()
}

type Delete_Context struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDelete_Context() *Delete_Context {
	var p = new(Delete_Context)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_delete_
	return p
}

func InitEmptyDelete_Context(p *Delete_Context) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_delete_
}

func (*Delete_Context) IsDelete_Context() {}

func NewDelete_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Delete_Context {
	var p = new(Delete_Context)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_delete_

	return p
}

func (s *Delete_Context) GetParser() antlr.Parser { return s.parser }

func (s *Delete_Context) KwDelete() IKwDeleteContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwDeleteContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwDeleteContext)
}

func (s *Delete_Context) FromSpec() IFromSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFromSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFromSpecContext)
}

func (s *Delete_Context) WhereSpec() IWhereSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhereSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhereSpecContext)
}

func (s *Delete_Context) BeginBatch() IBeginBatchContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBeginBatchContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBeginBatchContext)
}

func (s *Delete_Context) DeleteColumnList() IDeleteColumnListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeleteColumnListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeleteColumnListContext)
}

func (s *Delete_Context) UsingTimestampSpec() IUsingTimestampSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUsingTimestampSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUsingTimestampSpecContext)
}

func (s *Delete_Context) IfExist() IIfExistContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistContext)
}

func (s *Delete_Context) IfSpec() IIfSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfSpecContext)
}

func (s *Delete_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Delete_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Delete_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterDelete_(s)
	}
}

func (s *Delete_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitDelete_(s)
	}
}

func (p *CqlParser) Delete_() (localctx IDelete_Context) {
	localctx = NewDelete_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 238, CqlParserRULE_delete_)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1924)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CqlParserK_BEGIN {
		{
			p.SetState(1923)
			p.BeginBatch()
		}

	}
	{
		p.SetState(1926)
		p.KwDelete()
	}
	p.SetState(1928)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CqlParserOBJECT_NAME {
		{
			p.SetState(1927)
			p.DeleteColumnList()
		}

	}
	{
		p.SetState(1930)
		p.FromSpec()
	}
	p.SetState(1932)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CqlParserK_USING {
		{
			p.SetState(1931)
			p.UsingTimestampSpec()
		}

	}
	{
		p.SetState(1934)
		p.WhereSpec()
	}
	p.SetState(1937)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 151, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1935)
			p.IfExist()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 151, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(1936)
			p.IfSpec()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDeleteColumnListContext is an interface to support dynamic dispatch.
type IDeleteColumnListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllDeleteColumnItem() []IDeleteColumnItemContext
	DeleteColumnItem(i int) IDeleteColumnItemContext
	AllSyntaxComma() []ISyntaxCommaContext
	SyntaxComma(i int) ISyntaxCommaContext

	// IsDeleteColumnListContext differentiates from other interfaces.
	IsDeleteColumnListContext()
}

type DeleteColumnListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeleteColumnListContext() *DeleteColumnListContext {
	var p = new(DeleteColumnListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_deleteColumnList
	return p
}

func InitEmptyDeleteColumnListContext(p *DeleteColumnListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_deleteColumnList
}

func (*DeleteColumnListContext) IsDeleteColumnListContext() {}

func NewDeleteColumnListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeleteColumnListContext {
	var p = new(DeleteColumnListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_deleteColumnList

	return p
}

func (s *DeleteColumnListContext) GetParser() antlr.Parser { return s.parser }

func (s *DeleteColumnListContext) AllDeleteColumnItem() []IDeleteColumnItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDeleteColumnItemContext); ok {
			len++
		}
	}

	tst := make([]IDeleteColumnItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDeleteColumnItemContext); ok {
			tst[i] = t.(IDeleteColumnItemContext)
			i++
		}
	}

	return tst
}

func (s *DeleteColumnListContext) DeleteColumnItem(i int) IDeleteColumnItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeleteColumnItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeleteColumnItemContext)
}

func (s *DeleteColumnListContext) AllSyntaxComma() []ISyntaxCommaContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			len++
		}
	}

	tst := make([]ISyntaxCommaContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISyntaxCommaContext); ok {
			tst[i] = t.(ISyntaxCommaContext)
			i++
		}
	}

	return tst
}

func (s *DeleteColumnListContext) SyntaxComma(i int) ISyntaxCommaContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxCommaContext)
}

func (s *DeleteColumnListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeleteColumnListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeleteColumnListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterDeleteColumnList(s)
	}
}

func (s *DeleteColumnListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitDeleteColumnList(s)
	}
}

func (p *CqlParser) DeleteColumnList() (localctx IDeleteColumnListContext) {
	localctx = NewDeleteColumnListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 240, CqlParserRULE_deleteColumnList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1939)
		p.DeleteColumnItem()
	}

	p.SetState(1945)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == CqlParserCOMMA {
		{
			p.SetState(1940)
			p.SyntaxComma()
		}
		{
			p.SetState(1941)
			p.DeleteColumnItem()
		}

		p.SetState(1947)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDeleteColumnItemContext is an interface to support dynamic dispatch.
type IDeleteColumnItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OBJECT_NAME() antlr.TerminalNode
	LS_BRACKET() antlr.TerminalNode
	RS_BRACKET() antlr.TerminalNode
	StringLiteral() IStringLiteralContext
	DecimalLiteral() IDecimalLiteralContext

	// IsDeleteColumnItemContext differentiates from other interfaces.
	IsDeleteColumnItemContext()
}

type DeleteColumnItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeleteColumnItemContext() *DeleteColumnItemContext {
	var p = new(DeleteColumnItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_deleteColumnItem
	return p
}

func InitEmptyDeleteColumnItemContext(p *DeleteColumnItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_deleteColumnItem
}

func (*DeleteColumnItemContext) IsDeleteColumnItemContext() {}

func NewDeleteColumnItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeleteColumnItemContext {
	var p = new(DeleteColumnItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_deleteColumnItem

	return p
}

func (s *DeleteColumnItemContext) GetParser() antlr.Parser { return s.parser }

func (s *DeleteColumnItemContext) OBJECT_NAME() antlr.TerminalNode {
	return s.GetToken(CqlParserOBJECT_NAME, 0)
}

func (s *DeleteColumnItemContext) LS_BRACKET() antlr.TerminalNode {
	return s.GetToken(CqlParserLS_BRACKET, 0)
}

func (s *DeleteColumnItemContext) RS_BRACKET() antlr.TerminalNode {
	return s.GetToken(CqlParserRS_BRACKET, 0)
}

func (s *DeleteColumnItemContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *DeleteColumnItemContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *DeleteColumnItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeleteColumnItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeleteColumnItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterDeleteColumnItem(s)
	}
}

func (s *DeleteColumnItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitDeleteColumnItem(s)
	}
}

func (p *CqlParser) DeleteColumnItem() (localctx IDeleteColumnItemContext) {
	localctx = NewDeleteColumnItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 242, CqlParserRULE_deleteColumnItem)
	p.SetState(1957)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 154, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1948)
			p.Match(CqlParserOBJECT_NAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1949)
			p.Match(CqlParserOBJECT_NAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1950)
			p.Match(CqlParserLS_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1953)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case CqlParserSTRING_LITERAL:
			{
				p.SetState(1951)
				p.StringLiteral()
			}

		case CqlParserDECIMAL_LITERAL:
			{
				p.SetState(1952)
				p.DecimalLiteral()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(1955)
			p.Match(CqlParserRS_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUpdateContext is an interface to support dynamic dispatch.
type IUpdateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwUpdate() IKwUpdateContext
	Table() ITableContext
	KwSet() IKwSetContext
	Assignments() IAssignmentsContext
	WhereSpec() IWhereSpecContext
	BeginBatch() IBeginBatchContext
	Keyspace() IKeyspaceContext
	DOT() antlr.TerminalNode
	UsingTtlTimestamp() IUsingTtlTimestampContext
	IfExist() IIfExistContext
	IfSpec() IIfSpecContext

	// IsUpdateContext differentiates from other interfaces.
	IsUpdateContext()
}

type UpdateContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUpdateContext() *UpdateContext {
	var p = new(UpdateContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_update
	return p
}

func InitEmptyUpdateContext(p *UpdateContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_update
}

func (*UpdateContext) IsUpdateContext() {}

func NewUpdateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UpdateContext {
	var p = new(UpdateContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_update

	return p
}

func (s *UpdateContext) GetParser() antlr.Parser { return s.parser }

func (s *UpdateContext) KwUpdate() IKwUpdateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwUpdateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwUpdateContext)
}

func (s *UpdateContext) Table() ITableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableContext)
}

func (s *UpdateContext) KwSet() IKwSetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwSetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwSetContext)
}

func (s *UpdateContext) Assignments() IAssignmentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentsContext)
}

func (s *UpdateContext) WhereSpec() IWhereSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhereSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhereSpecContext)
}

func (s *UpdateContext) BeginBatch() IBeginBatchContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBeginBatchContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBeginBatchContext)
}

func (s *UpdateContext) Keyspace() IKeyspaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyspaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyspaceContext)
}

func (s *UpdateContext) DOT() antlr.TerminalNode {
	return s.GetToken(CqlParserDOT, 0)
}

func (s *UpdateContext) UsingTtlTimestamp() IUsingTtlTimestampContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUsingTtlTimestampContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUsingTtlTimestampContext)
}

func (s *UpdateContext) IfExist() IIfExistContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistContext)
}

func (s *UpdateContext) IfSpec() IIfSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfSpecContext)
}

func (s *UpdateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UpdateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UpdateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterUpdate(s)
	}
}

func (s *UpdateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitUpdate(s)
	}
}

func (p *CqlParser) Update() (localctx IUpdateContext) {
	localctx = NewUpdateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 244, CqlParserRULE_update)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1960)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CqlParserK_BEGIN {
		{
			p.SetState(1959)
			p.BeginBatch()
		}

	}
	{
		p.SetState(1962)
		p.KwUpdate()
	}
	p.SetState(1966)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 156, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1963)
			p.Keyspace()
		}
		{
			p.SetState(1964)
			p.Match(CqlParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1968)
		p.Table()
	}
	p.SetState(1970)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CqlParserK_USING {
		{
			p.SetState(1969)
			p.UsingTtlTimestamp()
		}

	}
	{
		p.SetState(1972)
		p.KwSet()
	}
	{
		p.SetState(1973)
		p.Assignments()
	}
	{
		p.SetState(1974)
		p.WhereSpec()
	}
	p.SetState(1977)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 158, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1975)
			p.IfExist()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 158, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(1976)
			p.IfSpec()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIfSpecContext is an interface to support dynamic dispatch.
type IIfSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwIf() IKwIfContext
	IfConditionList() IIfConditionListContext
	KwNot() IKwNotContext
	KwExists() IKwExistsContext

	// IsIfSpecContext differentiates from other interfaces.
	IsIfSpecContext()
}

type IfSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfSpecContext() *IfSpecContext {
	var p = new(IfSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_ifSpec
	return p
}

func InitEmptyIfSpecContext(p *IfSpecContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_ifSpec
}

func (*IfSpecContext) IsIfSpecContext() {}

func NewIfSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfSpecContext {
	var p = new(IfSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_ifSpec

	return p
}

func (s *IfSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *IfSpecContext) KwIf() IKwIfContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwIfContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwIfContext)
}

func (s *IfSpecContext) IfConditionList() IIfConditionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfConditionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfConditionListContext)
}

func (s *IfSpecContext) KwNot() IKwNotContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwNotContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwNotContext)
}

func (s *IfSpecContext) KwExists() IKwExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwExistsContext)
}

func (s *IfSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterIfSpec(s)
	}
}

func (s *IfSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitIfSpec(s)
	}
}

func (p *CqlParser) IfSpec() (localctx IIfSpecContext) {
	localctx = NewIfSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 246, CqlParserRULE_ifSpec)
	p.SetState(1986)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 159, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1979)
			p.KwIf()
		}
		{
			p.SetState(1980)
			p.IfConditionList()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1982)
			p.KwIf()
		}
		{
			p.SetState(1983)
			p.KwNot()
		}
		{
			p.SetState(1984)
			p.KwExists()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIfConditionListContext is an interface to support dynamic dispatch.
type IIfConditionListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIfCondition() []IIfConditionContext
	IfCondition(i int) IIfConditionContext
	AllKwAnd() []IKwAndContext
	KwAnd(i int) IKwAndContext
	AllKwOr() []IKwOrContext
	KwOr(i int) IKwOrContext

	// IsIfConditionListContext differentiates from other interfaces.
	IsIfConditionListContext()
}

type IfConditionListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfConditionListContext() *IfConditionListContext {
	var p = new(IfConditionListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_ifConditionList
	return p
}

func InitEmptyIfConditionListContext(p *IfConditionListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_ifConditionList
}

func (*IfConditionListContext) IsIfConditionListContext() {}

func NewIfConditionListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfConditionListContext {
	var p = new(IfConditionListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_ifConditionList

	return p
}

func (s *IfConditionListContext) GetParser() antlr.Parser { return s.parser }

func (s *IfConditionListContext) AllIfCondition() []IIfConditionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIfConditionContext); ok {
			len++
		}
	}

	tst := make([]IIfConditionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIfConditionContext); ok {
			tst[i] = t.(IIfConditionContext)
			i++
		}
	}

	return tst
}

func (s *IfConditionListContext) IfCondition(i int) IIfConditionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfConditionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfConditionContext)
}

func (s *IfConditionListContext) AllKwAnd() []IKwAndContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IKwAndContext); ok {
			len++
		}
	}

	tst := make([]IKwAndContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IKwAndContext); ok {
			tst[i] = t.(IKwAndContext)
			i++
		}
	}

	return tst
}

func (s *IfConditionListContext) KwAnd(i int) IKwAndContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwAndContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwAndContext)
}

func (s *IfConditionListContext) AllKwOr() []IKwOrContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IKwOrContext); ok {
			len++
		}
	}

	tst := make([]IKwOrContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IKwOrContext); ok {
			tst[i] = t.(IKwOrContext)
			i++
		}
	}

	return tst
}

func (s *IfConditionListContext) KwOr(i int) IKwOrContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwOrContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwOrContext)
}

func (s *IfConditionListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfConditionListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfConditionListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterIfConditionList(s)
	}
}

func (s *IfConditionListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitIfConditionList(s)
	}
}

func (p *CqlParser) IfConditionList() (localctx IIfConditionListContext) {
	localctx = NewIfConditionListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 248, CqlParserRULE_ifConditionList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1988)
		p.IfCondition()
	}

	p.SetState(1994)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == CqlParserK_AND {
		{
			p.SetState(1989)
			p.KwAnd()
		}
		{
			p.SetState(1990)
			p.IfCondition()
		}

		p.SetState(1996)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(2002)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == CqlParserK_OR {
		{
			p.SetState(1997)
			p.KwOr()
		}
		{
			p.SetState(1998)
			p.IfCondition()
		}

		p.SetState(2004)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIfConditionContext is an interface to support dynamic dispatch.
type IIfConditionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ColumnRef() IColumnRefContext
	AllIfConditionValue() []IIfConditionValueContext
	IfConditionValue(i int) IIfConditionValueContext
	OPERATOR_EQ() antlr.TerminalNode
	OPERATOR_LT() antlr.TerminalNode
	OPERATOR_GT() antlr.TerminalNode
	OPERATOR_LTE() antlr.TerminalNode
	OPERATOR_GTE() antlr.TerminalNode
	OPERATOR_NEQ() antlr.TerminalNode
	KwIn() IKwInContext
	SyntaxBracketLr() ISyntaxBracketLrContext
	SyntaxBracketRr() ISyntaxBracketRrContext
	AllSyntaxComma() []ISyntaxCommaContext
	SyntaxComma(i int) ISyntaxCommaContext
	SyntaxBracketLs() ISyntaxBracketLsContext
	SyntaxBracketRs() ISyntaxBracketRsContext
	KwContains() IKwContainsContext
	KwKey() IKwKeyContext
	SyntaxBracketLc() ISyntaxBracketLcContext
	SyntaxBracketRc() ISyntaxBracketRcContext
	KwLike() IKwLikeContext

	// IsIfConditionContext differentiates from other interfaces.
	IsIfConditionContext()
}

type IfConditionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfConditionContext() *IfConditionContext {
	var p = new(IfConditionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_ifCondition
	return p
}

func InitEmptyIfConditionContext(p *IfConditionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_ifCondition
}

func (*IfConditionContext) IsIfConditionContext() {}

func NewIfConditionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfConditionContext {
	var p = new(IfConditionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_ifCondition

	return p
}

func (s *IfConditionContext) GetParser() antlr.Parser { return s.parser }

func (s *IfConditionContext) ColumnRef() IColumnRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnRefContext)
}

func (s *IfConditionContext) AllIfConditionValue() []IIfConditionValueContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIfConditionValueContext); ok {
			len++
		}
	}

	tst := make([]IIfConditionValueContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIfConditionValueContext); ok {
			tst[i] = t.(IIfConditionValueContext)
			i++
		}
	}

	return tst
}

func (s *IfConditionContext) IfConditionValue(i int) IIfConditionValueContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfConditionValueContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfConditionValueContext)
}

func (s *IfConditionContext) OPERATOR_EQ() antlr.TerminalNode {
	return s.GetToken(CqlParserOPERATOR_EQ, 0)
}

func (s *IfConditionContext) OPERATOR_LT() antlr.TerminalNode {
	return s.GetToken(CqlParserOPERATOR_LT, 0)
}

func (s *IfConditionContext) OPERATOR_GT() antlr.TerminalNode {
	return s.GetToken(CqlParserOPERATOR_GT, 0)
}

func (s *IfConditionContext) OPERATOR_LTE() antlr.TerminalNode {
	return s.GetToken(CqlParserOPERATOR_LTE, 0)
}

func (s *IfConditionContext) OPERATOR_GTE() antlr.TerminalNode {
	return s.GetToken(CqlParserOPERATOR_GTE, 0)
}

func (s *IfConditionContext) OPERATOR_NEQ() antlr.TerminalNode {
	return s.GetToken(CqlParserOPERATOR_NEQ, 0)
}

func (s *IfConditionContext) KwIn() IKwInContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwInContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwInContext)
}

func (s *IfConditionContext) SyntaxBracketLr() ISyntaxBracketLrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxBracketLrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxBracketLrContext)
}

func (s *IfConditionContext) SyntaxBracketRr() ISyntaxBracketRrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxBracketRrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxBracketRrContext)
}

func (s *IfConditionContext) AllSyntaxComma() []ISyntaxCommaContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			len++
		}
	}

	tst := make([]ISyntaxCommaContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISyntaxCommaContext); ok {
			tst[i] = t.(ISyntaxCommaContext)
			i++
		}
	}

	return tst
}

func (s *IfConditionContext) SyntaxComma(i int) ISyntaxCommaContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxCommaContext)
}

func (s *IfConditionContext) SyntaxBracketLs() ISyntaxBracketLsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxBracketLsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxBracketLsContext)
}

func (s *IfConditionContext) SyntaxBracketRs() ISyntaxBracketRsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxBracketRsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxBracketRsContext)
}

func (s *IfConditionContext) KwContains() IKwContainsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwContainsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwContainsContext)
}

func (s *IfConditionContext) KwKey() IKwKeyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwKeyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwKeyContext)
}

func (s *IfConditionContext) SyntaxBracketLc() ISyntaxBracketLcContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxBracketLcContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxBracketLcContext)
}

func (s *IfConditionContext) SyntaxBracketRc() ISyntaxBracketRcContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxBracketRcContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxBracketRcContext)
}

func (s *IfConditionContext) KwLike() IKwLikeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwLikeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwLikeContext)
}

func (s *IfConditionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfConditionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfConditionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterIfCondition(s)
	}
}

func (s *IfConditionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitIfCondition(s)
	}
}

func (p *CqlParser) IfCondition() (localctx IIfConditionContext) {
	localctx = NewIfConditionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 250, CqlParserRULE_ifCondition)
	var _la int

	p.SetState(2062)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 164, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2005)
			p.ColumnRef()
		}
		{
			p.SetState(2006)
			_la = p.GetTokenStream().LA(1)

			if !(((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&16252928) != 0) || _la == CqlParserOPERATOR_NEQ) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(2007)
			p.IfConditionValue()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2009)
			p.IfConditionValue()
		}
		{
			p.SetState(2010)
			_la = p.GetTokenStream().LA(1)

			if !(((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&16252928) != 0) || _la == CqlParserOPERATOR_NEQ) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(2011)
			p.ColumnRef()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2013)
			p.ColumnRef()
		}
		{
			p.SetState(2014)
			p.KwIn()
		}
		{
			p.SetState(2015)
			p.SyntaxBracketLr()
		}
		p.SetState(2025)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&72057594037928488) != 0) || ((int64((_la-91)) & ^0x3f) == 0 && ((int64(1)<<(_la-91))&1161264667557889) != 0) || ((int64((_la-196)) & ^0x3f) == 0 && ((int64(1)<<(_la-196))&15097) != 0) {
			{
				p.SetState(2016)
				p.IfConditionValue()
			}
			p.SetState(2022)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == CqlParserCOMMA {
				{
					p.SetState(2017)
					p.SyntaxComma()
				}
				{
					p.SetState(2018)
					p.IfConditionValue()
				}

				p.SetState(2024)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(2027)
			p.SyntaxBracketRr()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2029)
			p.ColumnRef()
		}
		{
			p.SetState(2030)
			p.SyntaxBracketLs()
		}
		{
			p.SetState(2031)
			p.IfConditionValue()
		}
		{
			p.SetState(2032)
			p.SyntaxBracketRs()
		}
		{
			p.SetState(2033)
			_la = p.GetTokenStream().LA(1)

			if !(((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&16252928) != 0) || _la == CqlParserOPERATOR_NEQ) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(2034)
			p.IfConditionValue()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2036)
			p.ColumnRef()
		}
		{
			p.SetState(2037)
			p.KwContains()
		}
		{
			p.SetState(2038)
			p.IfConditionValue()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2040)
			p.ColumnRef()
		}
		{
			p.SetState(2041)
			p.KwContains()
		}
		{
			p.SetState(2042)
			p.KwKey()
		}
		{
			p.SetState(2043)
			p.IfConditionValue()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(2045)
			p.ColumnRef()
		}
		{
			p.SetState(2046)
			p.SyntaxBracketLc()
		}
		{
			p.SetState(2047)
			p.IfConditionValue()
		}
		{
			p.SetState(2048)
			p.SyntaxBracketRc()
		}
		{
			p.SetState(2049)
			_la = p.GetTokenStream().LA(1)

			if !(_la == CqlParserOPERATOR_EQ || _la == CqlParserOPERATOR_NEQ) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(2050)
			p.IfConditionValue()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(2052)
			p.ColumnRef()
		}
		{
			p.SetState(2053)
			p.KwLike()
		}
		{
			p.SetState(2054)
			p.IfConditionValue()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(2056)
			p.ColumnRef()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(2057)
			p.ColumnRef()
		}
		{
			p.SetState(2058)
			p.SyntaxBracketLs()
		}
		{
			p.SetState(2059)
			p.IfConditionValue()
		}
		{
			p.SetState(2060)
			p.SyntaxBracketRs()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIfConditionValueContext is an interface to support dynamic dispatch.
type IIfConditionValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Constant() IConstantContext
	OBJECT_NAME() antlr.TerminalNode
	FunctionCall() IFunctionCallContext
	AssignmentSet() IAssignmentSetContext
	AssignmentList() IAssignmentListContext
	AssignmentMap() IAssignmentMapContext

	// IsIfConditionValueContext differentiates from other interfaces.
	IsIfConditionValueContext()
}

type IfConditionValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfConditionValueContext() *IfConditionValueContext {
	var p = new(IfConditionValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_ifConditionValue
	return p
}

func InitEmptyIfConditionValueContext(p *IfConditionValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_ifConditionValue
}

func (*IfConditionValueContext) IsIfConditionValueContext() {}

func NewIfConditionValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfConditionValueContext {
	var p = new(IfConditionValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_ifConditionValue

	return p
}

func (s *IfConditionValueContext) GetParser() antlr.Parser { return s.parser }

func (s *IfConditionValueContext) Constant() IConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *IfConditionValueContext) OBJECT_NAME() antlr.TerminalNode {
	return s.GetToken(CqlParserOBJECT_NAME, 0)
}

func (s *IfConditionValueContext) FunctionCall() IFunctionCallContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionCallContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionCallContext)
}

func (s *IfConditionValueContext) AssignmentSet() IAssignmentSetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentSetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentSetContext)
}

func (s *IfConditionValueContext) AssignmentList() IAssignmentListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentListContext)
}

func (s *IfConditionValueContext) AssignmentMap() IAssignmentMapContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentMapContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentMapContext)
}

func (s *IfConditionValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfConditionValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfConditionValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterIfConditionValue(s)
	}
}

func (s *IfConditionValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitIfConditionValue(s)
	}
}

func (p *CqlParser) IfConditionValue() (localctx IIfConditionValueContext) {
	localctx = NewIfConditionValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 252, CqlParserRULE_ifConditionValue)
	p.SetState(2070)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 165, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2064)
			p.Constant()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2065)
			p.Match(CqlParserOBJECT_NAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2066)
			p.FunctionCall()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2067)
			p.AssignmentSet()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2068)
			p.AssignmentList()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2069)
			p.AssignmentMap()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssignmentsContext is an interface to support dynamic dispatch.
type IAssignmentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllAssignmentElement() []IAssignmentElementContext
	AssignmentElement(i int) IAssignmentElementContext
	AllSyntaxComma() []ISyntaxCommaContext
	SyntaxComma(i int) ISyntaxCommaContext

	// IsAssignmentsContext differentiates from other interfaces.
	IsAssignmentsContext()
}

type AssignmentsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentsContext() *AssignmentsContext {
	var p = new(AssignmentsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_assignments
	return p
}

func InitEmptyAssignmentsContext(p *AssignmentsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_assignments
}

func (*AssignmentsContext) IsAssignmentsContext() {}

func NewAssignmentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentsContext {
	var p = new(AssignmentsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_assignments

	return p
}

func (s *AssignmentsContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentsContext) AllAssignmentElement() []IAssignmentElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAssignmentElementContext); ok {
			len++
		}
	}

	tst := make([]IAssignmentElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAssignmentElementContext); ok {
			tst[i] = t.(IAssignmentElementContext)
			i++
		}
	}

	return tst
}

func (s *AssignmentsContext) AssignmentElement(i int) IAssignmentElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentElementContext)
}

func (s *AssignmentsContext) AllSyntaxComma() []ISyntaxCommaContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			len++
		}
	}

	tst := make([]ISyntaxCommaContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISyntaxCommaContext); ok {
			tst[i] = t.(ISyntaxCommaContext)
			i++
		}
	}

	return tst
}

func (s *AssignmentsContext) SyntaxComma(i int) ISyntaxCommaContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxCommaContext)
}

func (s *AssignmentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterAssignments(s)
	}
}

func (s *AssignmentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitAssignments(s)
	}
}

func (p *CqlParser) Assignments() (localctx IAssignmentsContext) {
	localctx = NewAssignmentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 254, CqlParserRULE_assignments)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2072)
		p.AssignmentElement()
	}

	p.SetState(2078)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == CqlParserCOMMA {
		{
			p.SetState(2073)
			p.SyntaxComma()
		}
		{
			p.SetState(2074)
			p.AssignmentElement()
		}

		p.SetState(2080)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssignmentElementContext is an interface to support dynamic dispatch.
type IAssignmentElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllColumnRef() []IColumnRefContext
	ColumnRef(i int) IColumnRefContext
	OPERATOR_EQ() antlr.TerminalNode
	Constant() IConstantContext
	AssignmentMap() IAssignmentMapContext
	AssignmentSet() IAssignmentSetContext
	AssignmentList() IAssignmentListContext
	FunctionCall() IFunctionCallContext
	DecimalLiteral() IDecimalLiteralContext
	PLUS() antlr.TerminalNode
	MINUS() antlr.TerminalNode
	SyntaxBracketLs() ISyntaxBracketLsContext
	AssignmentIndexKey() IAssignmentIndexKeyContext
	SyntaxBracketRs() ISyntaxBracketRsContext

	// IsAssignmentElementContext differentiates from other interfaces.
	IsAssignmentElementContext()
}

type AssignmentElementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentElementContext() *AssignmentElementContext {
	var p = new(AssignmentElementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_assignmentElement
	return p
}

func InitEmptyAssignmentElementContext(p *AssignmentElementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_assignmentElement
}

func (*AssignmentElementContext) IsAssignmentElementContext() {}

func NewAssignmentElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentElementContext {
	var p = new(AssignmentElementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_assignmentElement

	return p
}

func (s *AssignmentElementContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentElementContext) AllColumnRef() []IColumnRefContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnRefContext); ok {
			len++
		}
	}

	tst := make([]IColumnRefContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnRefContext); ok {
			tst[i] = t.(IColumnRefContext)
			i++
		}
	}

	return tst
}

func (s *AssignmentElementContext) ColumnRef(i int) IColumnRefContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnRefContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnRefContext)
}

func (s *AssignmentElementContext) OPERATOR_EQ() antlr.TerminalNode {
	return s.GetToken(CqlParserOPERATOR_EQ, 0)
}

func (s *AssignmentElementContext) Constant() IConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *AssignmentElementContext) AssignmentMap() IAssignmentMapContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentMapContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentMapContext)
}

func (s *AssignmentElementContext) AssignmentSet() IAssignmentSetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentSetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentSetContext)
}

func (s *AssignmentElementContext) AssignmentList() IAssignmentListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentListContext)
}

func (s *AssignmentElementContext) FunctionCall() IFunctionCallContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionCallContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionCallContext)
}

func (s *AssignmentElementContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *AssignmentElementContext) PLUS() antlr.TerminalNode {
	return s.GetToken(CqlParserPLUS, 0)
}

func (s *AssignmentElementContext) MINUS() antlr.TerminalNode {
	return s.GetToken(CqlParserMINUS, 0)
}

func (s *AssignmentElementContext) SyntaxBracketLs() ISyntaxBracketLsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxBracketLsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxBracketLsContext)
}

func (s *AssignmentElementContext) AssignmentIndexKey() IAssignmentIndexKeyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentIndexKeyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentIndexKeyContext)
}

func (s *AssignmentElementContext) SyntaxBracketRs() ISyntaxBracketRsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxBracketRsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxBracketRsContext)
}

func (s *AssignmentElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterAssignmentElement(s)
	}
}

func (s *AssignmentElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitAssignmentElement(s)
	}
}

func (p *CqlParser) AssignmentElement() (localctx IAssignmentElementContext) {
	localctx = NewAssignmentElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 256, CqlParserRULE_assignmentElement)
	var _la int

	p.SetState(2139)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 168, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2081)
			p.ColumnRef()
		}
		{
			p.SetState(2082)
			p.Match(CqlParserOPERATOR_EQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2088)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 167, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(2083)
				p.Constant()
			}

		case 2:
			{
				p.SetState(2084)
				p.AssignmentMap()
			}

		case 3:
			{
				p.SetState(2085)
				p.AssignmentSet()
			}

		case 4:
			{
				p.SetState(2086)
				p.AssignmentList()
			}

		case 5:
			{
				p.SetState(2087)
				p.FunctionCall()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2090)
			p.ColumnRef()
		}
		{
			p.SetState(2091)
			p.Match(CqlParserOPERATOR_EQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2092)
			p.ColumnRef()
		}
		{
			p.SetState(2093)
			_la = p.GetTokenStream().LA(1)

			if !(_la == CqlParserPLUS || _la == CqlParserMINUS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(2094)
			p.DecimalLiteral()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2096)
			p.ColumnRef()
		}
		{
			p.SetState(2097)
			p.Match(CqlParserOPERATOR_EQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2098)
			p.ColumnRef()
		}
		{
			p.SetState(2099)
			_la = p.GetTokenStream().LA(1)

			if !(_la == CqlParserPLUS || _la == CqlParserMINUS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(2100)
			p.AssignmentSet()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2102)
			p.ColumnRef()
		}
		{
			p.SetState(2103)
			p.Match(CqlParserOPERATOR_EQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2104)
			p.AssignmentSet()
		}
		{
			p.SetState(2105)
			_la = p.GetTokenStream().LA(1)

			if !(_la == CqlParserPLUS || _la == CqlParserMINUS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(2106)
			p.ColumnRef()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2108)
			p.ColumnRef()
		}
		{
			p.SetState(2109)
			p.Match(CqlParserOPERATOR_EQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2110)
			p.ColumnRef()
		}
		{
			p.SetState(2111)
			_la = p.GetTokenStream().LA(1)

			if !(_la == CqlParserPLUS || _la == CqlParserMINUS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(2112)
			p.AssignmentMap()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2114)
			p.ColumnRef()
		}
		{
			p.SetState(2115)
			p.Match(CqlParserOPERATOR_EQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2116)
			p.AssignmentMap()
		}
		{
			p.SetState(2117)
			_la = p.GetTokenStream().LA(1)

			if !(_la == CqlParserPLUS || _la == CqlParserMINUS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(2118)
			p.ColumnRef()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(2120)
			p.ColumnRef()
		}
		{
			p.SetState(2121)
			p.Match(CqlParserOPERATOR_EQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2122)
			p.ColumnRef()
		}
		{
			p.SetState(2123)
			_la = p.GetTokenStream().LA(1)

			if !(_la == CqlParserPLUS || _la == CqlParserMINUS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(2124)
			p.AssignmentList()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(2126)
			p.ColumnRef()
		}
		{
			p.SetState(2127)
			p.Match(CqlParserOPERATOR_EQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2128)
			p.AssignmentList()
		}
		{
			p.SetState(2129)
			_la = p.GetTokenStream().LA(1)

			if !(_la == CqlParserPLUS || _la == CqlParserMINUS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(2130)
			p.ColumnRef()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(2132)
			p.ColumnRef()
		}
		{
			p.SetState(2133)
			p.SyntaxBracketLs()
		}
		{
			p.SetState(2134)
			p.AssignmentIndexKey()
		}
		{
			p.SetState(2135)
			p.SyntaxBracketRs()
		}
		{
			p.SetState(2136)
			p.Match(CqlParserOPERATOR_EQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2137)
			p.Constant()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssignmentIndexKeyContext is an interface to support dynamic dispatch.
type IAssignmentIndexKeyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DecimalLiteral() IDecimalLiteralContext
	StringLiteral() IStringLiteralContext
	BooleanLiteral() IBooleanLiteralContext
	KwNull() IKwNullContext

	// IsAssignmentIndexKeyContext differentiates from other interfaces.
	IsAssignmentIndexKeyContext()
}

type AssignmentIndexKeyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentIndexKeyContext() *AssignmentIndexKeyContext {
	var p = new(AssignmentIndexKeyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_assignmentIndexKey
	return p
}

func InitEmptyAssignmentIndexKeyContext(p *AssignmentIndexKeyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_assignmentIndexKey
}

func (*AssignmentIndexKeyContext) IsAssignmentIndexKeyContext() {}

func NewAssignmentIndexKeyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentIndexKeyContext {
	var p = new(AssignmentIndexKeyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_assignmentIndexKey

	return p
}

func (s *AssignmentIndexKeyContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentIndexKeyContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *AssignmentIndexKeyContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *AssignmentIndexKeyContext) BooleanLiteral() IBooleanLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanLiteralContext)
}

func (s *AssignmentIndexKeyContext) KwNull() IKwNullContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwNullContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwNullContext)
}

func (s *AssignmentIndexKeyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentIndexKeyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentIndexKeyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterAssignmentIndexKey(s)
	}
}

func (s *AssignmentIndexKeyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitAssignmentIndexKey(s)
	}
}

func (p *CqlParser) AssignmentIndexKey() (localctx IAssignmentIndexKeyContext) {
	localctx = NewAssignmentIndexKeyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 258, CqlParserRULE_assignmentIndexKey)
	p.SetState(2145)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case CqlParserDECIMAL_LITERAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2141)
			p.DecimalLiteral()
		}

	case CqlParserSTRING_LITERAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2142)
			p.StringLiteral()
		}

	case CqlParserK_FALSE, CqlParserK_TRUE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2143)
			p.BooleanLiteral()
		}

	case CqlParserK_NULL:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2144)
			p.KwNull()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssignmentSetContext is an interface to support dynamic dispatch.
type IAssignmentSetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SyntaxBracketLc() ISyntaxBracketLcContext
	SyntaxBracketRc() ISyntaxBracketRcContext
	AllAssignmentSetElement() []IAssignmentSetElementContext
	AssignmentSetElement(i int) IAssignmentSetElementContext
	AllSyntaxComma() []ISyntaxCommaContext
	SyntaxComma(i int) ISyntaxCommaContext

	// IsAssignmentSetContext differentiates from other interfaces.
	IsAssignmentSetContext()
}

type AssignmentSetContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentSetContext() *AssignmentSetContext {
	var p = new(AssignmentSetContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_assignmentSet
	return p
}

func InitEmptyAssignmentSetContext(p *AssignmentSetContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_assignmentSet
}

func (*AssignmentSetContext) IsAssignmentSetContext() {}

func NewAssignmentSetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentSetContext {
	var p = new(AssignmentSetContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_assignmentSet

	return p
}

func (s *AssignmentSetContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentSetContext) SyntaxBracketLc() ISyntaxBracketLcContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxBracketLcContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxBracketLcContext)
}

func (s *AssignmentSetContext) SyntaxBracketRc() ISyntaxBracketRcContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxBracketRcContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxBracketRcContext)
}

func (s *AssignmentSetContext) AllAssignmentSetElement() []IAssignmentSetElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAssignmentSetElementContext); ok {
			len++
		}
	}

	tst := make([]IAssignmentSetElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAssignmentSetElementContext); ok {
			tst[i] = t.(IAssignmentSetElementContext)
			i++
		}
	}

	return tst
}

func (s *AssignmentSetContext) AssignmentSetElement(i int) IAssignmentSetElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentSetElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentSetElementContext)
}

func (s *AssignmentSetContext) AllSyntaxComma() []ISyntaxCommaContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			len++
		}
	}

	tst := make([]ISyntaxCommaContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISyntaxCommaContext); ok {
			tst[i] = t.(ISyntaxCommaContext)
			i++
		}
	}

	return tst
}

func (s *AssignmentSetContext) SyntaxComma(i int) ISyntaxCommaContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxCommaContext)
}

func (s *AssignmentSetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentSetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentSetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterAssignmentSet(s)
	}
}

func (s *AssignmentSetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitAssignmentSet(s)
	}
}

func (p *CqlParser) AssignmentSet() (localctx IAssignmentSetContext) {
	localctx = NewAssignmentSetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 260, CqlParserRULE_assignmentSet)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2147)
		p.SyntaxBracketLc()
	}
	p.SetState(2157)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&72057594037928488) != 0) || _la == CqlParserK_NULL || _la == CqlParserK_TRUE || ((int64((_la-196)) & ^0x3f) == 0 && ((int64(1)<<(_la-196))&11001) != 0) {
		{
			p.SetState(2148)
			p.AssignmentSetElement()
		}
		p.SetState(2154)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == CqlParserCOMMA {
			{
				p.SetState(2149)
				p.SyntaxComma()
			}
			{
				p.SetState(2150)
				p.AssignmentSetElement()
			}

			p.SetState(2156)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(2159)
		p.SyntaxBracketRc()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssignmentSetElementContext is an interface to support dynamic dispatch.
type IAssignmentSetElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Constant() IConstantContext
	AssignmentSet() IAssignmentSetContext
	AssignmentList() IAssignmentListContext

	// IsAssignmentSetElementContext differentiates from other interfaces.
	IsAssignmentSetElementContext()
}

type AssignmentSetElementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentSetElementContext() *AssignmentSetElementContext {
	var p = new(AssignmentSetElementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_assignmentSetElement
	return p
}

func InitEmptyAssignmentSetElementContext(p *AssignmentSetElementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_assignmentSetElement
}

func (*AssignmentSetElementContext) IsAssignmentSetElementContext() {}

func NewAssignmentSetElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentSetElementContext {
	var p = new(AssignmentSetElementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_assignmentSetElement

	return p
}

func (s *AssignmentSetElementContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentSetElementContext) Constant() IConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *AssignmentSetElementContext) AssignmentSet() IAssignmentSetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentSetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentSetContext)
}

func (s *AssignmentSetElementContext) AssignmentList() IAssignmentListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentListContext)
}

func (s *AssignmentSetElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentSetElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentSetElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterAssignmentSetElement(s)
	}
}

func (s *AssignmentSetElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitAssignmentSetElement(s)
	}
}

func (p *CqlParser) AssignmentSetElement() (localctx IAssignmentSetElementContext) {
	localctx = NewAssignmentSetElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 262, CqlParserRULE_assignmentSetElement)
	p.SetState(2164)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case CqlParserCOLON, CqlParserK_FALSE, CqlParserK_NULL, CqlParserK_TRUE, CqlParserK_EMPTY, CqlParserCODE_BLOCK, CqlParserSTRING_LITERAL, CqlParserDECIMAL_LITERAL, CqlParserFLOAT_LITERAL, CqlParserHEXADECIMAL_LITERAL, CqlParserQMARK, CqlParserDURATION_LITERAL, CqlParserUUID:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2161)
			p.Constant()
		}

	case CqlParserLC_BRACKET:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2162)
			p.AssignmentSet()
		}

	case CqlParserLS_BRACKET:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2163)
			p.AssignmentList()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssignmentMapContext is an interface to support dynamic dispatch.
type IAssignmentMapContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SyntaxBracketLc() ISyntaxBracketLcContext
	SyntaxBracketRc() ISyntaxBracketRcContext
	AllAssignmentMapEntry() []IAssignmentMapEntryContext
	AssignmentMapEntry(i int) IAssignmentMapEntryContext
	AllSyntaxComma() []ISyntaxCommaContext
	SyntaxComma(i int) ISyntaxCommaContext

	// IsAssignmentMapContext differentiates from other interfaces.
	IsAssignmentMapContext()
}

type AssignmentMapContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentMapContext() *AssignmentMapContext {
	var p = new(AssignmentMapContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_assignmentMap
	return p
}

func InitEmptyAssignmentMapContext(p *AssignmentMapContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_assignmentMap
}

func (*AssignmentMapContext) IsAssignmentMapContext() {}

func NewAssignmentMapContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentMapContext {
	var p = new(AssignmentMapContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_assignmentMap

	return p
}

func (s *AssignmentMapContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentMapContext) SyntaxBracketLc() ISyntaxBracketLcContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxBracketLcContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxBracketLcContext)
}

func (s *AssignmentMapContext) SyntaxBracketRc() ISyntaxBracketRcContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxBracketRcContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxBracketRcContext)
}

func (s *AssignmentMapContext) AllAssignmentMapEntry() []IAssignmentMapEntryContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAssignmentMapEntryContext); ok {
			len++
		}
	}

	tst := make([]IAssignmentMapEntryContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAssignmentMapEntryContext); ok {
			tst[i] = t.(IAssignmentMapEntryContext)
			i++
		}
	}

	return tst
}

func (s *AssignmentMapContext) AssignmentMapEntry(i int) IAssignmentMapEntryContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentMapEntryContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentMapEntryContext)
}

func (s *AssignmentMapContext) AllSyntaxComma() []ISyntaxCommaContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			len++
		}
	}

	tst := make([]ISyntaxCommaContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISyntaxCommaContext); ok {
			tst[i] = t.(ISyntaxCommaContext)
			i++
		}
	}

	return tst
}

func (s *AssignmentMapContext) SyntaxComma(i int) ISyntaxCommaContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxCommaContext)
}

func (s *AssignmentMapContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentMapContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentMapContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterAssignmentMap(s)
	}
}

func (s *AssignmentMapContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitAssignmentMap(s)
	}
}

func (p *CqlParser) AssignmentMap() (localctx IAssignmentMapContext) {
	localctx = NewAssignmentMapContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 264, CqlParserRULE_assignmentMap)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2166)
		p.SyntaxBracketLc()
	}
	p.SetState(2176)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&72057594037928488) != 0) || _la == CqlParserK_NULL || _la == CqlParserK_TRUE || ((int64((_la-196)) & ^0x3f) == 0 && ((int64(1)<<(_la-196))&11001) != 0) {
		{
			p.SetState(2167)
			p.AssignmentMapEntry()
		}
		p.SetState(2173)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == CqlParserCOMMA {
			{
				p.SetState(2168)
				p.SyntaxComma()
			}
			{
				p.SetState(2169)
				p.AssignmentMapEntry()
			}

			p.SetState(2175)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(2178)
		p.SyntaxBracketRc()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssignmentMapEntryContext is an interface to support dynamic dispatch.
type IAssignmentMapEntryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AssignmentMapKey() IAssignmentMapKeyContext
	SyntaxColon() ISyntaxColonContext
	AssignmentMapValue() IAssignmentMapValueContext

	// IsAssignmentMapEntryContext differentiates from other interfaces.
	IsAssignmentMapEntryContext()
}

type AssignmentMapEntryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentMapEntryContext() *AssignmentMapEntryContext {
	var p = new(AssignmentMapEntryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_assignmentMapEntry
	return p
}

func InitEmptyAssignmentMapEntryContext(p *AssignmentMapEntryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_assignmentMapEntry
}

func (*AssignmentMapEntryContext) IsAssignmentMapEntryContext() {}

func NewAssignmentMapEntryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentMapEntryContext {
	var p = new(AssignmentMapEntryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_assignmentMapEntry

	return p
}

func (s *AssignmentMapEntryContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentMapEntryContext) AssignmentMapKey() IAssignmentMapKeyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentMapKeyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentMapKeyContext)
}

func (s *AssignmentMapEntryContext) SyntaxColon() ISyntaxColonContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxColonContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxColonContext)
}

func (s *AssignmentMapEntryContext) AssignmentMapValue() IAssignmentMapValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentMapValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentMapValueContext)
}

func (s *AssignmentMapEntryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentMapEntryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentMapEntryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterAssignmentMapEntry(s)
	}
}

func (s *AssignmentMapEntryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitAssignmentMapEntry(s)
	}
}

func (p *CqlParser) AssignmentMapEntry() (localctx IAssignmentMapEntryContext) {
	localctx = NewAssignmentMapEntryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 266, CqlParserRULE_assignmentMapEntry)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2180)
		p.AssignmentMapKey()
	}
	{
		p.SetState(2181)
		p.SyntaxColon()
	}
	{
		p.SetState(2182)
		p.AssignmentMapValue()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssignmentMapKeyContext is an interface to support dynamic dispatch.
type IAssignmentMapKeyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Constant() IConstantContext
	AssignmentList() IAssignmentListContext
	AssignmentSet() IAssignmentSetContext

	// IsAssignmentMapKeyContext differentiates from other interfaces.
	IsAssignmentMapKeyContext()
}

type AssignmentMapKeyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentMapKeyContext() *AssignmentMapKeyContext {
	var p = new(AssignmentMapKeyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_assignmentMapKey
	return p
}

func InitEmptyAssignmentMapKeyContext(p *AssignmentMapKeyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_assignmentMapKey
}

func (*AssignmentMapKeyContext) IsAssignmentMapKeyContext() {}

func NewAssignmentMapKeyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentMapKeyContext {
	var p = new(AssignmentMapKeyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_assignmentMapKey

	return p
}

func (s *AssignmentMapKeyContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentMapKeyContext) Constant() IConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *AssignmentMapKeyContext) AssignmentList() IAssignmentListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentListContext)
}

func (s *AssignmentMapKeyContext) AssignmentSet() IAssignmentSetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentSetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentSetContext)
}

func (s *AssignmentMapKeyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentMapKeyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentMapKeyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterAssignmentMapKey(s)
	}
}

func (s *AssignmentMapKeyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitAssignmentMapKey(s)
	}
}

func (p *CqlParser) AssignmentMapKey() (localctx IAssignmentMapKeyContext) {
	localctx = NewAssignmentMapKeyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 268, CqlParserRULE_assignmentMapKey)
	p.SetState(2187)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case CqlParserCOLON, CqlParserK_FALSE, CqlParserK_NULL, CqlParserK_TRUE, CqlParserK_EMPTY, CqlParserCODE_BLOCK, CqlParserSTRING_LITERAL, CqlParserDECIMAL_LITERAL, CqlParserFLOAT_LITERAL, CqlParserHEXADECIMAL_LITERAL, CqlParserQMARK, CqlParserDURATION_LITERAL, CqlParserUUID:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2184)
			p.Constant()
		}

	case CqlParserLS_BRACKET:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2185)
			p.AssignmentList()
		}

	case CqlParserLC_BRACKET:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2186)
			p.AssignmentSet()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssignmentMapValueContext is an interface to support dynamic dispatch.
type IAssignmentMapValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Constant() IConstantContext
	AssignmentSet() IAssignmentSetContext
	AssignmentList() IAssignmentListContext
	AssignmentMap() IAssignmentMapContext

	// IsAssignmentMapValueContext differentiates from other interfaces.
	IsAssignmentMapValueContext()
}

type AssignmentMapValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentMapValueContext() *AssignmentMapValueContext {
	var p = new(AssignmentMapValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_assignmentMapValue
	return p
}

func InitEmptyAssignmentMapValueContext(p *AssignmentMapValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_assignmentMapValue
}

func (*AssignmentMapValueContext) IsAssignmentMapValueContext() {}

func NewAssignmentMapValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentMapValueContext {
	var p = new(AssignmentMapValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_assignmentMapValue

	return p
}

func (s *AssignmentMapValueContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentMapValueContext) Constant() IConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *AssignmentMapValueContext) AssignmentSet() IAssignmentSetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentSetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentSetContext)
}

func (s *AssignmentMapValueContext) AssignmentList() IAssignmentListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentListContext)
}

func (s *AssignmentMapValueContext) AssignmentMap() IAssignmentMapContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentMapContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentMapContext)
}

func (s *AssignmentMapValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentMapValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentMapValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterAssignmentMapValue(s)
	}
}

func (s *AssignmentMapValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitAssignmentMapValue(s)
	}
}

func (p *CqlParser) AssignmentMapValue() (localctx IAssignmentMapValueContext) {
	localctx = NewAssignmentMapValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 270, CqlParserRULE_assignmentMapValue)
	p.SetState(2193)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 176, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2189)
			p.Constant()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2190)
			p.AssignmentSet()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2191)
			p.AssignmentList()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2192)
			p.AssignmentMap()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssignmentListContext is an interface to support dynamic dispatch.
type IAssignmentListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SyntaxBracketLs() ISyntaxBracketLsContext
	SyntaxBracketRs() ISyntaxBracketRsContext
	AllAssignmentListElement() []IAssignmentListElementContext
	AssignmentListElement(i int) IAssignmentListElementContext
	AllSyntaxComma() []ISyntaxCommaContext
	SyntaxComma(i int) ISyntaxCommaContext

	// IsAssignmentListContext differentiates from other interfaces.
	IsAssignmentListContext()
}

type AssignmentListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentListContext() *AssignmentListContext {
	var p = new(AssignmentListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_assignmentList
	return p
}

func InitEmptyAssignmentListContext(p *AssignmentListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_assignmentList
}

func (*AssignmentListContext) IsAssignmentListContext() {}

func NewAssignmentListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentListContext {
	var p = new(AssignmentListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_assignmentList

	return p
}

func (s *AssignmentListContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentListContext) SyntaxBracketLs() ISyntaxBracketLsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxBracketLsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxBracketLsContext)
}

func (s *AssignmentListContext) SyntaxBracketRs() ISyntaxBracketRsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxBracketRsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxBracketRsContext)
}

func (s *AssignmentListContext) AllAssignmentListElement() []IAssignmentListElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAssignmentListElementContext); ok {
			len++
		}
	}

	tst := make([]IAssignmentListElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAssignmentListElementContext); ok {
			tst[i] = t.(IAssignmentListElementContext)
			i++
		}
	}

	return tst
}

func (s *AssignmentListContext) AssignmentListElement(i int) IAssignmentListElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentListElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentListElementContext)
}

func (s *AssignmentListContext) AllSyntaxComma() []ISyntaxCommaContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			len++
		}
	}

	tst := make([]ISyntaxCommaContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISyntaxCommaContext); ok {
			tst[i] = t.(ISyntaxCommaContext)
			i++
		}
	}

	return tst
}

func (s *AssignmentListContext) SyntaxComma(i int) ISyntaxCommaContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxCommaContext)
}

func (s *AssignmentListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterAssignmentList(s)
	}
}

func (s *AssignmentListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitAssignmentList(s)
	}
}

func (p *CqlParser) AssignmentList() (localctx IAssignmentListContext) {
	localctx = NewAssignmentListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 272, CqlParserRULE_assignmentList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2195)
		p.SyntaxBracketLs()
	}
	p.SetState(2205)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&72057594037928488) != 0) || _la == CqlParserK_NULL || _la == CqlParserK_TRUE || ((int64((_la-196)) & ^0x3f) == 0 && ((int64(1)<<(_la-196))&11001) != 0) {
		{
			p.SetState(2196)
			p.AssignmentListElement()
		}
		p.SetState(2202)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == CqlParserCOMMA {
			{
				p.SetState(2197)
				p.SyntaxComma()
			}
			{
				p.SetState(2198)
				p.AssignmentListElement()
			}

			p.SetState(2204)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(2207)
		p.SyntaxBracketRs()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssignmentListElementContext is an interface to support dynamic dispatch.
type IAssignmentListElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Constant() IConstantContext
	AssignmentSet() IAssignmentSetContext
	AssignmentList() IAssignmentListContext
	AssignmentMap() IAssignmentMapContext

	// IsAssignmentListElementContext differentiates from other interfaces.
	IsAssignmentListElementContext()
}

type AssignmentListElementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentListElementContext() *AssignmentListElementContext {
	var p = new(AssignmentListElementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_assignmentListElement
	return p
}

func InitEmptyAssignmentListElementContext(p *AssignmentListElementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_assignmentListElement
}

func (*AssignmentListElementContext) IsAssignmentListElementContext() {}

func NewAssignmentListElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentListElementContext {
	var p = new(AssignmentListElementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_assignmentListElement

	return p
}

func (s *AssignmentListElementContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentListElementContext) Constant() IConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *AssignmentListElementContext) AssignmentSet() IAssignmentSetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentSetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentSetContext)
}

func (s *AssignmentListElementContext) AssignmentList() IAssignmentListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentListContext)
}

func (s *AssignmentListElementContext) AssignmentMap() IAssignmentMapContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentMapContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentMapContext)
}

func (s *AssignmentListElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentListElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentListElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterAssignmentListElement(s)
	}
}

func (s *AssignmentListElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitAssignmentListElement(s)
	}
}

func (p *CqlParser) AssignmentListElement() (localctx IAssignmentListElementContext) {
	localctx = NewAssignmentListElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 274, CqlParserRULE_assignmentListElement)
	p.SetState(2213)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 179, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2209)
			p.Constant()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2210)
			p.AssignmentSet()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2211)
			p.AssignmentList()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2212)
			p.AssignmentMap()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssignmentTupleContext is an interface to support dynamic dispatch.
type IAssignmentTupleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SyntaxBracketLr() ISyntaxBracketLrContext
	SyntaxBracketRr() ISyntaxBracketRrContext
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllSyntaxComma() []ISyntaxCommaContext
	SyntaxComma(i int) ISyntaxCommaContext

	// IsAssignmentTupleContext differentiates from other interfaces.
	IsAssignmentTupleContext()
}

type AssignmentTupleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentTupleContext() *AssignmentTupleContext {
	var p = new(AssignmentTupleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_assignmentTuple
	return p
}

func InitEmptyAssignmentTupleContext(p *AssignmentTupleContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_assignmentTuple
}

func (*AssignmentTupleContext) IsAssignmentTupleContext() {}

func NewAssignmentTupleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentTupleContext {
	var p = new(AssignmentTupleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_assignmentTuple

	return p
}

func (s *AssignmentTupleContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentTupleContext) SyntaxBracketLr() ISyntaxBracketLrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxBracketLrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxBracketLrContext)
}

func (s *AssignmentTupleContext) SyntaxBracketRr() ISyntaxBracketRrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxBracketRrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxBracketRrContext)
}

func (s *AssignmentTupleContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *AssignmentTupleContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *AssignmentTupleContext) AllSyntaxComma() []ISyntaxCommaContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			len++
		}
	}

	tst := make([]ISyntaxCommaContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISyntaxCommaContext); ok {
			tst[i] = t.(ISyntaxCommaContext)
			i++
		}
	}

	return tst
}

func (s *AssignmentTupleContext) SyntaxComma(i int) ISyntaxCommaContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxCommaContext)
}

func (s *AssignmentTupleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentTupleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentTupleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterAssignmentTuple(s)
	}
}

func (s *AssignmentTupleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitAssignmentTuple(s)
	}
}

func (p *CqlParser) AssignmentTuple() (localctx IAssignmentTupleContext) {
	localctx = NewAssignmentTupleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 276, CqlParserRULE_assignmentTuple)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2215)
		p.SyntaxBracketLr()
	}

	{
		p.SetState(2216)
		p.Expression()
	}
	p.SetState(2222)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == CqlParserCOMMA {
		{
			p.SetState(2217)
			p.SyntaxComma()
		}
		{
			p.SetState(2218)
			p.Expression()
		}

		p.SetState(2224)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

	{
		p.SetState(2225)
		p.SyntaxBracketRr()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInsertContext is an interface to support dynamic dispatch.
type IInsertContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwInsert() IKwInsertContext
	KwInto() IKwIntoContext
	Table() ITableContext
	InsertValuesSpec() IInsertValuesSpecContext
	BeginBatch() IBeginBatchContext
	Keyspace() IKeyspaceContext
	DOT() antlr.TerminalNode
	InsertColumnSpec() IInsertColumnSpecContext
	IfNotExist() IIfNotExistContext
	UsingTtlTimestamp() IUsingTtlTimestampContext

	// IsInsertContext differentiates from other interfaces.
	IsInsertContext()
}

type InsertContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInsertContext() *InsertContext {
	var p = new(InsertContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_insert
	return p
}

func InitEmptyInsertContext(p *InsertContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_insert
}

func (*InsertContext) IsInsertContext() {}

func NewInsertContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InsertContext {
	var p = new(InsertContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_insert

	return p
}

func (s *InsertContext) GetParser() antlr.Parser { return s.parser }

func (s *InsertContext) KwInsert() IKwInsertContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwInsertContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwInsertContext)
}

func (s *InsertContext) KwInto() IKwIntoContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwIntoContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwIntoContext)
}

func (s *InsertContext) Table() ITableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableContext)
}

func (s *InsertContext) InsertValuesSpec() IInsertValuesSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsertValuesSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsertValuesSpecContext)
}

func (s *InsertContext) BeginBatch() IBeginBatchContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBeginBatchContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBeginBatchContext)
}

func (s *InsertContext) Keyspace() IKeyspaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyspaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyspaceContext)
}

func (s *InsertContext) DOT() antlr.TerminalNode {
	return s.GetToken(CqlParserDOT, 0)
}

func (s *InsertContext) InsertColumnSpec() IInsertColumnSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsertColumnSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsertColumnSpecContext)
}

func (s *InsertContext) IfNotExist() IIfNotExistContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistContext)
}

func (s *InsertContext) UsingTtlTimestamp() IUsingTtlTimestampContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUsingTtlTimestampContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUsingTtlTimestampContext)
}

func (s *InsertContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InsertContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InsertContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterInsert(s)
	}
}

func (s *InsertContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitInsert(s)
	}
}

func (p *CqlParser) Insert() (localctx IInsertContext) {
	localctx = NewInsertContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 278, CqlParserRULE_insert)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2228)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CqlParserK_BEGIN {
		{
			p.SetState(2227)
			p.BeginBatch()
		}

	}
	{
		p.SetState(2230)
		p.KwInsert()
	}
	{
		p.SetState(2231)
		p.KwInto()
	}
	p.SetState(2235)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 182, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2232)
			p.Keyspace()
		}
		{
			p.SetState(2233)
			p.Match(CqlParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(2237)
		p.Table()
	}
	p.SetState(2239)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CqlParserLR_BRACKET {
		{
			p.SetState(2238)
			p.InsertColumnSpec()
		}

	}
	{
		p.SetState(2241)
		p.InsertValuesSpec()
	}
	p.SetState(2243)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CqlParserK_IF {
		{
			p.SetState(2242)
			p.IfNotExist()
		}

	}
	p.SetState(2246)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CqlParserK_USING {
		{
			p.SetState(2245)
			p.UsingTtlTimestamp()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUsingTtlTimestampContext is an interface to support dynamic dispatch.
type IUsingTtlTimestampContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwUsing() IKwUsingContext
	Ttl() ITtlContext
	KwAnd() IKwAndContext
	Timestamp() ITimestampContext
	KwTimeout() IKwTimeoutContext
	Constant() IConstantContext

	// IsUsingTtlTimestampContext differentiates from other interfaces.
	IsUsingTtlTimestampContext()
}

type UsingTtlTimestampContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUsingTtlTimestampContext() *UsingTtlTimestampContext {
	var p = new(UsingTtlTimestampContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_usingTtlTimestamp
	return p
}

func InitEmptyUsingTtlTimestampContext(p *UsingTtlTimestampContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_usingTtlTimestamp
}

func (*UsingTtlTimestampContext) IsUsingTtlTimestampContext() {}

func NewUsingTtlTimestampContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UsingTtlTimestampContext {
	var p = new(UsingTtlTimestampContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_usingTtlTimestamp

	return p
}

func (s *UsingTtlTimestampContext) GetParser() antlr.Parser { return s.parser }

func (s *UsingTtlTimestampContext) KwUsing() IKwUsingContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwUsingContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwUsingContext)
}

func (s *UsingTtlTimestampContext) Ttl() ITtlContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITtlContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITtlContext)
}

func (s *UsingTtlTimestampContext) KwAnd() IKwAndContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwAndContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwAndContext)
}

func (s *UsingTtlTimestampContext) Timestamp() ITimestampContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITimestampContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITimestampContext)
}

func (s *UsingTtlTimestampContext) KwTimeout() IKwTimeoutContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwTimeoutContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwTimeoutContext)
}

func (s *UsingTtlTimestampContext) Constant() IConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *UsingTtlTimestampContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UsingTtlTimestampContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UsingTtlTimestampContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterUsingTtlTimestamp(s)
	}
}

func (s *UsingTtlTimestampContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitUsingTtlTimestamp(s)
	}
}

func (p *CqlParser) UsingTtlTimestamp() (localctx IUsingTtlTimestampContext) {
	localctx = NewUsingTtlTimestampContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 280, CqlParserRULE_usingTtlTimestamp)
	p.SetState(2292)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 186, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2248)
			p.KwUsing()
		}
		{
			p.SetState(2249)
			p.Ttl()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2251)
			p.KwUsing()
		}
		{
			p.SetState(2252)
			p.Ttl()
		}
		{
			p.SetState(2253)
			p.KwAnd()
		}
		{
			p.SetState(2254)
			p.Timestamp()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2256)
			p.KwUsing()
		}
		{
			p.SetState(2257)
			p.Timestamp()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2259)
			p.KwUsing()
		}
		{
			p.SetState(2260)
			p.Timestamp()
		}
		{
			p.SetState(2261)
			p.KwAnd()
		}
		{
			p.SetState(2262)
			p.Ttl()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2264)
			p.KwUsing()
		}
		{
			p.SetState(2265)
			p.KwTimeout()
		}
		{
			p.SetState(2266)
			p.Constant()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2268)
			p.KwUsing()
		}
		{
			p.SetState(2269)
			p.Ttl()
		}
		{
			p.SetState(2270)
			p.KwAnd()
		}
		{
			p.SetState(2271)
			p.KwTimeout()
		}
		{
			p.SetState(2272)
			p.Constant()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(2274)
			p.KwUsing()
		}
		{
			p.SetState(2275)
			p.Timestamp()
		}
		{
			p.SetState(2276)
			p.KwAnd()
		}
		{
			p.SetState(2277)
			p.KwTimeout()
		}
		{
			p.SetState(2278)
			p.Constant()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(2280)
			p.KwUsing()
		}
		{
			p.SetState(2281)
			p.KwTimeout()
		}
		{
			p.SetState(2282)
			p.Constant()
		}
		{
			p.SetState(2283)
			p.KwAnd()
		}
		{
			p.SetState(2284)
			p.Ttl()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(2286)
			p.KwUsing()
		}
		{
			p.SetState(2287)
			p.KwTimeout()
		}
		{
			p.SetState(2288)
			p.Constant()
		}
		{
			p.SetState(2289)
			p.KwAnd()
		}
		{
			p.SetState(2290)
			p.Timestamp()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITimestampContext is an interface to support dynamic dispatch.
type ITimestampContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwTimestamp() IKwTimestampContext
	DecimalLiteral() IDecimalLiteralContext

	// IsTimestampContext differentiates from other interfaces.
	IsTimestampContext()
}

type TimestampContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTimestampContext() *TimestampContext {
	var p = new(TimestampContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_timestamp
	return p
}

func InitEmptyTimestampContext(p *TimestampContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_timestamp
}

func (*TimestampContext) IsTimestampContext() {}

func NewTimestampContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TimestampContext {
	var p = new(TimestampContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_timestamp

	return p
}

func (s *TimestampContext) GetParser() antlr.Parser { return s.parser }

func (s *TimestampContext) KwTimestamp() IKwTimestampContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwTimestampContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwTimestampContext)
}

func (s *TimestampContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *TimestampContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TimestampContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TimestampContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterTimestamp(s)
	}
}

func (s *TimestampContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitTimestamp(s)
	}
}

func (p *CqlParser) Timestamp() (localctx ITimestampContext) {
	localctx = NewTimestampContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 282, CqlParserRULE_timestamp)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2294)
		p.KwTimestamp()
	}
	{
		p.SetState(2295)
		p.DecimalLiteral()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITtlContext is an interface to support dynamic dispatch.
type ITtlContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwTtl() IKwTtlContext
	DecimalLiteral() IDecimalLiteralContext

	// IsTtlContext differentiates from other interfaces.
	IsTtlContext()
}

type TtlContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTtlContext() *TtlContext {
	var p = new(TtlContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_ttl
	return p
}

func InitEmptyTtlContext(p *TtlContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_ttl
}

func (*TtlContext) IsTtlContext() {}

func NewTtlContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TtlContext {
	var p = new(TtlContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_ttl

	return p
}

func (s *TtlContext) GetParser() antlr.Parser { return s.parser }

func (s *TtlContext) KwTtl() IKwTtlContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwTtlContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwTtlContext)
}

func (s *TtlContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *TtlContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TtlContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TtlContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterTtl(s)
	}
}

func (s *TtlContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitTtl(s)
	}
}

func (p *CqlParser) Ttl() (localctx ITtlContext) {
	localctx = NewTtlContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 284, CqlParserRULE_ttl)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2297)
		p.KwTtl()
	}
	{
		p.SetState(2298)
		p.DecimalLiteral()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUsingTimestampSpecContext is an interface to support dynamic dispatch.
type IUsingTimestampSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwUsing() IKwUsingContext
	Timestamp() ITimestampContext
	KwTimeout() IKwTimeoutContext
	Constant() IConstantContext
	KwAnd() IKwAndContext

	// IsUsingTimestampSpecContext differentiates from other interfaces.
	IsUsingTimestampSpecContext()
}

type UsingTimestampSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUsingTimestampSpecContext() *UsingTimestampSpecContext {
	var p = new(UsingTimestampSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_usingTimestampSpec
	return p
}

func InitEmptyUsingTimestampSpecContext(p *UsingTimestampSpecContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_usingTimestampSpec
}

func (*UsingTimestampSpecContext) IsUsingTimestampSpecContext() {}

func NewUsingTimestampSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UsingTimestampSpecContext {
	var p = new(UsingTimestampSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_usingTimestampSpec

	return p
}

func (s *UsingTimestampSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *UsingTimestampSpecContext) KwUsing() IKwUsingContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwUsingContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwUsingContext)
}

func (s *UsingTimestampSpecContext) Timestamp() ITimestampContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITimestampContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITimestampContext)
}

func (s *UsingTimestampSpecContext) KwTimeout() IKwTimeoutContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwTimeoutContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwTimeoutContext)
}

func (s *UsingTimestampSpecContext) Constant() IConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *UsingTimestampSpecContext) KwAnd() IKwAndContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwAndContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwAndContext)
}

func (s *UsingTimestampSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UsingTimestampSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UsingTimestampSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterUsingTimestampSpec(s)
	}
}

func (s *UsingTimestampSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitUsingTimestampSpec(s)
	}
}

func (p *CqlParser) UsingTimestampSpec() (localctx IUsingTimestampSpecContext) {
	localctx = NewUsingTimestampSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 286, CqlParserRULE_usingTimestampSpec)
	p.SetState(2319)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 187, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2300)
			p.KwUsing()
		}
		{
			p.SetState(2301)
			p.Timestamp()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2303)
			p.KwUsing()
		}
		{
			p.SetState(2304)
			p.KwTimeout()
		}
		{
			p.SetState(2305)
			p.Constant()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2307)
			p.KwUsing()
		}
		{
			p.SetState(2308)
			p.Timestamp()
		}
		{
			p.SetState(2309)
			p.KwAnd()
		}
		{
			p.SetState(2310)
			p.KwTimeout()
		}
		{
			p.SetState(2311)
			p.Constant()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2313)
			p.KwUsing()
		}
		{
			p.SetState(2314)
			p.KwTimeout()
		}
		{
			p.SetState(2315)
			p.Constant()
		}
		{
			p.SetState(2316)
			p.KwAnd()
		}
		{
			p.SetState(2317)
			p.Timestamp()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIfNotExistContext is an interface to support dynamic dispatch.
type IIfNotExistContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwIf() IKwIfContext
	KwNot() IKwNotContext
	KwExists() IKwExistsContext

	// IsIfNotExistContext differentiates from other interfaces.
	IsIfNotExistContext()
}

type IfNotExistContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfNotExistContext() *IfNotExistContext {
	var p = new(IfNotExistContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_ifNotExist
	return p
}

func InitEmptyIfNotExistContext(p *IfNotExistContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_ifNotExist
}

func (*IfNotExistContext) IsIfNotExistContext() {}

func NewIfNotExistContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfNotExistContext {
	var p = new(IfNotExistContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_ifNotExist

	return p
}

func (s *IfNotExistContext) GetParser() antlr.Parser { return s.parser }

func (s *IfNotExistContext) KwIf() IKwIfContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwIfContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwIfContext)
}

func (s *IfNotExistContext) KwNot() IKwNotContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwNotContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwNotContext)
}

func (s *IfNotExistContext) KwExists() IKwExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwExistsContext)
}

func (s *IfNotExistContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfNotExistContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfNotExistContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterIfNotExist(s)
	}
}

func (s *IfNotExistContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitIfNotExist(s)
	}
}

func (p *CqlParser) IfNotExist() (localctx IIfNotExistContext) {
	localctx = NewIfNotExistContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 288, CqlParserRULE_ifNotExist)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2321)
		p.KwIf()
	}
	{
		p.SetState(2322)
		p.KwNot()
	}
	{
		p.SetState(2323)
		p.KwExists()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIfExistContext is an interface to support dynamic dispatch.
type IIfExistContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwIf() IKwIfContext
	KwExists() IKwExistsContext

	// IsIfExistContext differentiates from other interfaces.
	IsIfExistContext()
}

type IfExistContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfExistContext() *IfExistContext {
	var p = new(IfExistContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_ifExist
	return p
}

func InitEmptyIfExistContext(p *IfExistContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_ifExist
}

func (*IfExistContext) IsIfExistContext() {}

func NewIfExistContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfExistContext {
	var p = new(IfExistContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_ifExist

	return p
}

func (s *IfExistContext) GetParser() antlr.Parser { return s.parser }

func (s *IfExistContext) KwIf() IKwIfContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwIfContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwIfContext)
}

func (s *IfExistContext) KwExists() IKwExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwExistsContext)
}

func (s *IfExistContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfExistContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfExistContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterIfExist(s)
	}
}

func (s *IfExistContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitIfExist(s)
	}
}

func (p *CqlParser) IfExist() (localctx IIfExistContext) {
	localctx = NewIfExistContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 290, CqlParserRULE_ifExist)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2325)
		p.KwIf()
	}
	{
		p.SetState(2326)
		p.KwExists()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInsertValuesSpecContext is an interface to support dynamic dispatch.
type IInsertValuesSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwValues() IKwValuesContext
	LR_BRACKET() antlr.TerminalNode
	ExpressionList() IExpressionListContext
	RR_BRACKET() antlr.TerminalNode
	KwJson() IKwJsonContext
	Constant() IConstantContext
	JsonDefault() IJsonDefaultContext

	// IsInsertValuesSpecContext differentiates from other interfaces.
	IsInsertValuesSpecContext()
}

type InsertValuesSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInsertValuesSpecContext() *InsertValuesSpecContext {
	var p = new(InsertValuesSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_insertValuesSpec
	return p
}

func InitEmptyInsertValuesSpecContext(p *InsertValuesSpecContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_insertValuesSpec
}

func (*InsertValuesSpecContext) IsInsertValuesSpecContext() {}

func NewInsertValuesSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InsertValuesSpecContext {
	var p = new(InsertValuesSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_insertValuesSpec

	return p
}

func (s *InsertValuesSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *InsertValuesSpecContext) KwValues() IKwValuesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwValuesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwValuesContext)
}

func (s *InsertValuesSpecContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(CqlParserLR_BRACKET, 0)
}

func (s *InsertValuesSpecContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *InsertValuesSpecContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(CqlParserRR_BRACKET, 0)
}

func (s *InsertValuesSpecContext) KwJson() IKwJsonContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwJsonContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwJsonContext)
}

func (s *InsertValuesSpecContext) Constant() IConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *InsertValuesSpecContext) JsonDefault() IJsonDefaultContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJsonDefaultContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJsonDefaultContext)
}

func (s *InsertValuesSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InsertValuesSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InsertValuesSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterInsertValuesSpec(s)
	}
}

func (s *InsertValuesSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitInsertValuesSpec(s)
	}
}

func (p *CqlParser) InsertValuesSpec() (localctx IInsertValuesSpecContext) {
	localctx = NewInsertValuesSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 292, CqlParserRULE_insertValuesSpec)
	var _la int

	p.SetState(2338)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case CqlParserK_VALUES:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2328)
			p.KwValues()
		}
		{
			p.SetState(2329)
			p.Match(CqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2330)
			p.ExpressionList()
		}
		{
			p.SetState(2331)
			p.Match(CqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case CqlParserK_JSON:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2333)
			p.KwJson()
		}
		{
			p.SetState(2334)
			p.Constant()
		}
		p.SetState(2336)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == CqlParserK_DEFAULT {
			{
				p.SetState(2335)
				p.JsonDefault()
			}

		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJsonDefaultContext is an interface to support dynamic dispatch.
type IJsonDefaultContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwDefault() IKwDefaultContext
	KwNull() IKwNullContext
	KwUnset() IKwUnsetContext

	// IsJsonDefaultContext differentiates from other interfaces.
	IsJsonDefaultContext()
}

type JsonDefaultContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJsonDefaultContext() *JsonDefaultContext {
	var p = new(JsonDefaultContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_jsonDefault
	return p
}

func InitEmptyJsonDefaultContext(p *JsonDefaultContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_jsonDefault
}

func (*JsonDefaultContext) IsJsonDefaultContext() {}

func NewJsonDefaultContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JsonDefaultContext {
	var p = new(JsonDefaultContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_jsonDefault

	return p
}

func (s *JsonDefaultContext) GetParser() antlr.Parser { return s.parser }

func (s *JsonDefaultContext) KwDefault() IKwDefaultContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwDefaultContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwDefaultContext)
}

func (s *JsonDefaultContext) KwNull() IKwNullContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwNullContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwNullContext)
}

func (s *JsonDefaultContext) KwUnset() IKwUnsetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwUnsetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwUnsetContext)
}

func (s *JsonDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JsonDefaultContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JsonDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterJsonDefault(s)
	}
}

func (s *JsonDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitJsonDefault(s)
	}
}

func (p *CqlParser) JsonDefault() (localctx IJsonDefaultContext) {
	localctx = NewJsonDefaultContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 294, CqlParserRULE_jsonDefault)
	p.SetState(2346)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 190, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2340)
			p.KwDefault()
		}
		{
			p.SetState(2341)
			p.KwNull()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2343)
			p.KwDefault()
		}
		{
			p.SetState(2344)
			p.KwUnset()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInsertColumnSpecContext is an interface to support dynamic dispatch.
type IInsertColumnSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LR_BRACKET() antlr.TerminalNode
	ColumnList() IColumnListContext
	RR_BRACKET() antlr.TerminalNode

	// IsInsertColumnSpecContext differentiates from other interfaces.
	IsInsertColumnSpecContext()
}

type InsertColumnSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInsertColumnSpecContext() *InsertColumnSpecContext {
	var p = new(InsertColumnSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_insertColumnSpec
	return p
}

func InitEmptyInsertColumnSpecContext(p *InsertColumnSpecContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_insertColumnSpec
}

func (*InsertColumnSpecContext) IsInsertColumnSpecContext() {}

func NewInsertColumnSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InsertColumnSpecContext {
	var p = new(InsertColumnSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_insertColumnSpec

	return p
}

func (s *InsertColumnSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *InsertColumnSpecContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(CqlParserLR_BRACKET, 0)
}

func (s *InsertColumnSpecContext) ColumnList() IColumnListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnListContext)
}

func (s *InsertColumnSpecContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(CqlParserRR_BRACKET, 0)
}

func (s *InsertColumnSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InsertColumnSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InsertColumnSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterInsertColumnSpec(s)
	}
}

func (s *InsertColumnSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitInsertColumnSpec(s)
	}
}

func (p *CqlParser) InsertColumnSpec() (localctx IInsertColumnSpecContext) {
	localctx = NewInsertColumnSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 296, CqlParserRULE_insertColumnSpec)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2348)
		p.Match(CqlParserLR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2349)
		p.ColumnList()
	}
	{
		p.SetState(2350)
		p.Match(CqlParserRR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnListContext is an interface to support dynamic dispatch.
type IColumnListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllColumn() []IColumnContext
	Column(i int) IColumnContext
	AllSyntaxComma() []ISyntaxCommaContext
	SyntaxComma(i int) ISyntaxCommaContext

	// IsColumnListContext differentiates from other interfaces.
	IsColumnListContext()
}

type ColumnListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnListContext() *ColumnListContext {
	var p = new(ColumnListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_columnList
	return p
}

func InitEmptyColumnListContext(p *ColumnListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_columnList
}

func (*ColumnListContext) IsColumnListContext() {}

func NewColumnListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnListContext {
	var p = new(ColumnListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_columnList

	return p
}

func (s *ColumnListContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnListContext) AllColumn() []IColumnContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnContext); ok {
			len++
		}
	}

	tst := make([]IColumnContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnContext); ok {
			tst[i] = t.(IColumnContext)
			i++
		}
	}

	return tst
}

func (s *ColumnListContext) Column(i int) IColumnContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnContext)
}

func (s *ColumnListContext) AllSyntaxComma() []ISyntaxCommaContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			len++
		}
	}

	tst := make([]ISyntaxCommaContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISyntaxCommaContext); ok {
			tst[i] = t.(ISyntaxCommaContext)
			i++
		}
	}

	return tst
}

func (s *ColumnListContext) SyntaxComma(i int) ISyntaxCommaContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxCommaContext)
}

func (s *ColumnListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterColumnList(s)
	}
}

func (s *ColumnListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitColumnList(s)
	}
}

func (p *CqlParser) ColumnList() (localctx IColumnListContext) {
	localctx = NewColumnListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 298, CqlParserRULE_columnList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2352)
		p.Column()
	}
	p.SetState(2358)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == CqlParserCOMMA {
		{
			p.SetState(2353)
			p.SyntaxComma()
		}
		{
			p.SetState(2354)
			p.Column()
		}

		p.SetState(2360)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionListContext is an interface to support dynamic dispatch.
type IExpressionListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllSyntaxComma() []ISyntaxCommaContext
	SyntaxComma(i int) ISyntaxCommaContext

	// IsExpressionListContext differentiates from other interfaces.
	IsExpressionListContext()
}

type ExpressionListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionListContext() *ExpressionListContext {
	var p = new(ExpressionListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_expressionList
	return p
}

func InitEmptyExpressionListContext(p *ExpressionListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_expressionList
}

func (*ExpressionListContext) IsExpressionListContext() {}

func NewExpressionListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionListContext {
	var p = new(ExpressionListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_expressionList

	return p
}

func (s *ExpressionListContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionListContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ExpressionListContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionListContext) AllSyntaxComma() []ISyntaxCommaContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			len++
		}
	}

	tst := make([]ISyntaxCommaContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISyntaxCommaContext); ok {
			tst[i] = t.(ISyntaxCommaContext)
			i++
		}
	}

	return tst
}

func (s *ExpressionListContext) SyntaxComma(i int) ISyntaxCommaContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxCommaContext)
}

func (s *ExpressionListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterExpressionList(s)
	}
}

func (s *ExpressionListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitExpressionList(s)
	}
}

func (p *CqlParser) ExpressionList() (localctx IExpressionListContext) {
	localctx = NewExpressionListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 300, CqlParserRULE_expressionList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2361)
		p.Expression()
	}
	p.SetState(2367)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == CqlParserCOMMA {
		{
			p.SetState(2362)
			p.SyntaxComma()
		}
		{
			p.SetState(2363)
			p.Expression()
		}

		p.SetState(2369)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Constant() IConstantContext
	FunctionCall() IFunctionCallContext
	AssignmentMap() IAssignmentMapContext
	AssignmentSet() IAssignmentSetContext
	AssignmentList() IAssignmentListContext
	AssignmentTuple() IAssignmentTupleContext

	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_expression
	return p
}

func InitEmptyExpressionContext(p *ExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_expression
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) Constant() IConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *ExpressionContext) FunctionCall() IFunctionCallContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionCallContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionCallContext)
}

func (s *ExpressionContext) AssignmentMap() IAssignmentMapContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentMapContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentMapContext)
}

func (s *ExpressionContext) AssignmentSet() IAssignmentSetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentSetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentSetContext)
}

func (s *ExpressionContext) AssignmentList() IAssignmentListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentListContext)
}

func (s *ExpressionContext) AssignmentTuple() IAssignmentTupleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentTupleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentTupleContext)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterExpression(s)
	}
}

func (s *ExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitExpression(s)
	}
}

func (p *CqlParser) Expression() (localctx IExpressionContext) {
	localctx = NewExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 302, CqlParserRULE_expression)
	p.SetState(2376)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 193, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2370)
			p.Constant()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2371)
			p.FunctionCall()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2372)
			p.AssignmentMap()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2373)
			p.AssignmentSet()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2374)
			p.AssignmentList()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2375)
			p.AssignmentTuple()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelect_Context is an interface to support dynamic dispatch.
type ISelect_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwSelect() IKwSelectContext
	SelectElements() ISelectElementsContext
	FromSpec() IFromSpecContext
	DistinctSpec() IDistinctSpecContext
	KwJson() IKwJsonContext
	WhereSpec() IWhereSpecContext
	GroupBySpec() IGroupBySpecContext
	OrderSpec() IOrderSpecContext
	PerPartitionLimitSpec() IPerPartitionLimitSpecContext
	LimitSpec() ILimitSpecContext
	AllowFilteringSpec() IAllowFilteringSpecContext
	BypassCacheSpec() IBypassCacheSpecContext
	UsingTimeoutSpec() IUsingTimeoutSpecContext

	// IsSelect_Context differentiates from other interfaces.
	IsSelect_Context()
}

type Select_Context struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelect_Context() *Select_Context {
	var p = new(Select_Context)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_select_
	return p
}

func InitEmptySelect_Context(p *Select_Context) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_select_
}

func (*Select_Context) IsSelect_Context() {}

func NewSelect_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Select_Context {
	var p = new(Select_Context)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_select_

	return p
}

func (s *Select_Context) GetParser() antlr.Parser { return s.parser }

func (s *Select_Context) KwSelect() IKwSelectContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwSelectContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwSelectContext)
}

func (s *Select_Context) SelectElements() ISelectElementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectElementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectElementsContext)
}

func (s *Select_Context) FromSpec() IFromSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFromSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFromSpecContext)
}

func (s *Select_Context) DistinctSpec() IDistinctSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDistinctSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDistinctSpecContext)
}

func (s *Select_Context) KwJson() IKwJsonContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwJsonContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwJsonContext)
}

func (s *Select_Context) WhereSpec() IWhereSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhereSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhereSpecContext)
}

func (s *Select_Context) GroupBySpec() IGroupBySpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroupBySpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroupBySpecContext)
}

func (s *Select_Context) OrderSpec() IOrderSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderSpecContext)
}

func (s *Select_Context) PerPartitionLimitSpec() IPerPartitionLimitSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPerPartitionLimitSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPerPartitionLimitSpecContext)
}

func (s *Select_Context) LimitSpec() ILimitSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitSpecContext)
}

func (s *Select_Context) AllowFilteringSpec() IAllowFilteringSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAllowFilteringSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAllowFilteringSpecContext)
}

func (s *Select_Context) BypassCacheSpec() IBypassCacheSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBypassCacheSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBypassCacheSpecContext)
}

func (s *Select_Context) UsingTimeoutSpec() IUsingTimeoutSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUsingTimeoutSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUsingTimeoutSpecContext)
}

func (s *Select_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Select_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Select_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterSelect_(s)
	}
}

func (s *Select_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitSelect_(s)
	}
}

func (p *CqlParser) Select_() (localctx ISelect_Context) {
	localctx = NewSelect_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 304, CqlParserRULE_select_)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2378)
		p.KwSelect()
	}
	p.SetState(2380)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CqlParserK_DISTINCT {
		{
			p.SetState(2379)
			p.DistinctSpec()
		}

	}
	p.SetState(2383)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CqlParserK_JSON {
		{
			p.SetState(2382)
			p.KwJson()
		}

	}
	{
		p.SetState(2385)
		p.SelectElements()
	}
	{
		p.SetState(2386)
		p.FromSpec()
	}
	p.SetState(2388)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CqlParserK_WHERE {
		{
			p.SetState(2387)
			p.WhereSpec()
		}

	}
	p.SetState(2391)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CqlParserK_GROUP {
		{
			p.SetState(2390)
			p.GroupBySpec()
		}

	}
	p.SetState(2394)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CqlParserK_ORDER {
		{
			p.SetState(2393)
			p.OrderSpec()
		}

	}
	p.SetState(2397)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CqlParserK_PER {
		{
			p.SetState(2396)
			p.PerPartitionLimitSpec()
		}

	}
	p.SetState(2400)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CqlParserK_LIMIT {
		{
			p.SetState(2399)
			p.LimitSpec()
		}

	}
	p.SetState(2403)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CqlParserK_ALLOW {
		{
			p.SetState(2402)
			p.AllowFilteringSpec()
		}

	}
	p.SetState(2406)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CqlParserK_BYPASS {
		{
			p.SetState(2405)
			p.BypassCacheSpec()
		}

	}
	p.SetState(2409)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CqlParserK_USING {
		{
			p.SetState(2408)
			p.UsingTimeoutSpec()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAllowFilteringSpecContext is an interface to support dynamic dispatch.
type IAllowFilteringSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwAllow() IKwAllowContext
	KwFiltering() IKwFilteringContext

	// IsAllowFilteringSpecContext differentiates from other interfaces.
	IsAllowFilteringSpecContext()
}

type AllowFilteringSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAllowFilteringSpecContext() *AllowFilteringSpecContext {
	var p = new(AllowFilteringSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_allowFilteringSpec
	return p
}

func InitEmptyAllowFilteringSpecContext(p *AllowFilteringSpecContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_allowFilteringSpec
}

func (*AllowFilteringSpecContext) IsAllowFilteringSpecContext() {}

func NewAllowFilteringSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AllowFilteringSpecContext {
	var p = new(AllowFilteringSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_allowFilteringSpec

	return p
}

func (s *AllowFilteringSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *AllowFilteringSpecContext) KwAllow() IKwAllowContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwAllowContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwAllowContext)
}

func (s *AllowFilteringSpecContext) KwFiltering() IKwFilteringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwFilteringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwFilteringContext)
}

func (s *AllowFilteringSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AllowFilteringSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AllowFilteringSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterAllowFilteringSpec(s)
	}
}

func (s *AllowFilteringSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitAllowFilteringSpec(s)
	}
}

func (p *CqlParser) AllowFilteringSpec() (localctx IAllowFilteringSpecContext) {
	localctx = NewAllowFilteringSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 306, CqlParserRULE_allowFilteringSpec)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2411)
		p.KwAllow()
	}
	{
		p.SetState(2412)
		p.KwFiltering()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGroupBySpecContext is an interface to support dynamic dispatch.
type IGroupBySpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwGroup() IKwGroupContext
	KwBy() IKwByContext
	ColumnList() IColumnListContext

	// IsGroupBySpecContext differentiates from other interfaces.
	IsGroupBySpecContext()
}

type GroupBySpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroupBySpecContext() *GroupBySpecContext {
	var p = new(GroupBySpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_groupBySpec
	return p
}

func InitEmptyGroupBySpecContext(p *GroupBySpecContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_groupBySpec
}

func (*GroupBySpecContext) IsGroupBySpecContext() {}

func NewGroupBySpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GroupBySpecContext {
	var p = new(GroupBySpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_groupBySpec

	return p
}

func (s *GroupBySpecContext) GetParser() antlr.Parser { return s.parser }

func (s *GroupBySpecContext) KwGroup() IKwGroupContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwGroupContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwGroupContext)
}

func (s *GroupBySpecContext) KwBy() IKwByContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwByContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwByContext)
}

func (s *GroupBySpecContext) ColumnList() IColumnListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnListContext)
}

func (s *GroupBySpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupBySpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GroupBySpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterGroupBySpec(s)
	}
}

func (s *GroupBySpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitGroupBySpec(s)
	}
}

func (p *CqlParser) GroupBySpec() (localctx IGroupBySpecContext) {
	localctx = NewGroupBySpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 308, CqlParserRULE_groupBySpec)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2414)
		p.KwGroup()
	}
	{
		p.SetState(2415)
		p.KwBy()
	}
	{
		p.SetState(2416)
		p.ColumnList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBypassCacheSpecContext is an interface to support dynamic dispatch.
type IBypassCacheSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwBypass() IKwBypassContext
	KwCache() IKwCacheContext

	// IsBypassCacheSpecContext differentiates from other interfaces.
	IsBypassCacheSpecContext()
}

type BypassCacheSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBypassCacheSpecContext() *BypassCacheSpecContext {
	var p = new(BypassCacheSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_bypassCacheSpec
	return p
}

func InitEmptyBypassCacheSpecContext(p *BypassCacheSpecContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_bypassCacheSpec
}

func (*BypassCacheSpecContext) IsBypassCacheSpecContext() {}

func NewBypassCacheSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BypassCacheSpecContext {
	var p = new(BypassCacheSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_bypassCacheSpec

	return p
}

func (s *BypassCacheSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *BypassCacheSpecContext) KwBypass() IKwBypassContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwBypassContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwBypassContext)
}

func (s *BypassCacheSpecContext) KwCache() IKwCacheContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwCacheContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwCacheContext)
}

func (s *BypassCacheSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BypassCacheSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BypassCacheSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterBypassCacheSpec(s)
	}
}

func (s *BypassCacheSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitBypassCacheSpec(s)
	}
}

func (p *CqlParser) BypassCacheSpec() (localctx IBypassCacheSpecContext) {
	localctx = NewBypassCacheSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 310, CqlParserRULE_bypassCacheSpec)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2418)
		p.KwBypass()
	}
	{
		p.SetState(2419)
		p.KwCache()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPerPartitionLimitSpecContext is an interface to support dynamic dispatch.
type IPerPartitionLimitSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwPer() IKwPerContext
	KwPartition() IKwPartitionContext
	KwLimit() IKwLimitContext
	DecimalLiteral() IDecimalLiteralContext

	// IsPerPartitionLimitSpecContext differentiates from other interfaces.
	IsPerPartitionLimitSpecContext()
}

type PerPartitionLimitSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPerPartitionLimitSpecContext() *PerPartitionLimitSpecContext {
	var p = new(PerPartitionLimitSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_perPartitionLimitSpec
	return p
}

func InitEmptyPerPartitionLimitSpecContext(p *PerPartitionLimitSpecContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_perPartitionLimitSpec
}

func (*PerPartitionLimitSpecContext) IsPerPartitionLimitSpecContext() {}

func NewPerPartitionLimitSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PerPartitionLimitSpecContext {
	var p = new(PerPartitionLimitSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_perPartitionLimitSpec

	return p
}

func (s *PerPartitionLimitSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *PerPartitionLimitSpecContext) KwPer() IKwPerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwPerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwPerContext)
}

func (s *PerPartitionLimitSpecContext) KwPartition() IKwPartitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwPartitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwPartitionContext)
}

func (s *PerPartitionLimitSpecContext) KwLimit() IKwLimitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwLimitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwLimitContext)
}

func (s *PerPartitionLimitSpecContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *PerPartitionLimitSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PerPartitionLimitSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PerPartitionLimitSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterPerPartitionLimitSpec(s)
	}
}

func (s *PerPartitionLimitSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitPerPartitionLimitSpec(s)
	}
}

func (p *CqlParser) PerPartitionLimitSpec() (localctx IPerPartitionLimitSpecContext) {
	localctx = NewPerPartitionLimitSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 312, CqlParserRULE_perPartitionLimitSpec)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2421)
		p.KwPer()
	}
	{
		p.SetState(2422)
		p.KwPartition()
	}
	{
		p.SetState(2423)
		p.KwLimit()
	}
	{
		p.SetState(2424)
		p.DecimalLiteral()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUsingTimeoutSpecContext is an interface to support dynamic dispatch.
type IUsingTimeoutSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwUsing() IKwUsingContext
	KwTimeout() IKwTimeoutContext
	Constant() IConstantContext

	// IsUsingTimeoutSpecContext differentiates from other interfaces.
	IsUsingTimeoutSpecContext()
}

type UsingTimeoutSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUsingTimeoutSpecContext() *UsingTimeoutSpecContext {
	var p = new(UsingTimeoutSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_usingTimeoutSpec
	return p
}

func InitEmptyUsingTimeoutSpecContext(p *UsingTimeoutSpecContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_usingTimeoutSpec
}

func (*UsingTimeoutSpecContext) IsUsingTimeoutSpecContext() {}

func NewUsingTimeoutSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UsingTimeoutSpecContext {
	var p = new(UsingTimeoutSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_usingTimeoutSpec

	return p
}

func (s *UsingTimeoutSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *UsingTimeoutSpecContext) KwUsing() IKwUsingContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwUsingContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwUsingContext)
}

func (s *UsingTimeoutSpecContext) KwTimeout() IKwTimeoutContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwTimeoutContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwTimeoutContext)
}

func (s *UsingTimeoutSpecContext) Constant() IConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *UsingTimeoutSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UsingTimeoutSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UsingTimeoutSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterUsingTimeoutSpec(s)
	}
}

func (s *UsingTimeoutSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitUsingTimeoutSpec(s)
	}
}

func (p *CqlParser) UsingTimeoutSpec() (localctx IUsingTimeoutSpecContext) {
	localctx = NewUsingTimeoutSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 314, CqlParserRULE_usingTimeoutSpec)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2426)
		p.KwUsing()
	}
	{
		p.SetState(2427)
		p.KwTimeout()
	}
	{
		p.SetState(2428)
		p.Constant()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPruneMaterializedViewContext is an interface to support dynamic dispatch.
type IPruneMaterializedViewContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwPrune() IKwPruneContext
	KwMaterialized() IKwMaterializedContext
	KwView() IKwViewContext
	MaterializedView() IMaterializedViewContext
	Keyspace() IKeyspaceContext
	DOT() antlr.TerminalNode
	WhereSpec() IWhereSpecContext
	PruneUsingSpec() IPruneUsingSpecContext

	// IsPruneMaterializedViewContext differentiates from other interfaces.
	IsPruneMaterializedViewContext()
}

type PruneMaterializedViewContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPruneMaterializedViewContext() *PruneMaterializedViewContext {
	var p = new(PruneMaterializedViewContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_pruneMaterializedView
	return p
}

func InitEmptyPruneMaterializedViewContext(p *PruneMaterializedViewContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_pruneMaterializedView
}

func (*PruneMaterializedViewContext) IsPruneMaterializedViewContext() {}

func NewPruneMaterializedViewContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PruneMaterializedViewContext {
	var p = new(PruneMaterializedViewContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_pruneMaterializedView

	return p
}

func (s *PruneMaterializedViewContext) GetParser() antlr.Parser { return s.parser }

func (s *PruneMaterializedViewContext) KwPrune() IKwPruneContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwPruneContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwPruneContext)
}

func (s *PruneMaterializedViewContext) KwMaterialized() IKwMaterializedContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwMaterializedContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwMaterializedContext)
}

func (s *PruneMaterializedViewContext) KwView() IKwViewContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwViewContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwViewContext)
}

func (s *PruneMaterializedViewContext) MaterializedView() IMaterializedViewContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMaterializedViewContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMaterializedViewContext)
}

func (s *PruneMaterializedViewContext) Keyspace() IKeyspaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyspaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyspaceContext)
}

func (s *PruneMaterializedViewContext) DOT() antlr.TerminalNode {
	return s.GetToken(CqlParserDOT, 0)
}

func (s *PruneMaterializedViewContext) WhereSpec() IWhereSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhereSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhereSpecContext)
}

func (s *PruneMaterializedViewContext) PruneUsingSpec() IPruneUsingSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPruneUsingSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPruneUsingSpecContext)
}

func (s *PruneMaterializedViewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PruneMaterializedViewContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PruneMaterializedViewContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterPruneMaterializedView(s)
	}
}

func (s *PruneMaterializedViewContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitPruneMaterializedView(s)
	}
}

func (p *CqlParser) PruneMaterializedView() (localctx IPruneMaterializedViewContext) {
	localctx = NewPruneMaterializedViewContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 316, CqlParserRULE_pruneMaterializedView)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2430)
		p.KwPrune()
	}
	{
		p.SetState(2431)
		p.KwMaterialized()
	}
	{
		p.SetState(2432)
		p.KwView()
	}
	p.SetState(2436)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 204, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2433)
			p.Keyspace()
		}
		{
			p.SetState(2434)
			p.Match(CqlParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(2438)
		p.MaterializedView()
	}
	p.SetState(2440)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CqlParserK_WHERE {
		{
			p.SetState(2439)
			p.WhereSpec()
		}

	}
	p.SetState(2443)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CqlParserK_USING {
		{
			p.SetState(2442)
			p.PruneUsingSpec()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDescribeStatementContext is an interface to support dynamic dispatch.
type IDescribeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DescribeTarget() IDescribeTargetContext
	KwDescribe() IKwDescribeContext
	KwDesc() IKwDescContext
	DescribeInternals() IDescribeInternalsContext

	// IsDescribeStatementContext differentiates from other interfaces.
	IsDescribeStatementContext()
}

type DescribeStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDescribeStatementContext() *DescribeStatementContext {
	var p = new(DescribeStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_describeStatement
	return p
}

func InitEmptyDescribeStatementContext(p *DescribeStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_describeStatement
}

func (*DescribeStatementContext) IsDescribeStatementContext() {}

func NewDescribeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DescribeStatementContext {
	var p = new(DescribeStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_describeStatement

	return p
}

func (s *DescribeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DescribeStatementContext) DescribeTarget() IDescribeTargetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDescribeTargetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDescribeTargetContext)
}

func (s *DescribeStatementContext) KwDescribe() IKwDescribeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwDescribeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwDescribeContext)
}

func (s *DescribeStatementContext) KwDesc() IKwDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwDescContext)
}

func (s *DescribeStatementContext) DescribeInternals() IDescribeInternalsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDescribeInternalsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDescribeInternalsContext)
}

func (s *DescribeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DescribeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DescribeStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterDescribeStatement(s)
	}
}

func (s *DescribeStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitDescribeStatement(s)
	}
}

func (p *CqlParser) DescribeStatement() (localctx IDescribeStatementContext) {
	localctx = NewDescribeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 318, CqlParserRULE_describeStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2447)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case CqlParserK_DESCRIBE:
		{
			p.SetState(2445)
			p.KwDescribe()
		}

	case CqlParserK_DESC:
		{
			p.SetState(2446)
			p.KwDesc()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(2449)
		p.DescribeTarget()
	}
	p.SetState(2451)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CqlParserK_WITH {
		{
			p.SetState(2450)
			p.DescribeInternals()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDescribeTargetContext is an interface to support dynamic dispatch.
type IDescribeTargetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwCluster() IKwClusterContext
	KwSchema() IKwSchemaContext
	KwFull() IKwFullContext
	KwKeyspaces() IKwKeyspacesContext
	KwKeyspace() IKwKeyspaceContext
	KwOnly() IKwOnlyContext
	Keyspace() IKeyspaceContext
	KwTables() IKwTablesContext
	Table() ITableContext
	KwTable() IKwTableContext
	DOT() antlr.TerminalNode
	KwColumnfamily() IKwColumnfamilyContext
	KwIndex() IKwIndexContext
	OBJECT_NAME() antlr.TerminalNode
	KwMaterialized() IKwMaterializedContext
	KwView() IKwViewContext
	KwTypes() IKwTypesContext
	KwType() IKwTypeContext
	KwFunctions() IKwFunctionsContext
	KwFunction() IKwFunctionContext
	KwAggregates() IKwAggregatesContext
	KwAggregate() IKwAggregateContext

	// IsDescribeTargetContext differentiates from other interfaces.
	IsDescribeTargetContext()
}

type DescribeTargetContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDescribeTargetContext() *DescribeTargetContext {
	var p = new(DescribeTargetContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_describeTarget
	return p
}

func InitEmptyDescribeTargetContext(p *DescribeTargetContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_describeTarget
}

func (*DescribeTargetContext) IsDescribeTargetContext() {}

func NewDescribeTargetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DescribeTargetContext {
	var p = new(DescribeTargetContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_describeTarget

	return p
}

func (s *DescribeTargetContext) GetParser() antlr.Parser { return s.parser }

func (s *DescribeTargetContext) KwCluster() IKwClusterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwClusterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwClusterContext)
}

func (s *DescribeTargetContext) KwSchema() IKwSchemaContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwSchemaContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwSchemaContext)
}

func (s *DescribeTargetContext) KwFull() IKwFullContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwFullContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwFullContext)
}

func (s *DescribeTargetContext) KwKeyspaces() IKwKeyspacesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwKeyspacesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwKeyspacesContext)
}

func (s *DescribeTargetContext) KwKeyspace() IKwKeyspaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwKeyspaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwKeyspaceContext)
}

func (s *DescribeTargetContext) KwOnly() IKwOnlyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwOnlyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwOnlyContext)
}

func (s *DescribeTargetContext) Keyspace() IKeyspaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyspaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyspaceContext)
}

func (s *DescribeTargetContext) KwTables() IKwTablesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwTablesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwTablesContext)
}

func (s *DescribeTargetContext) Table() ITableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableContext)
}

func (s *DescribeTargetContext) KwTable() IKwTableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwTableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwTableContext)
}

func (s *DescribeTargetContext) DOT() antlr.TerminalNode {
	return s.GetToken(CqlParserDOT, 0)
}

func (s *DescribeTargetContext) KwColumnfamily() IKwColumnfamilyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwColumnfamilyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwColumnfamilyContext)
}

func (s *DescribeTargetContext) KwIndex() IKwIndexContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwIndexContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwIndexContext)
}

func (s *DescribeTargetContext) OBJECT_NAME() antlr.TerminalNode {
	return s.GetToken(CqlParserOBJECT_NAME, 0)
}

func (s *DescribeTargetContext) KwMaterialized() IKwMaterializedContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwMaterializedContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwMaterializedContext)
}

func (s *DescribeTargetContext) KwView() IKwViewContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwViewContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwViewContext)
}

func (s *DescribeTargetContext) KwTypes() IKwTypesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwTypesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwTypesContext)
}

func (s *DescribeTargetContext) KwType() IKwTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwTypeContext)
}

func (s *DescribeTargetContext) KwFunctions() IKwFunctionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwFunctionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwFunctionsContext)
}

func (s *DescribeTargetContext) KwFunction() IKwFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwFunctionContext)
}

func (s *DescribeTargetContext) KwAggregates() IKwAggregatesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwAggregatesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwAggregatesContext)
}

func (s *DescribeTargetContext) KwAggregate() IKwAggregateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwAggregateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwAggregateContext)
}

func (s *DescribeTargetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DescribeTargetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DescribeTargetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterDescribeTarget(s)
	}
}

func (s *DescribeTargetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitDescribeTarget(s)
	}
}

func (p *CqlParser) DescribeTarget() (localctx IDescribeTargetContext) {
	localctx = NewDescribeTargetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 320, CqlParserRULE_describeTarget)
	var _la int

	p.SetState(2528)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 220, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2453)
			p.KwCluster()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(2455)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == CqlParserK_FULL {
			{
				p.SetState(2454)
				p.KwFull()
			}

		}
		{
			p.SetState(2457)
			p.KwSchema()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2458)
			p.KwKeyspaces()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		p.SetState(2460)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == CqlParserK_ONLY {
			{
				p.SetState(2459)
				p.KwOnly()
			}

		}
		{
			p.SetState(2462)
			p.KwKeyspace()
		}
		p.SetState(2464)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == CqlParserDQUOTE || _la == CqlParserOBJECT_NAME {
			{
				p.SetState(2463)
				p.Keyspace()
			}

		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2466)
			p.KwTables()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		p.SetState(2468)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == CqlParserK_TABLE {
			{
				p.SetState(2467)
				p.KwTable()
			}

		}
		p.SetState(2473)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 213, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2470)
				p.Keyspace()
			}
			{
				p.SetState(2471)
				p.Match(CqlParserDOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(2475)
			p.Table()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(2476)
			p.KwColumnfamily()
		}
		p.SetState(2480)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 214, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2477)
				p.Keyspace()
			}
			{
				p.SetState(2478)
				p.Match(CqlParserDOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(2482)
			p.Table()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(2484)
			p.KwIndex()
		}
		p.SetState(2488)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 215, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2485)
				p.Keyspace()
			}
			{
				p.SetState(2486)
				p.Match(CqlParserDOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(2490)
			p.Match(CqlParserOBJECT_NAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(2492)
			p.KwMaterialized()
		}
		{
			p.SetState(2493)
			p.KwView()
		}
		p.SetState(2497)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 216, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2494)
				p.Keyspace()
			}
			{
				p.SetState(2495)
				p.Match(CqlParserDOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(2499)
			p.Match(CqlParserOBJECT_NAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(2501)
			p.KwTypes()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(2502)
			p.KwType()
		}
		p.SetState(2506)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 217, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2503)
				p.Keyspace()
			}
			{
				p.SetState(2504)
				p.Match(CqlParserDOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(2508)
			p.Match(CqlParserOBJECT_NAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(2510)
			p.KwFunctions()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(2511)
			p.KwFunction()
		}
		p.SetState(2515)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 218, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2512)
				p.Keyspace()
			}
			{
				p.SetState(2513)
				p.Match(CqlParserDOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(2517)
			p.Match(CqlParserOBJECT_NAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(2519)
			p.KwAggregates()
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(2520)
			p.KwAggregate()
		}
		p.SetState(2524)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 219, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2521)
				p.Keyspace()
			}
			{
				p.SetState(2522)
				p.Match(CqlParserDOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(2526)
			p.Match(CqlParserOBJECT_NAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDescribeInternalsContext is an interface to support dynamic dispatch.
type IDescribeInternalsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwWith() IKwWithContext
	KwInternals() IKwInternalsContext
	KwAnd() IKwAndContext
	KwPasswords() IKwPasswordsContext

	// IsDescribeInternalsContext differentiates from other interfaces.
	IsDescribeInternalsContext()
}

type DescribeInternalsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDescribeInternalsContext() *DescribeInternalsContext {
	var p = new(DescribeInternalsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_describeInternals
	return p
}

func InitEmptyDescribeInternalsContext(p *DescribeInternalsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_describeInternals
}

func (*DescribeInternalsContext) IsDescribeInternalsContext() {}

func NewDescribeInternalsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DescribeInternalsContext {
	var p = new(DescribeInternalsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_describeInternals

	return p
}

func (s *DescribeInternalsContext) GetParser() antlr.Parser { return s.parser }

func (s *DescribeInternalsContext) KwWith() IKwWithContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwWithContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwWithContext)
}

func (s *DescribeInternalsContext) KwInternals() IKwInternalsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwInternalsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwInternalsContext)
}

func (s *DescribeInternalsContext) KwAnd() IKwAndContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwAndContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwAndContext)
}

func (s *DescribeInternalsContext) KwPasswords() IKwPasswordsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwPasswordsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwPasswordsContext)
}

func (s *DescribeInternalsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DescribeInternalsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DescribeInternalsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterDescribeInternals(s)
	}
}

func (s *DescribeInternalsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitDescribeInternals(s)
	}
}

func (p *CqlParser) DescribeInternals() (localctx IDescribeInternalsContext) {
	localctx = NewDescribeInternalsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 322, CqlParserRULE_describeInternals)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2530)
		p.KwWith()
	}
	{
		p.SetState(2531)
		p.KwInternals()
	}
	p.SetState(2535)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CqlParserK_AND {
		{
			p.SetState(2532)
			p.KwAnd()
		}
		{
			p.SetState(2533)
			p.KwPasswords()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IServiceLevelNameContext is an interface to support dynamic dispatch.
type IServiceLevelNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OBJECT_NAME() antlr.TerminalNode
	StringLiteral() IStringLiteralContext

	// IsServiceLevelNameContext differentiates from other interfaces.
	IsServiceLevelNameContext()
}

type ServiceLevelNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyServiceLevelNameContext() *ServiceLevelNameContext {
	var p = new(ServiceLevelNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_serviceLevelName
	return p
}

func InitEmptyServiceLevelNameContext(p *ServiceLevelNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_serviceLevelName
}

func (*ServiceLevelNameContext) IsServiceLevelNameContext() {}

func NewServiceLevelNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ServiceLevelNameContext {
	var p = new(ServiceLevelNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_serviceLevelName

	return p
}

func (s *ServiceLevelNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ServiceLevelNameContext) OBJECT_NAME() antlr.TerminalNode {
	return s.GetToken(CqlParserOBJECT_NAME, 0)
}

func (s *ServiceLevelNameContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *ServiceLevelNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ServiceLevelNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ServiceLevelNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterServiceLevelName(s)
	}
}

func (s *ServiceLevelNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitServiceLevelName(s)
	}
}

func (p *CqlParser) ServiceLevelName() (localctx IServiceLevelNameContext) {
	localctx = NewServiceLevelNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 324, CqlParserRULE_serviceLevelName)
	p.SetState(2539)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case CqlParserOBJECT_NAME:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2537)
			p.Match(CqlParserOBJECT_NAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case CqlParserSTRING_LITERAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2538)
			p.StringLiteral()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IServiceLevelContext is an interface to support dynamic dispatch.
type IServiceLevelContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwService() IKwServiceContext
	KwLevel() IKwLevelContext

	// IsServiceLevelContext differentiates from other interfaces.
	IsServiceLevelContext()
}

type ServiceLevelContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyServiceLevelContext() *ServiceLevelContext {
	var p = new(ServiceLevelContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_serviceLevel
	return p
}

func InitEmptyServiceLevelContext(p *ServiceLevelContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_serviceLevel
}

func (*ServiceLevelContext) IsServiceLevelContext() {}

func NewServiceLevelContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ServiceLevelContext {
	var p = new(ServiceLevelContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_serviceLevel

	return p
}

func (s *ServiceLevelContext) GetParser() antlr.Parser { return s.parser }

func (s *ServiceLevelContext) KwService() IKwServiceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwServiceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwServiceContext)
}

func (s *ServiceLevelContext) KwLevel() IKwLevelContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwLevelContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwLevelContext)
}

func (s *ServiceLevelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ServiceLevelContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ServiceLevelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterServiceLevel(s)
	}
}

func (s *ServiceLevelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitServiceLevel(s)
	}
}

func (p *CqlParser) ServiceLevel() (localctx IServiceLevelContext) {
	localctx = NewServiceLevelContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 326, CqlParserRULE_serviceLevel)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2541)
		p.KwService()
	}
	{
		p.SetState(2542)
		p.KwLevel()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IServiceLevelsContext is an interface to support dynamic dispatch.
type IServiceLevelsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwService() IKwServiceContext
	KwLevels() IKwLevelsContext

	// IsServiceLevelsContext differentiates from other interfaces.
	IsServiceLevelsContext()
}

type ServiceLevelsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyServiceLevelsContext() *ServiceLevelsContext {
	var p = new(ServiceLevelsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_serviceLevels
	return p
}

func InitEmptyServiceLevelsContext(p *ServiceLevelsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_serviceLevels
}

func (*ServiceLevelsContext) IsServiceLevelsContext() {}

func NewServiceLevelsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ServiceLevelsContext {
	var p = new(ServiceLevelsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_serviceLevels

	return p
}

func (s *ServiceLevelsContext) GetParser() antlr.Parser { return s.parser }

func (s *ServiceLevelsContext) KwService() IKwServiceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwServiceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwServiceContext)
}

func (s *ServiceLevelsContext) KwLevels() IKwLevelsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwLevelsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwLevelsContext)
}

func (s *ServiceLevelsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ServiceLevelsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ServiceLevelsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterServiceLevels(s)
	}
}

func (s *ServiceLevelsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitServiceLevels(s)
	}
}

func (p *CqlParser) ServiceLevels() (localctx IServiceLevelsContext) {
	localctx = NewServiceLevelsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 328, CqlParserRULE_serviceLevels)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2544)
		p.KwService()
	}
	{
		p.SetState(2545)
		p.KwLevels()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateServiceLevelContext is an interface to support dynamic dispatch.
type ICreateServiceLevelContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwCreate() IKwCreateContext
	ServiceLevel() IServiceLevelContext
	ServiceLevelName() IServiceLevelNameContext
	IfNotExist() IIfNotExistContext
	KwWith() IKwWithContext
	PropertyList() IPropertyListContext

	// IsCreateServiceLevelContext differentiates from other interfaces.
	IsCreateServiceLevelContext()
}

type CreateServiceLevelContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateServiceLevelContext() *CreateServiceLevelContext {
	var p = new(CreateServiceLevelContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_createServiceLevel
	return p
}

func InitEmptyCreateServiceLevelContext(p *CreateServiceLevelContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_createServiceLevel
}

func (*CreateServiceLevelContext) IsCreateServiceLevelContext() {}

func NewCreateServiceLevelContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateServiceLevelContext {
	var p = new(CreateServiceLevelContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_createServiceLevel

	return p
}

func (s *CreateServiceLevelContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateServiceLevelContext) KwCreate() IKwCreateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwCreateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwCreateContext)
}

func (s *CreateServiceLevelContext) ServiceLevel() IServiceLevelContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IServiceLevelContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IServiceLevelContext)
}

func (s *CreateServiceLevelContext) ServiceLevelName() IServiceLevelNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IServiceLevelNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IServiceLevelNameContext)
}

func (s *CreateServiceLevelContext) IfNotExist() IIfNotExistContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistContext)
}

func (s *CreateServiceLevelContext) KwWith() IKwWithContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwWithContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwWithContext)
}

func (s *CreateServiceLevelContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *CreateServiceLevelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateServiceLevelContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateServiceLevelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterCreateServiceLevel(s)
	}
}

func (s *CreateServiceLevelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitCreateServiceLevel(s)
	}
}

func (p *CqlParser) CreateServiceLevel() (localctx ICreateServiceLevelContext) {
	localctx = NewCreateServiceLevelContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 330, CqlParserRULE_createServiceLevel)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2547)
		p.KwCreate()
	}
	{
		p.SetState(2548)
		p.ServiceLevel()
	}
	p.SetState(2550)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CqlParserK_IF {
		{
			p.SetState(2549)
			p.IfNotExist()
		}

	}
	{
		p.SetState(2552)
		p.ServiceLevelName()
	}
	p.SetState(2556)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CqlParserK_WITH {
		{
			p.SetState(2553)
			p.KwWith()
		}
		{
			p.SetState(2554)
			p.PropertyList()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterServiceLevelContext is an interface to support dynamic dispatch.
type IAlterServiceLevelContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwAlter() IKwAlterContext
	ServiceLevel() IServiceLevelContext
	ServiceLevelName() IServiceLevelNameContext
	KwWith() IKwWithContext
	PropertyList() IPropertyListContext

	// IsAlterServiceLevelContext differentiates from other interfaces.
	IsAlterServiceLevelContext()
}

type AlterServiceLevelContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterServiceLevelContext() *AlterServiceLevelContext {
	var p = new(AlterServiceLevelContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_alterServiceLevel
	return p
}

func InitEmptyAlterServiceLevelContext(p *AlterServiceLevelContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_alterServiceLevel
}

func (*AlterServiceLevelContext) IsAlterServiceLevelContext() {}

func NewAlterServiceLevelContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterServiceLevelContext {
	var p = new(AlterServiceLevelContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_alterServiceLevel

	return p
}

func (s *AlterServiceLevelContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterServiceLevelContext) KwAlter() IKwAlterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwAlterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwAlterContext)
}

func (s *AlterServiceLevelContext) ServiceLevel() IServiceLevelContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IServiceLevelContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IServiceLevelContext)
}

func (s *AlterServiceLevelContext) ServiceLevelName() IServiceLevelNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IServiceLevelNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IServiceLevelNameContext)
}

func (s *AlterServiceLevelContext) KwWith() IKwWithContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwWithContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwWithContext)
}

func (s *AlterServiceLevelContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *AlterServiceLevelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterServiceLevelContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterServiceLevelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterAlterServiceLevel(s)
	}
}

func (s *AlterServiceLevelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitAlterServiceLevel(s)
	}
}

func (p *CqlParser) AlterServiceLevel() (localctx IAlterServiceLevelContext) {
	localctx = NewAlterServiceLevelContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 332, CqlParserRULE_alterServiceLevel)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2558)
		p.KwAlter()
	}
	{
		p.SetState(2559)
		p.ServiceLevel()
	}
	{
		p.SetState(2560)
		p.ServiceLevelName()
	}
	{
		p.SetState(2561)
		p.KwWith()
	}
	{
		p.SetState(2562)
		p.PropertyList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropServiceLevelContext is an interface to support dynamic dispatch.
type IDropServiceLevelContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwDrop() IKwDropContext
	ServiceLevel() IServiceLevelContext
	ServiceLevelName() IServiceLevelNameContext
	IfExist() IIfExistContext

	// IsDropServiceLevelContext differentiates from other interfaces.
	IsDropServiceLevelContext()
}

type DropServiceLevelContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropServiceLevelContext() *DropServiceLevelContext {
	var p = new(DropServiceLevelContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_dropServiceLevel
	return p
}

func InitEmptyDropServiceLevelContext(p *DropServiceLevelContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_dropServiceLevel
}

func (*DropServiceLevelContext) IsDropServiceLevelContext() {}

func NewDropServiceLevelContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropServiceLevelContext {
	var p = new(DropServiceLevelContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_dropServiceLevel

	return p
}

func (s *DropServiceLevelContext) GetParser() antlr.Parser { return s.parser }

func (s *DropServiceLevelContext) KwDrop() IKwDropContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwDropContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwDropContext)
}

func (s *DropServiceLevelContext) ServiceLevel() IServiceLevelContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IServiceLevelContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IServiceLevelContext)
}

func (s *DropServiceLevelContext) ServiceLevelName() IServiceLevelNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IServiceLevelNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IServiceLevelNameContext)
}

func (s *DropServiceLevelContext) IfExist() IIfExistContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistContext)
}

func (s *DropServiceLevelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropServiceLevelContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropServiceLevelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterDropServiceLevel(s)
	}
}

func (s *DropServiceLevelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitDropServiceLevel(s)
	}
}

func (p *CqlParser) DropServiceLevel() (localctx IDropServiceLevelContext) {
	localctx = NewDropServiceLevelContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 334, CqlParserRULE_dropServiceLevel)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2564)
		p.KwDrop()
	}
	{
		p.SetState(2565)
		p.ServiceLevel()
	}
	p.SetState(2567)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CqlParserK_IF {
		{
			p.SetState(2566)
			p.IfExist()
		}

	}
	{
		p.SetState(2569)
		p.ServiceLevelName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAttachServiceLevelContext is an interface to support dynamic dispatch.
type IAttachServiceLevelContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwAttach() IKwAttachContext
	ServiceLevel() IServiceLevelContext
	AllServiceLevelName() []IServiceLevelNameContext
	ServiceLevelName(i int) IServiceLevelNameContext
	KwTo() IKwToContext

	// IsAttachServiceLevelContext differentiates from other interfaces.
	IsAttachServiceLevelContext()
}

type AttachServiceLevelContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttachServiceLevelContext() *AttachServiceLevelContext {
	var p = new(AttachServiceLevelContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_attachServiceLevel
	return p
}

func InitEmptyAttachServiceLevelContext(p *AttachServiceLevelContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_attachServiceLevel
}

func (*AttachServiceLevelContext) IsAttachServiceLevelContext() {}

func NewAttachServiceLevelContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AttachServiceLevelContext {
	var p = new(AttachServiceLevelContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_attachServiceLevel

	return p
}

func (s *AttachServiceLevelContext) GetParser() antlr.Parser { return s.parser }

func (s *AttachServiceLevelContext) KwAttach() IKwAttachContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwAttachContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwAttachContext)
}

func (s *AttachServiceLevelContext) ServiceLevel() IServiceLevelContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IServiceLevelContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IServiceLevelContext)
}

func (s *AttachServiceLevelContext) AllServiceLevelName() []IServiceLevelNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IServiceLevelNameContext); ok {
			len++
		}
	}

	tst := make([]IServiceLevelNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IServiceLevelNameContext); ok {
			tst[i] = t.(IServiceLevelNameContext)
			i++
		}
	}

	return tst
}

func (s *AttachServiceLevelContext) ServiceLevelName(i int) IServiceLevelNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IServiceLevelNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IServiceLevelNameContext)
}

func (s *AttachServiceLevelContext) KwTo() IKwToContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwToContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwToContext)
}

func (s *AttachServiceLevelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AttachServiceLevelContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AttachServiceLevelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterAttachServiceLevel(s)
	}
}

func (s *AttachServiceLevelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitAttachServiceLevel(s)
	}
}

func (p *CqlParser) AttachServiceLevel() (localctx IAttachServiceLevelContext) {
	localctx = NewAttachServiceLevelContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 336, CqlParserRULE_attachServiceLevel)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2571)
		p.KwAttach()
	}
	{
		p.SetState(2572)
		p.ServiceLevel()
	}
	{
		p.SetState(2573)
		p.ServiceLevelName()
	}
	{
		p.SetState(2574)
		p.KwTo()
	}
	{
		p.SetState(2575)
		p.ServiceLevelName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDetachServiceLevelContext is an interface to support dynamic dispatch.
type IDetachServiceLevelContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwDetach() IKwDetachContext
	ServiceLevel() IServiceLevelContext
	KwFrom() IKwFromContext
	ServiceLevelName() IServiceLevelNameContext

	// IsDetachServiceLevelContext differentiates from other interfaces.
	IsDetachServiceLevelContext()
}

type DetachServiceLevelContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDetachServiceLevelContext() *DetachServiceLevelContext {
	var p = new(DetachServiceLevelContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_detachServiceLevel
	return p
}

func InitEmptyDetachServiceLevelContext(p *DetachServiceLevelContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_detachServiceLevel
}

func (*DetachServiceLevelContext) IsDetachServiceLevelContext() {}

func NewDetachServiceLevelContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DetachServiceLevelContext {
	var p = new(DetachServiceLevelContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_detachServiceLevel

	return p
}

func (s *DetachServiceLevelContext) GetParser() antlr.Parser { return s.parser }

func (s *DetachServiceLevelContext) KwDetach() IKwDetachContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwDetachContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwDetachContext)
}

func (s *DetachServiceLevelContext) ServiceLevel() IServiceLevelContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IServiceLevelContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IServiceLevelContext)
}

func (s *DetachServiceLevelContext) KwFrom() IKwFromContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwFromContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwFromContext)
}

func (s *DetachServiceLevelContext) ServiceLevelName() IServiceLevelNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IServiceLevelNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IServiceLevelNameContext)
}

func (s *DetachServiceLevelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DetachServiceLevelContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DetachServiceLevelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterDetachServiceLevel(s)
	}
}

func (s *DetachServiceLevelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitDetachServiceLevel(s)
	}
}

func (p *CqlParser) DetachServiceLevel() (localctx IDetachServiceLevelContext) {
	localctx = NewDetachServiceLevelContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 338, CqlParserRULE_detachServiceLevel)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2577)
		p.KwDetach()
	}
	{
		p.SetState(2578)
		p.ServiceLevel()
	}
	{
		p.SetState(2579)
		p.KwFrom()
	}
	{
		p.SetState(2580)
		p.ServiceLevelName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IListServiceLevelContext is an interface to support dynamic dispatch.
type IListServiceLevelContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwList() IKwListContext
	ServiceLevel() IServiceLevelContext
	ServiceLevelName() IServiceLevelNameContext
	KwAll() IKwAllContext
	ServiceLevels() IServiceLevelsContext
	KwAttached() IKwAttachedContext
	KwOf() IKwOfContext
	KwEffective() IKwEffectiveContext

	// IsListServiceLevelContext differentiates from other interfaces.
	IsListServiceLevelContext()
}

type ListServiceLevelContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyListServiceLevelContext() *ListServiceLevelContext {
	var p = new(ListServiceLevelContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_listServiceLevel
	return p
}

func InitEmptyListServiceLevelContext(p *ListServiceLevelContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_listServiceLevel
}

func (*ListServiceLevelContext) IsListServiceLevelContext() {}

func NewListServiceLevelContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ListServiceLevelContext {
	var p = new(ListServiceLevelContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_listServiceLevel

	return p
}

func (s *ListServiceLevelContext) GetParser() antlr.Parser { return s.parser }

func (s *ListServiceLevelContext) KwList() IKwListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwListContext)
}

func (s *ListServiceLevelContext) ServiceLevel() IServiceLevelContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IServiceLevelContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IServiceLevelContext)
}

func (s *ListServiceLevelContext) ServiceLevelName() IServiceLevelNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IServiceLevelNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IServiceLevelNameContext)
}

func (s *ListServiceLevelContext) KwAll() IKwAllContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwAllContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwAllContext)
}

func (s *ListServiceLevelContext) ServiceLevels() IServiceLevelsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IServiceLevelsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IServiceLevelsContext)
}

func (s *ListServiceLevelContext) KwAttached() IKwAttachedContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwAttachedContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwAttachedContext)
}

func (s *ListServiceLevelContext) KwOf() IKwOfContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwOfContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwOfContext)
}

func (s *ListServiceLevelContext) KwEffective() IKwEffectiveContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwEffectiveContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwEffectiveContext)
}

func (s *ListServiceLevelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListServiceLevelContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ListServiceLevelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterListServiceLevel(s)
	}
}

func (s *ListServiceLevelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitListServiceLevel(s)
	}
}

func (p *CqlParser) ListServiceLevel() (localctx IListServiceLevelContext) {
	localctx = NewListServiceLevelContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 340, CqlParserRULE_listServiceLevel)
	p.SetState(2602)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 226, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2582)
			p.KwList()
		}
		{
			p.SetState(2583)
			p.ServiceLevel()
		}
		{
			p.SetState(2584)
			p.ServiceLevelName()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2586)
			p.KwList()
		}
		{
			p.SetState(2587)
			p.KwAll()
		}
		{
			p.SetState(2588)
			p.ServiceLevels()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2590)
			p.KwList()
		}
		{
			p.SetState(2591)
			p.KwAttached()
		}
		{
			p.SetState(2592)
			p.ServiceLevel()
		}
		{
			p.SetState(2593)
			p.KwOf()
		}
		{
			p.SetState(2594)
			p.ServiceLevelName()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2596)
			p.KwList()
		}
		{
			p.SetState(2597)
			p.KwEffective()
		}
		{
			p.SetState(2598)
			p.ServiceLevel()
		}
		{
			p.SetState(2599)
			p.KwOf()
		}
		{
			p.SetState(2600)
			p.ServiceLevelName()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyListContext is an interface to support dynamic dispatch.
type IPropertyListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllProperty() []IPropertyContext
	Property(i int) IPropertyContext
	AllKwAnd() []IKwAndContext
	KwAnd(i int) IKwAndContext

	// IsPropertyListContext differentiates from other interfaces.
	IsPropertyListContext()
}

type PropertyListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyListContext() *PropertyListContext {
	var p = new(PropertyListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_propertyList
	return p
}

func InitEmptyPropertyListContext(p *PropertyListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_propertyList
}

func (*PropertyListContext) IsPropertyListContext() {}

func NewPropertyListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyListContext {
	var p = new(PropertyListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_propertyList

	return p
}

func (s *PropertyListContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyListContext) AllProperty() []IPropertyContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPropertyContext); ok {
			len++
		}
	}

	tst := make([]IPropertyContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPropertyContext); ok {
			tst[i] = t.(IPropertyContext)
			i++
		}
	}

	return tst
}

func (s *PropertyListContext) Property(i int) IPropertyContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyContext)
}

func (s *PropertyListContext) AllKwAnd() []IKwAndContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IKwAndContext); ok {
			len++
		}
	}

	tst := make([]IKwAndContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IKwAndContext); ok {
			tst[i] = t.(IKwAndContext)
			i++
		}
	}

	return tst
}

func (s *PropertyListContext) KwAnd(i int) IKwAndContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwAndContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwAndContext)
}

func (s *PropertyListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterPropertyList(s)
	}
}

func (s *PropertyListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitPropertyList(s)
	}
}

func (p *CqlParser) PropertyList() (localctx IPropertyListContext) {
	localctx = NewPropertyListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 342, CqlParserRULE_propertyList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2604)
		p.Property()
	}
	p.SetState(2610)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == CqlParserK_AND {
		{
			p.SetState(2605)
			p.KwAnd()
		}
		{
			p.SetState(2606)
			p.Property()
		}

		p.SetState(2612)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyContext is an interface to support dynamic dispatch.
type IPropertyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PropertyName() IPropertyNameContext
	OPERATOR_EQ() antlr.TerminalNode
	PropertyValue() IPropertyValueContext

	// IsPropertyContext differentiates from other interfaces.
	IsPropertyContext()
}

type PropertyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyContext() *PropertyContext {
	var p = new(PropertyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_property
	return p
}

func InitEmptyPropertyContext(p *PropertyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_property
}

func (*PropertyContext) IsPropertyContext() {}

func NewPropertyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyContext {
	var p = new(PropertyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_property

	return p
}

func (s *PropertyContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyContext) PropertyName() IPropertyNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyNameContext)
}

func (s *PropertyContext) OPERATOR_EQ() antlr.TerminalNode {
	return s.GetToken(CqlParserOPERATOR_EQ, 0)
}

func (s *PropertyContext) PropertyValue() IPropertyValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyValueContext)
}

func (s *PropertyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterProperty(s)
	}
}

func (s *PropertyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitProperty(s)
	}
}

func (p *CqlParser) Property() (localctx IPropertyContext) {
	localctx = NewPropertyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 344, CqlParserRULE_property)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2613)
		p.PropertyName()
	}
	{
		p.SetState(2614)
		p.Match(CqlParserOPERATOR_EQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2615)
		p.PropertyValue()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyNameContext is an interface to support dynamic dispatch.
type IPropertyNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OBJECT_NAME() antlr.TerminalNode
	KwTimeout() IKwTimeoutContext
	KwDefault() IKwDefaultContext

	// IsPropertyNameContext differentiates from other interfaces.
	IsPropertyNameContext()
}

type PropertyNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyNameContext() *PropertyNameContext {
	var p = new(PropertyNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_propertyName
	return p
}

func InitEmptyPropertyNameContext(p *PropertyNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_propertyName
}

func (*PropertyNameContext) IsPropertyNameContext() {}

func NewPropertyNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyNameContext {
	var p = new(PropertyNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_propertyName

	return p
}

func (s *PropertyNameContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyNameContext) OBJECT_NAME() antlr.TerminalNode {
	return s.GetToken(CqlParserOBJECT_NAME, 0)
}

func (s *PropertyNameContext) KwTimeout() IKwTimeoutContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwTimeoutContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwTimeoutContext)
}

func (s *PropertyNameContext) KwDefault() IKwDefaultContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwDefaultContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwDefaultContext)
}

func (s *PropertyNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterPropertyName(s)
	}
}

func (s *PropertyNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitPropertyName(s)
	}
}

func (p *CqlParser) PropertyName() (localctx IPropertyNameContext) {
	localctx = NewPropertyNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 346, CqlParserRULE_propertyName)
	p.SetState(2620)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case CqlParserOBJECT_NAME:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2617)
			p.Match(CqlParserOBJECT_NAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case CqlParserK_TIMEOUT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2618)
			p.KwTimeout()
		}

	case CqlParserK_DEFAULT:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2619)
			p.KwDefault()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyValueContext is an interface to support dynamic dispatch.
type IPropertyValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Constant() IConstantContext
	OBJECT_NAME() antlr.TerminalNode

	// IsPropertyValueContext differentiates from other interfaces.
	IsPropertyValueContext()
}

type PropertyValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyValueContext() *PropertyValueContext {
	var p = new(PropertyValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_propertyValue
	return p
}

func InitEmptyPropertyValueContext(p *PropertyValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_propertyValue
}

func (*PropertyValueContext) IsPropertyValueContext() {}

func NewPropertyValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyValueContext {
	var p = new(PropertyValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_propertyValue

	return p
}

func (s *PropertyValueContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyValueContext) Constant() IConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *PropertyValueContext) OBJECT_NAME() antlr.TerminalNode {
	return s.GetToken(CqlParserOBJECT_NAME, 0)
}

func (s *PropertyValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterPropertyValue(s)
	}
}

func (s *PropertyValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitPropertyValue(s)
	}
}

func (p *CqlParser) PropertyValue() (localctx IPropertyValueContext) {
	localctx = NewPropertyValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 348, CqlParserRULE_propertyValue)
	p.SetState(2624)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case CqlParserCOLON, CqlParserK_FALSE, CqlParserK_NULL, CqlParserK_TRUE, CqlParserK_EMPTY, CqlParserCODE_BLOCK, CqlParserSTRING_LITERAL, CqlParserDECIMAL_LITERAL, CqlParserFLOAT_LITERAL, CqlParserHEXADECIMAL_LITERAL, CqlParserQMARK, CqlParserDURATION_LITERAL, CqlParserUUID:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2622)
			p.Constant()
		}

	case CqlParserOBJECT_NAME:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2623)
			p.Match(CqlParserOBJECT_NAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPruneUsingSpecContext is an interface to support dynamic dispatch.
type IPruneUsingSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwUsing() IKwUsingContext
	KwTimeout() IKwTimeoutContext
	Constant() IConstantContext
	KwConcurrency() IKwConcurrencyContext
	DecimalLiteral() IDecimalLiteralContext
	KwAnd() IKwAndContext

	// IsPruneUsingSpecContext differentiates from other interfaces.
	IsPruneUsingSpecContext()
}

type PruneUsingSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPruneUsingSpecContext() *PruneUsingSpecContext {
	var p = new(PruneUsingSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_pruneUsingSpec
	return p
}

func InitEmptyPruneUsingSpecContext(p *PruneUsingSpecContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_pruneUsingSpec
}

func (*PruneUsingSpecContext) IsPruneUsingSpecContext() {}

func NewPruneUsingSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PruneUsingSpecContext {
	var p = new(PruneUsingSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_pruneUsingSpec

	return p
}

func (s *PruneUsingSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *PruneUsingSpecContext) KwUsing() IKwUsingContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwUsingContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwUsingContext)
}

func (s *PruneUsingSpecContext) KwTimeout() IKwTimeoutContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwTimeoutContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwTimeoutContext)
}

func (s *PruneUsingSpecContext) Constant() IConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *PruneUsingSpecContext) KwConcurrency() IKwConcurrencyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwConcurrencyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwConcurrencyContext)
}

func (s *PruneUsingSpecContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *PruneUsingSpecContext) KwAnd() IKwAndContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwAndContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwAndContext)
}

func (s *PruneUsingSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PruneUsingSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PruneUsingSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterPruneUsingSpec(s)
	}
}

func (s *PruneUsingSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitPruneUsingSpec(s)
	}
}

func (p *CqlParser) PruneUsingSpec() (localctx IPruneUsingSpecContext) {
	localctx = NewPruneUsingSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 350, CqlParserRULE_pruneUsingSpec)
	p.SetState(2648)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 230, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2626)
			p.KwUsing()
		}
		{
			p.SetState(2627)
			p.KwTimeout()
		}
		{
			p.SetState(2628)
			p.Constant()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2630)
			p.KwUsing()
		}
		{
			p.SetState(2631)
			p.KwConcurrency()
		}
		{
			p.SetState(2632)
			p.DecimalLiteral()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2634)
			p.KwUsing()
		}
		{
			p.SetState(2635)
			p.KwConcurrency()
		}
		{
			p.SetState(2636)
			p.DecimalLiteral()
		}
		{
			p.SetState(2637)
			p.KwAnd()
		}
		{
			p.SetState(2638)
			p.KwTimeout()
		}
		{
			p.SetState(2639)
			p.Constant()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2641)
			p.KwUsing()
		}
		{
			p.SetState(2642)
			p.KwTimeout()
		}
		{
			p.SetState(2643)
			p.Constant()
		}
		{
			p.SetState(2644)
			p.KwAnd()
		}
		{
			p.SetState(2645)
			p.KwConcurrency()
		}
		{
			p.SetState(2646)
			p.DecimalLiteral()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILimitSpecContext is an interface to support dynamic dispatch.
type ILimitSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwLimit() IKwLimitContext
	DecimalLiteral() IDecimalLiteralContext

	// IsLimitSpecContext differentiates from other interfaces.
	IsLimitSpecContext()
}

type LimitSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLimitSpecContext() *LimitSpecContext {
	var p = new(LimitSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_limitSpec
	return p
}

func InitEmptyLimitSpecContext(p *LimitSpecContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_limitSpec
}

func (*LimitSpecContext) IsLimitSpecContext() {}

func NewLimitSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LimitSpecContext {
	var p = new(LimitSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_limitSpec

	return p
}

func (s *LimitSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *LimitSpecContext) KwLimit() IKwLimitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwLimitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwLimitContext)
}

func (s *LimitSpecContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *LimitSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LimitSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LimitSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterLimitSpec(s)
	}
}

func (s *LimitSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitLimitSpec(s)
	}
}

func (p *CqlParser) LimitSpec() (localctx ILimitSpecContext) {
	localctx = NewLimitSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 352, CqlParserRULE_limitSpec)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2650)
		p.KwLimit()
	}
	{
		p.SetState(2651)
		p.DecimalLiteral()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFromSpecContext is an interface to support dynamic dispatch.
type IFromSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwFrom() IKwFromContext
	FromSpecElement() IFromSpecElementContext

	// IsFromSpecContext differentiates from other interfaces.
	IsFromSpecContext()
}

type FromSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFromSpecContext() *FromSpecContext {
	var p = new(FromSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_fromSpec
	return p
}

func InitEmptyFromSpecContext(p *FromSpecContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_fromSpec
}

func (*FromSpecContext) IsFromSpecContext() {}

func NewFromSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FromSpecContext {
	var p = new(FromSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_fromSpec

	return p
}

func (s *FromSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *FromSpecContext) KwFrom() IKwFromContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwFromContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwFromContext)
}

func (s *FromSpecContext) FromSpecElement() IFromSpecElementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFromSpecElementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFromSpecElementContext)
}

func (s *FromSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FromSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FromSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterFromSpec(s)
	}
}

func (s *FromSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitFromSpec(s)
	}
}

func (p *CqlParser) FromSpec() (localctx IFromSpecContext) {
	localctx = NewFromSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 354, CqlParserRULE_fromSpec)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2653)
		p.KwFrom()
	}
	{
		p.SetState(2654)
		p.FromSpecElement()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFromSpecElementContext is an interface to support dynamic dispatch.
type IFromSpecElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllOBJECT_NAME() []antlr.TerminalNode
	OBJECT_NAME(i int) antlr.TerminalNode
	ReservedKeywordAsTable() IReservedKeywordAsTableContext
	ReservedTypeAsTable() IReservedTypeAsTableContext
	DOT() antlr.TerminalNode

	// IsFromSpecElementContext differentiates from other interfaces.
	IsFromSpecElementContext()
}

type FromSpecElementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFromSpecElementContext() *FromSpecElementContext {
	var p = new(FromSpecElementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_fromSpecElement
	return p
}

func InitEmptyFromSpecElementContext(p *FromSpecElementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_fromSpecElement
}

func (*FromSpecElementContext) IsFromSpecElementContext() {}

func NewFromSpecElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FromSpecElementContext {
	var p = new(FromSpecElementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_fromSpecElement

	return p
}

func (s *FromSpecElementContext) GetParser() antlr.Parser { return s.parser }

func (s *FromSpecElementContext) AllOBJECT_NAME() []antlr.TerminalNode {
	return s.GetTokens(CqlParserOBJECT_NAME)
}

func (s *FromSpecElementContext) OBJECT_NAME(i int) antlr.TerminalNode {
	return s.GetToken(CqlParserOBJECT_NAME, i)
}

func (s *FromSpecElementContext) ReservedKeywordAsTable() IReservedKeywordAsTableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReservedKeywordAsTableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReservedKeywordAsTableContext)
}

func (s *FromSpecElementContext) ReservedTypeAsTable() IReservedTypeAsTableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReservedTypeAsTableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReservedTypeAsTableContext)
}

func (s *FromSpecElementContext) DOT() antlr.TerminalNode {
	return s.GetToken(CqlParserDOT, 0)
}

func (s *FromSpecElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FromSpecElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FromSpecElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterFromSpecElement(s)
	}
}

func (s *FromSpecElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitFromSpecElement(s)
	}
}

func (p *CqlParser) FromSpecElement() (localctx IFromSpecElementContext) {
	localctx = NewFromSpecElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 356, CqlParserRULE_fromSpecElement)
	p.SetState(2668)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 231, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2656)
			p.Match(CqlParserOBJECT_NAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2657)
			p.ReservedKeywordAsTable()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2658)
			p.ReservedTypeAsTable()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2659)
			p.Match(CqlParserOBJECT_NAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2660)
			p.Match(CqlParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2661)
			p.Match(CqlParserOBJECT_NAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2662)
			p.Match(CqlParserOBJECT_NAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2663)
			p.Match(CqlParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2664)
			p.ReservedKeywordAsTable()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2665)
			p.Match(CqlParserOBJECT_NAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2666)
			p.Match(CqlParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2667)
			p.ReservedTypeAsTable()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOrderSpecContext is an interface to support dynamic dispatch.
type IOrderSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwOrder() IKwOrderContext
	KwBy() IKwByContext
	OrderSpecElement() IOrderSpecElementContext

	// IsOrderSpecContext differentiates from other interfaces.
	IsOrderSpecContext()
}

type OrderSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrderSpecContext() *OrderSpecContext {
	var p = new(OrderSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_orderSpec
	return p
}

func InitEmptyOrderSpecContext(p *OrderSpecContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_orderSpec
}

func (*OrderSpecContext) IsOrderSpecContext() {}

func NewOrderSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OrderSpecContext {
	var p = new(OrderSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_orderSpec

	return p
}

func (s *OrderSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *OrderSpecContext) KwOrder() IKwOrderContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwOrderContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwOrderContext)
}

func (s *OrderSpecContext) KwBy() IKwByContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwByContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwByContext)
}

func (s *OrderSpecContext) OrderSpecElement() IOrderSpecElementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderSpecElementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderSpecElementContext)
}

func (s *OrderSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OrderSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OrderSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterOrderSpec(s)
	}
}

func (s *OrderSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitOrderSpec(s)
	}
}

func (p *CqlParser) OrderSpec() (localctx IOrderSpecContext) {
	localctx = NewOrderSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 358, CqlParserRULE_orderSpec)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2670)
		p.KwOrder()
	}
	{
		p.SetState(2671)
		p.KwBy()
	}
	{
		p.SetState(2672)
		p.OrderSpecElement()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOrderSpecElementContext is an interface to support dynamic dispatch.
type IOrderSpecElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OBJECT_NAME() antlr.TerminalNode
	KwAsc() IKwAscContext
	KwDesc() IKwDescContext
	KwAnn() IKwAnnContext
	KwOf() IKwOfContext
	VectorLiteral() IVectorLiteralContext

	// IsOrderSpecElementContext differentiates from other interfaces.
	IsOrderSpecElementContext()
}

type OrderSpecElementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrderSpecElementContext() *OrderSpecElementContext {
	var p = new(OrderSpecElementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_orderSpecElement
	return p
}

func InitEmptyOrderSpecElementContext(p *OrderSpecElementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_orderSpecElement
}

func (*OrderSpecElementContext) IsOrderSpecElementContext() {}

func NewOrderSpecElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OrderSpecElementContext {
	var p = new(OrderSpecElementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_orderSpecElement

	return p
}

func (s *OrderSpecElementContext) GetParser() antlr.Parser { return s.parser }

func (s *OrderSpecElementContext) OBJECT_NAME() antlr.TerminalNode {
	return s.GetToken(CqlParserOBJECT_NAME, 0)
}

func (s *OrderSpecElementContext) KwAsc() IKwAscContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwAscContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwAscContext)
}

func (s *OrderSpecElementContext) KwDesc() IKwDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwDescContext)
}

func (s *OrderSpecElementContext) KwAnn() IKwAnnContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwAnnContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwAnnContext)
}

func (s *OrderSpecElementContext) KwOf() IKwOfContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwOfContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwOfContext)
}

func (s *OrderSpecElementContext) VectorLiteral() IVectorLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVectorLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVectorLiteralContext)
}

func (s *OrderSpecElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OrderSpecElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OrderSpecElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterOrderSpecElement(s)
	}
}

func (s *OrderSpecElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitOrderSpecElement(s)
	}
}

func (p *CqlParser) OrderSpecElement() (localctx IOrderSpecElementContext) {
	localctx = NewOrderSpecElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 360, CqlParserRULE_orderSpecElement)
	p.SetState(2684)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 233, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2674)
			p.Match(CqlParserOBJECT_NAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2677)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		switch p.GetTokenStream().LA(1) {
		case CqlParserK_ASC:
			{
				p.SetState(2675)
				p.KwAsc()
			}

		case CqlParserK_DESC:
			{
				p.SetState(2676)
				p.KwDesc()
			}

		case CqlParserEOF, CqlParserSEMI, CqlParserMINUSMINUS, CqlParserK_ALLOW, CqlParserK_LIMIT, CqlParserK_PER, CqlParserK_USING, CqlParserK_BYPASS:

		default:
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2679)
			p.Match(CqlParserOBJECT_NAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2680)
			p.KwAnn()
		}
		{
			p.SetState(2681)
			p.KwOf()
		}
		{
			p.SetState(2682)
			p.VectorLiteral()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVectorLiteralContext is an interface to support dynamic dispatch.
type IVectorLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SyntaxBracketLs() ISyntaxBracketLsContext
	SyntaxBracketRs() ISyntaxBracketRsContext
	AllFloatLiteral() []IFloatLiteralContext
	FloatLiteral(i int) IFloatLiteralContext
	AllDecimalLiteral() []IDecimalLiteralContext
	DecimalLiteral(i int) IDecimalLiteralContext
	AllSyntaxComma() []ISyntaxCommaContext
	SyntaxComma(i int) ISyntaxCommaContext

	// IsVectorLiteralContext differentiates from other interfaces.
	IsVectorLiteralContext()
}

type VectorLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVectorLiteralContext() *VectorLiteralContext {
	var p = new(VectorLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_vectorLiteral
	return p
}

func InitEmptyVectorLiteralContext(p *VectorLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_vectorLiteral
}

func (*VectorLiteralContext) IsVectorLiteralContext() {}

func NewVectorLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VectorLiteralContext {
	var p = new(VectorLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_vectorLiteral

	return p
}

func (s *VectorLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *VectorLiteralContext) SyntaxBracketLs() ISyntaxBracketLsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxBracketLsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxBracketLsContext)
}

func (s *VectorLiteralContext) SyntaxBracketRs() ISyntaxBracketRsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxBracketRsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxBracketRsContext)
}

func (s *VectorLiteralContext) AllFloatLiteral() []IFloatLiteralContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFloatLiteralContext); ok {
			len++
		}
	}

	tst := make([]IFloatLiteralContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFloatLiteralContext); ok {
			tst[i] = t.(IFloatLiteralContext)
			i++
		}
	}

	return tst
}

func (s *VectorLiteralContext) FloatLiteral(i int) IFloatLiteralContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFloatLiteralContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFloatLiteralContext)
}

func (s *VectorLiteralContext) AllDecimalLiteral() []IDecimalLiteralContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			len++
		}
	}

	tst := make([]IDecimalLiteralContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDecimalLiteralContext); ok {
			tst[i] = t.(IDecimalLiteralContext)
			i++
		}
	}

	return tst
}

func (s *VectorLiteralContext) DecimalLiteral(i int) IDecimalLiteralContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *VectorLiteralContext) AllSyntaxComma() []ISyntaxCommaContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			len++
		}
	}

	tst := make([]ISyntaxCommaContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISyntaxCommaContext); ok {
			tst[i] = t.(ISyntaxCommaContext)
			i++
		}
	}

	return tst
}

func (s *VectorLiteralContext) SyntaxComma(i int) ISyntaxCommaContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxCommaContext)
}

func (s *VectorLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VectorLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VectorLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterVectorLiteral(s)
	}
}

func (s *VectorLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitVectorLiteral(s)
	}
}

func (p *CqlParser) VectorLiteral() (localctx IVectorLiteralContext) {
	localctx = NewVectorLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 362, CqlParserRULE_vectorLiteral)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2686)
		p.SyntaxBracketLs()
	}
	p.SetState(2689)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 234, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2687)
			p.FloatLiteral()
		}

	case 2:
		{
			p.SetState(2688)
			p.DecimalLiteral()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(2698)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == CqlParserCOMMA {
		{
			p.SetState(2691)
			p.SyntaxComma()
		}
		p.SetState(2694)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 235, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(2692)
				p.FloatLiteral()
			}

		case 2:
			{
				p.SetState(2693)
				p.DecimalLiteral()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

		p.SetState(2700)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2701)
		p.SyntaxBracketRs()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWhereSpecContext is an interface to support dynamic dispatch.
type IWhereSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwWhere() IKwWhereContext
	RelationElements() IRelationElementsContext

	// IsWhereSpecContext differentiates from other interfaces.
	IsWhereSpecContext()
}

type WhereSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhereSpecContext() *WhereSpecContext {
	var p = new(WhereSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_whereSpec
	return p
}

func InitEmptyWhereSpecContext(p *WhereSpecContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_whereSpec
}

func (*WhereSpecContext) IsWhereSpecContext() {}

func NewWhereSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhereSpecContext {
	var p = new(WhereSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_whereSpec

	return p
}

func (s *WhereSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *WhereSpecContext) KwWhere() IKwWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwWhereContext)
}

func (s *WhereSpecContext) RelationElements() IRelationElementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationElementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationElementsContext)
}

func (s *WhereSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhereSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhereSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterWhereSpec(s)
	}
}

func (s *WhereSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitWhereSpec(s)
	}
}

func (p *CqlParser) WhereSpec() (localctx IWhereSpecContext) {
	localctx = NewWhereSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 364, CqlParserRULE_whereSpec)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2703)
		p.KwWhere()
	}
	{
		p.SetState(2704)
		p.RelationElements()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDistinctSpecContext is an interface to support dynamic dispatch.
type IDistinctSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwDistinct() IKwDistinctContext

	// IsDistinctSpecContext differentiates from other interfaces.
	IsDistinctSpecContext()
}

type DistinctSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDistinctSpecContext() *DistinctSpecContext {
	var p = new(DistinctSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_distinctSpec
	return p
}

func InitEmptyDistinctSpecContext(p *DistinctSpecContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_distinctSpec
}

func (*DistinctSpecContext) IsDistinctSpecContext() {}

func NewDistinctSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DistinctSpecContext {
	var p = new(DistinctSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_distinctSpec

	return p
}

func (s *DistinctSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *DistinctSpecContext) KwDistinct() IKwDistinctContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwDistinctContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwDistinctContext)
}

func (s *DistinctSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DistinctSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DistinctSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterDistinctSpec(s)
	}
}

func (s *DistinctSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitDistinctSpec(s)
	}
}

func (p *CqlParser) DistinctSpec() (localctx IDistinctSpecContext) {
	localctx = NewDistinctSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 366, CqlParserRULE_distinctSpec)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2706)
		p.KwDistinct()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelectElementsContext is an interface to support dynamic dispatch.
type ISelectElementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetStar returns the star token.
	GetStar() antlr.Token

	// SetStar sets the star token.
	SetStar(antlr.Token)

	// Getter signatures
	AllSelectElement() []ISelectElementContext
	SelectElement(i int) ISelectElementContext
	STAR() antlr.TerminalNode
	AllSyntaxComma() []ISyntaxCommaContext
	SyntaxComma(i int) ISyntaxCommaContext

	// IsSelectElementsContext differentiates from other interfaces.
	IsSelectElementsContext()
}

type SelectElementsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	star   antlr.Token
}

func NewEmptySelectElementsContext() *SelectElementsContext {
	var p = new(SelectElementsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_selectElements
	return p
}

func InitEmptySelectElementsContext(p *SelectElementsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_selectElements
}

func (*SelectElementsContext) IsSelectElementsContext() {}

func NewSelectElementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectElementsContext {
	var p = new(SelectElementsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_selectElements

	return p
}

func (s *SelectElementsContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectElementsContext) GetStar() antlr.Token { return s.star }

func (s *SelectElementsContext) SetStar(v antlr.Token) { s.star = v }

func (s *SelectElementsContext) AllSelectElement() []ISelectElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISelectElementContext); ok {
			len++
		}
	}

	tst := make([]ISelectElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISelectElementContext); ok {
			tst[i] = t.(ISelectElementContext)
			i++
		}
	}

	return tst
}

func (s *SelectElementsContext) SelectElement(i int) ISelectElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectElementContext)
}

func (s *SelectElementsContext) STAR() antlr.TerminalNode {
	return s.GetToken(CqlParserSTAR, 0)
}

func (s *SelectElementsContext) AllSyntaxComma() []ISyntaxCommaContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			len++
		}
	}

	tst := make([]ISyntaxCommaContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISyntaxCommaContext); ok {
			tst[i] = t.(ISyntaxCommaContext)
			i++
		}
	}

	return tst
}

func (s *SelectElementsContext) SyntaxComma(i int) ISyntaxCommaContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxCommaContext)
}

func (s *SelectElementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectElementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectElementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterSelectElements(s)
	}
}

func (s *SelectElementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitSelectElements(s)
	}
}

func (p *CqlParser) SelectElements() (localctx ISelectElementsContext) {
	localctx = NewSelectElementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 368, CqlParserRULE_selectElements)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2710)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case CqlParserSTAR:
		{
			p.SetState(2708)

			var _m = p.Match(CqlParserSTAR)

			localctx.(*SelectElementsContext).star = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case CqlParserK_KEY, CqlParserK_PASSWORD, CqlParserK_ROLE, CqlParserK_STATIC, CqlParserK_TIMESTAMP, CqlParserK_TOKEN, CqlParserK_TTL, CqlParserK_TWO, CqlParserK_TYPE, CqlParserK_USER, CqlParserK_UUID, CqlParserK_VALUES, CqlParserK_WRITETIME, CqlParserK_TEXT, CqlParserK_TIME, CqlParserK_CAST, CqlParserK_VALUE, CqlParserOBJECT_NAME:
		{
			p.SetState(2709)
			p.SelectElement()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(2717)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == CqlParserCOMMA {
		{
			p.SetState(2712)
			p.SyntaxComma()
		}
		{
			p.SetState(2713)
			p.SelectElement()
		}

		p.SetState(2719)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelectElementContext is an interface to support dynamic dispatch.
type ISelectElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OBJECT_NAME() antlr.TerminalNode
	DOT() antlr.TerminalNode
	STAR() antlr.TerminalNode
	ColumnRef() IColumnRefContext
	KwAs() IKwAsContext
	FunctionCall() IFunctionCallContext
	CastCall() ICastCallContext
	QualifiedFunctionCall() IQualifiedFunctionCallContext

	// IsSelectElementContext differentiates from other interfaces.
	IsSelectElementContext()
}

type SelectElementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectElementContext() *SelectElementContext {
	var p = new(SelectElementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_selectElement
	return p
}

func InitEmptySelectElementContext(p *SelectElementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_selectElement
}

func (*SelectElementContext) IsSelectElementContext() {}

func NewSelectElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectElementContext {
	var p = new(SelectElementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_selectElement

	return p
}

func (s *SelectElementContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectElementContext) OBJECT_NAME() antlr.TerminalNode {
	return s.GetToken(CqlParserOBJECT_NAME, 0)
}

func (s *SelectElementContext) DOT() antlr.TerminalNode {
	return s.GetToken(CqlParserDOT, 0)
}

func (s *SelectElementContext) STAR() antlr.TerminalNode {
	return s.GetToken(CqlParserSTAR, 0)
}

func (s *SelectElementContext) ColumnRef() IColumnRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnRefContext)
}

func (s *SelectElementContext) KwAs() IKwAsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwAsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwAsContext)
}

func (s *SelectElementContext) FunctionCall() IFunctionCallContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionCallContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionCallContext)
}

func (s *SelectElementContext) CastCall() ICastCallContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICastCallContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICastCallContext)
}

func (s *SelectElementContext) QualifiedFunctionCall() IQualifiedFunctionCallContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedFunctionCallContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedFunctionCallContext)
}

func (s *SelectElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterSelectElement(s)
	}
}

func (s *SelectElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitSelectElement(s)
	}
}

func (p *CqlParser) SelectElement() (localctx ISelectElementContext) {
	localctx = NewSelectElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 370, CqlParserRULE_selectElement)
	var _la int

	p.SetState(2747)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 243, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2720)
			p.Match(CqlParserOBJECT_NAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2721)
			p.Match(CqlParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2722)
			p.Match(CqlParserSTAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2723)
			p.ColumnRef()
		}
		p.SetState(2727)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == CqlParserK_AS {
			{
				p.SetState(2724)
				p.KwAs()
			}
			{
				p.SetState(2725)
				p.Match(CqlParserOBJECT_NAME)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2729)
			p.FunctionCall()
		}
		p.SetState(2733)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == CqlParserK_AS {
			{
				p.SetState(2730)
				p.KwAs()
			}
			{
				p.SetState(2731)
				p.Match(CqlParserOBJECT_NAME)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2735)
			p.CastCall()
		}
		p.SetState(2739)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == CqlParserK_AS {
			{
				p.SetState(2736)
				p.KwAs()
			}
			{
				p.SetState(2737)
				p.Match(CqlParserOBJECT_NAME)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2741)
			p.QualifiedFunctionCall()
		}
		p.SetState(2745)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == CqlParserK_AS {
			{
				p.SetState(2742)
				p.KwAs()
			}
			{
				p.SetState(2743)
				p.Match(CqlParserOBJECT_NAME)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRelationElementsContext is an interface to support dynamic dispatch.
type IRelationElementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllRelationElement() []IRelationElementContext
	RelationElement(i int) IRelationElementContext
	AllKwAnd() []IKwAndContext
	KwAnd(i int) IKwAndContext

	// IsRelationElementsContext differentiates from other interfaces.
	IsRelationElementsContext()
}

type RelationElementsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationElementsContext() *RelationElementsContext {
	var p = new(RelationElementsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_relationElements
	return p
}

func InitEmptyRelationElementsContext(p *RelationElementsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_relationElements
}

func (*RelationElementsContext) IsRelationElementsContext() {}

func NewRelationElementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationElementsContext {
	var p = new(RelationElementsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_relationElements

	return p
}

func (s *RelationElementsContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationElementsContext) AllRelationElement() []IRelationElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRelationElementContext); ok {
			len++
		}
	}

	tst := make([]IRelationElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRelationElementContext); ok {
			tst[i] = t.(IRelationElementContext)
			i++
		}
	}

	return tst
}

func (s *RelationElementsContext) RelationElement(i int) IRelationElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationElementContext)
}

func (s *RelationElementsContext) AllKwAnd() []IKwAndContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IKwAndContext); ok {
			len++
		}
	}

	tst := make([]IKwAndContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IKwAndContext); ok {
			tst[i] = t.(IKwAndContext)
			i++
		}
	}

	return tst
}

func (s *RelationElementsContext) KwAnd(i int) IKwAndContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwAndContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwAndContext)
}

func (s *RelationElementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationElementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RelationElementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterRelationElements(s)
	}
}

func (s *RelationElementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitRelationElements(s)
	}
}

func (p *CqlParser) RelationElements() (localctx IRelationElementsContext) {
	localctx = NewRelationElementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 372, CqlParserRULE_relationElements)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2749)
		p.RelationElement()
	}

	p.SetState(2755)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == CqlParserK_AND {
		{
			p.SetState(2750)
			p.KwAnd()
		}
		{
			p.SetState(2751)
			p.RelationElement()
		}

		p.SetState(2757)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRelationElementContext is an interface to support dynamic dispatch.
type IRelationElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllColumnRef() []IColumnRefContext
	ColumnRef(i int) IColumnRefContext
	Constant() IConstantContext
	OPERATOR_EQ() antlr.TerminalNode
	OPERATOR_LT() antlr.TerminalNode
	OPERATOR_GT() antlr.TerminalNode
	OPERATOR_LTE() antlr.TerminalNode
	OPERATOR_GTE() antlr.TerminalNode
	AllFunctionCall() []IFunctionCallContext
	FunctionCall(i int) IFunctionCallContext
	DOT() antlr.TerminalNode
	OBJECT_NAME() antlr.TerminalNode
	KwIn() IKwInContext
	AllLR_BRACKET() []antlr.TerminalNode
	LR_BRACKET(i int) antlr.TerminalNode
	AllRR_BRACKET() []antlr.TerminalNode
	RR_BRACKET(i int) antlr.TerminalNode
	FunctionArgs() IFunctionArgsContext
	AllAssignmentTuple() []IAssignmentTupleContext
	AssignmentTuple(i int) IAssignmentTupleContext
	AllSyntaxComma() []ISyntaxCommaContext
	SyntaxComma(i int) ISyntaxCommaContext
	ScyllaClusteringBound() IScyllaClusteringBoundContext
	RelalationContainsKey() IRelalationContainsKeyContext
	RelalationContains() IRelalationContainsContext
	KwLike() IKwLikeContext

	// IsRelationElementContext differentiates from other interfaces.
	IsRelationElementContext()
}

type RelationElementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationElementContext() *RelationElementContext {
	var p = new(RelationElementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_relationElement
	return p
}

func InitEmptyRelationElementContext(p *RelationElementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_relationElement
}

func (*RelationElementContext) IsRelationElementContext() {}

func NewRelationElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationElementContext {
	var p = new(RelationElementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_relationElement

	return p
}

func (s *RelationElementContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationElementContext) AllColumnRef() []IColumnRefContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnRefContext); ok {
			len++
		}
	}

	tst := make([]IColumnRefContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnRefContext); ok {
			tst[i] = t.(IColumnRefContext)
			i++
		}
	}

	return tst
}

func (s *RelationElementContext) ColumnRef(i int) IColumnRefContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnRefContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnRefContext)
}

func (s *RelationElementContext) Constant() IConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *RelationElementContext) OPERATOR_EQ() antlr.TerminalNode {
	return s.GetToken(CqlParserOPERATOR_EQ, 0)
}

func (s *RelationElementContext) OPERATOR_LT() antlr.TerminalNode {
	return s.GetToken(CqlParserOPERATOR_LT, 0)
}

func (s *RelationElementContext) OPERATOR_GT() antlr.TerminalNode {
	return s.GetToken(CqlParserOPERATOR_GT, 0)
}

func (s *RelationElementContext) OPERATOR_LTE() antlr.TerminalNode {
	return s.GetToken(CqlParserOPERATOR_LTE, 0)
}

func (s *RelationElementContext) OPERATOR_GTE() antlr.TerminalNode {
	return s.GetToken(CqlParserOPERATOR_GTE, 0)
}

func (s *RelationElementContext) AllFunctionCall() []IFunctionCallContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFunctionCallContext); ok {
			len++
		}
	}

	tst := make([]IFunctionCallContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFunctionCallContext); ok {
			tst[i] = t.(IFunctionCallContext)
			i++
		}
	}

	return tst
}

func (s *RelationElementContext) FunctionCall(i int) IFunctionCallContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionCallContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionCallContext)
}

func (s *RelationElementContext) DOT() antlr.TerminalNode {
	return s.GetToken(CqlParserDOT, 0)
}

func (s *RelationElementContext) OBJECT_NAME() antlr.TerminalNode {
	return s.GetToken(CqlParserOBJECT_NAME, 0)
}

func (s *RelationElementContext) KwIn() IKwInContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwInContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwInContext)
}

func (s *RelationElementContext) AllLR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(CqlParserLR_BRACKET)
}

func (s *RelationElementContext) LR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(CqlParserLR_BRACKET, i)
}

func (s *RelationElementContext) AllRR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(CqlParserRR_BRACKET)
}

func (s *RelationElementContext) RR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(CqlParserRR_BRACKET, i)
}

func (s *RelationElementContext) FunctionArgs() IFunctionArgsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionArgsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionArgsContext)
}

func (s *RelationElementContext) AllAssignmentTuple() []IAssignmentTupleContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAssignmentTupleContext); ok {
			len++
		}
	}

	tst := make([]IAssignmentTupleContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAssignmentTupleContext); ok {
			tst[i] = t.(IAssignmentTupleContext)
			i++
		}
	}

	return tst
}

func (s *RelationElementContext) AssignmentTuple(i int) IAssignmentTupleContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentTupleContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentTupleContext)
}

func (s *RelationElementContext) AllSyntaxComma() []ISyntaxCommaContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			len++
		}
	}

	tst := make([]ISyntaxCommaContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISyntaxCommaContext); ok {
			tst[i] = t.(ISyntaxCommaContext)
			i++
		}
	}

	return tst
}

func (s *RelationElementContext) SyntaxComma(i int) ISyntaxCommaContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxCommaContext)
}

func (s *RelationElementContext) ScyllaClusteringBound() IScyllaClusteringBoundContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScyllaClusteringBoundContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScyllaClusteringBoundContext)
}

func (s *RelationElementContext) RelalationContainsKey() IRelalationContainsKeyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelalationContainsKeyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelalationContainsKeyContext)
}

func (s *RelationElementContext) RelalationContains() IRelalationContainsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelalationContainsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelalationContainsContext)
}

func (s *RelationElementContext) KwLike() IKwLikeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwLikeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwLikeContext)
}

func (s *RelationElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RelationElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterRelationElement(s)
	}
}

func (s *RelationElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitRelationElement(s)
	}
}

func (p *CqlParser) RelationElement() (localctx IRelationElementContext) {
	localctx = NewRelationElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 374, CqlParserRULE_relationElement)
	var _la int

	p.SetState(2859)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 251, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2758)
			p.ColumnRef()
		}
		{
			p.SetState(2759)
			_la = p.GetTokenStream().LA(1)

			if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&16252928) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(2760)
			p.Constant()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2762)
			p.ColumnRef()
		}
		{
			p.SetState(2763)
			_la = p.GetTokenStream().LA(1)

			if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&16252928) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(2764)
			p.FunctionCall()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2766)
			p.ColumnRef()
		}
		{
			p.SetState(2767)
			p.Match(CqlParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2768)
			p.Match(CqlParserOBJECT_NAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2769)
			_la = p.GetTokenStream().LA(1)

			if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&16252928) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(2770)
			p.Constant()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2772)
			p.FunctionCall()
		}
		{
			p.SetState(2773)
			_la = p.GetTokenStream().LA(1)

			if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&16252928) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(2774)
			p.Constant()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2776)
			p.FunctionCall()
		}
		{
			p.SetState(2777)
			_la = p.GetTokenStream().LA(1)

			if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&16252928) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(2778)
			p.FunctionCall()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2780)
			p.ColumnRef()
		}
		{
			p.SetState(2781)
			p.KwIn()
		}
		{
			p.SetState(2782)
			p.Match(CqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2784)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == CqlParserCOLON || _la == CqlParserK_FALSE || ((int64((_la-74)) & ^0x3f) == 0 && ((int64(1)<<(_la-74))&-3326748282943569919) != 0) || ((int64((_la-141)) & ^0x3f) == 0 && ((int64(1)<<(_la-141))&8971170462017323009) != 0) || ((int64((_la-205)) & ^0x3f) == 0 && ((int64(1)<<(_la-205))&29) != 0) {
			{
				p.SetState(2783)
				p.FunctionArgs()
			}

		}
		{
			p.SetState(2786)
			p.Match(CqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(2788)
			p.Match(CqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2789)
			p.ColumnRef()
		}
		p.SetState(2795)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == CqlParserCOMMA {
			{
				p.SetState(2790)
				p.SyntaxComma()
			}
			{
				p.SetState(2791)
				p.ColumnRef()
			}

			p.SetState(2797)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2798)
			p.Match(CqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2799)
			p.KwIn()
		}
		{
			p.SetState(2800)
			p.Match(CqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2801)
			p.AssignmentTuple()
		}
		p.SetState(2807)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == CqlParserCOMMA {
			{
				p.SetState(2802)
				p.SyntaxComma()
			}
			{
				p.SetState(2803)
				p.AssignmentTuple()
			}

			p.SetState(2809)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2810)
			p.Match(CqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(2812)
			p.Match(CqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2813)
			p.ColumnRef()
		}
		p.SetState(2819)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == CqlParserCOMMA {
			{
				p.SetState(2814)
				p.SyntaxComma()
			}
			{
				p.SetState(2815)
				p.ColumnRef()
			}

			p.SetState(2821)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2822)
			p.Match(CqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2823)
			_la = p.GetTokenStream().LA(1)

			if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&16252928) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

		{
			p.SetState(2824)
			p.AssignmentTuple()
		}
		p.SetState(2830)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == CqlParserCOMMA {
			{
				p.SetState(2825)
				p.SyntaxComma()
			}
			{
				p.SetState(2826)
				p.AssignmentTuple()
			}

			p.SetState(2832)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(2833)
			p.Match(CqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2834)
			p.ColumnRef()
		}
		p.SetState(2840)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == CqlParserCOMMA {
			{
				p.SetState(2835)
				p.SyntaxComma()
			}
			{
				p.SetState(2836)
				p.ColumnRef()
			}

			p.SetState(2842)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2843)
			p.Match(CqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2844)
			_la = p.GetTokenStream().LA(1)

			if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&16252928) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(2845)
			p.ScyllaClusteringBound()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(2847)
			p.ScyllaClusteringBound()
		}
		{
			p.SetState(2848)
			_la = p.GetTokenStream().LA(1)

			if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&16252928) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(2849)
			p.Match(CqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2850)
			p.FunctionArgs()
		}
		{
			p.SetState(2851)
			p.Match(CqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(2853)
			p.RelalationContainsKey()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(2854)
			p.RelalationContains()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(2855)
			p.ColumnRef()
		}
		{
			p.SetState(2856)
			p.KwLike()
		}
		{
			p.SetState(2857)
			p.Constant()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRelalationContainsContext is an interface to support dynamic dispatch.
type IRelalationContainsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ColumnRef() IColumnRefContext
	KwContains() IKwContainsContext
	Constant() IConstantContext

	// IsRelalationContainsContext differentiates from other interfaces.
	IsRelalationContainsContext()
}

type RelalationContainsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelalationContainsContext() *RelalationContainsContext {
	var p = new(RelalationContainsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_relalationContains
	return p
}

func InitEmptyRelalationContainsContext(p *RelalationContainsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_relalationContains
}

func (*RelalationContainsContext) IsRelalationContainsContext() {}

func NewRelalationContainsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelalationContainsContext {
	var p = new(RelalationContainsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_relalationContains

	return p
}

func (s *RelalationContainsContext) GetParser() antlr.Parser { return s.parser }

func (s *RelalationContainsContext) ColumnRef() IColumnRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnRefContext)
}

func (s *RelalationContainsContext) KwContains() IKwContainsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwContainsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwContainsContext)
}

func (s *RelalationContainsContext) Constant() IConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *RelalationContainsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelalationContainsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RelalationContainsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterRelalationContains(s)
	}
}

func (s *RelalationContainsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitRelalationContains(s)
	}
}

func (p *CqlParser) RelalationContains() (localctx IRelalationContainsContext) {
	localctx = NewRelalationContainsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 376, CqlParserRULE_relalationContains)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2861)
		p.ColumnRef()
	}
	{
		p.SetState(2862)
		p.KwContains()
	}
	{
		p.SetState(2863)
		p.Constant()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRelalationContainsKeyContext is an interface to support dynamic dispatch.
type IRelalationContainsKeyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ColumnRef() IColumnRefContext
	Constant() IConstantContext
	KwContains() IKwContainsContext
	KwKey() IKwKeyContext

	// IsRelalationContainsKeyContext differentiates from other interfaces.
	IsRelalationContainsKeyContext()
}

type RelalationContainsKeyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelalationContainsKeyContext() *RelalationContainsKeyContext {
	var p = new(RelalationContainsKeyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_relalationContainsKey
	return p
}

func InitEmptyRelalationContainsKeyContext(p *RelalationContainsKeyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_relalationContainsKey
}

func (*RelalationContainsKeyContext) IsRelalationContainsKeyContext() {}

func NewRelalationContainsKeyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelalationContainsKeyContext {
	var p = new(RelalationContainsKeyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_relalationContainsKey

	return p
}

func (s *RelalationContainsKeyContext) GetParser() antlr.Parser { return s.parser }

func (s *RelalationContainsKeyContext) ColumnRef() IColumnRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnRefContext)
}

func (s *RelalationContainsKeyContext) Constant() IConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *RelalationContainsKeyContext) KwContains() IKwContainsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwContainsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwContainsContext)
}

func (s *RelalationContainsKeyContext) KwKey() IKwKeyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwKeyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwKeyContext)
}

func (s *RelalationContainsKeyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelalationContainsKeyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RelalationContainsKeyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterRelalationContainsKey(s)
	}
}

func (s *RelalationContainsKeyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitRelalationContainsKey(s)
	}
}

func (p *CqlParser) RelalationContainsKey() (localctx IRelalationContainsKeyContext) {
	localctx = NewRelalationContainsKeyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 378, CqlParserRULE_relalationContainsKey)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2865)
		p.ColumnRef()
	}

	{
		p.SetState(2866)
		p.KwContains()
	}
	{
		p.SetState(2867)
		p.KwKey()
	}

	{
		p.SetState(2869)
		p.Constant()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IScyllaClusteringBoundContext is an interface to support dynamic dispatch.
type IScyllaClusteringBoundContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_SCYLLA_CLUSTERING_BOUND() antlr.TerminalNode
	LR_BRACKET() antlr.TerminalNode
	RR_BRACKET() antlr.TerminalNode
	FunctionArgs() IFunctionArgsContext

	// IsScyllaClusteringBoundContext differentiates from other interfaces.
	IsScyllaClusteringBoundContext()
}

type ScyllaClusteringBoundContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScyllaClusteringBoundContext() *ScyllaClusteringBoundContext {
	var p = new(ScyllaClusteringBoundContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_scyllaClusteringBound
	return p
}

func InitEmptyScyllaClusteringBoundContext(p *ScyllaClusteringBoundContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_scyllaClusteringBound
}

func (*ScyllaClusteringBoundContext) IsScyllaClusteringBoundContext() {}

func NewScyllaClusteringBoundContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScyllaClusteringBoundContext {
	var p = new(ScyllaClusteringBoundContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_scyllaClusteringBound

	return p
}

func (s *ScyllaClusteringBoundContext) GetParser() antlr.Parser { return s.parser }

func (s *ScyllaClusteringBoundContext) K_SCYLLA_CLUSTERING_BOUND() antlr.TerminalNode {
	return s.GetToken(CqlParserK_SCYLLA_CLUSTERING_BOUND, 0)
}

func (s *ScyllaClusteringBoundContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(CqlParserLR_BRACKET, 0)
}

func (s *ScyllaClusteringBoundContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(CqlParserRR_BRACKET, 0)
}

func (s *ScyllaClusteringBoundContext) FunctionArgs() IFunctionArgsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionArgsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionArgsContext)
}

func (s *ScyllaClusteringBoundContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScyllaClusteringBoundContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScyllaClusteringBoundContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterScyllaClusteringBound(s)
	}
}

func (s *ScyllaClusteringBoundContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitScyllaClusteringBound(s)
	}
}

func (p *CqlParser) ScyllaClusteringBound() (localctx IScyllaClusteringBoundContext) {
	localctx = NewScyllaClusteringBoundContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 380, CqlParserRULE_scyllaClusteringBound)
	var _la int

	p.SetState(2878)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 253, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2871)
			p.Match(CqlParserK_SCYLLA_CLUSTERING_BOUND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2872)
			p.Match(CqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2874)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == CqlParserCOLON || _la == CqlParserK_FALSE || ((int64((_la-74)) & ^0x3f) == 0 && ((int64(1)<<(_la-74))&-3326748282943569919) != 0) || ((int64((_la-141)) & ^0x3f) == 0 && ((int64(1)<<(_la-141))&8971170462017323009) != 0) || ((int64((_la-205)) & ^0x3f) == 0 && ((int64(1)<<(_la-205))&29) != 0) {
			{
				p.SetState(2873)
				p.FunctionArgs()
			}

		}
		{
			p.SetState(2876)
			p.Match(CqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2877)
			p.Match(CqlParserK_SCYLLA_CLUSTERING_BOUND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionCallContext is an interface to support dynamic dispatch.
type IFunctionCallContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OBJECT_NAME() antlr.TerminalNode
	LR_BRACKET() antlr.TerminalNode
	STAR() antlr.TerminalNode
	RR_BRACKET() antlr.TerminalNode
	FunctionArgs() IFunctionArgsContext
	K_UUID() antlr.TerminalNode
	KwWritetime() IKwWritetimeContext
	KwTtl() IKwTtlContext
	KwToken() IKwTokenContext

	// IsFunctionCallContext differentiates from other interfaces.
	IsFunctionCallContext()
}

type FunctionCallContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionCallContext() *FunctionCallContext {
	var p = new(FunctionCallContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_functionCall
	return p
}

func InitEmptyFunctionCallContext(p *FunctionCallContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_functionCall
}

func (*FunctionCallContext) IsFunctionCallContext() {}

func NewFunctionCallContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionCallContext {
	var p = new(FunctionCallContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_functionCall

	return p
}

func (s *FunctionCallContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionCallContext) OBJECT_NAME() antlr.TerminalNode {
	return s.GetToken(CqlParserOBJECT_NAME, 0)
}

func (s *FunctionCallContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(CqlParserLR_BRACKET, 0)
}

func (s *FunctionCallContext) STAR() antlr.TerminalNode {
	return s.GetToken(CqlParserSTAR, 0)
}

func (s *FunctionCallContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(CqlParserRR_BRACKET, 0)
}

func (s *FunctionCallContext) FunctionArgs() IFunctionArgsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionArgsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionArgsContext)
}

func (s *FunctionCallContext) K_UUID() antlr.TerminalNode {
	return s.GetToken(CqlParserK_UUID, 0)
}

func (s *FunctionCallContext) KwWritetime() IKwWritetimeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwWritetimeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwWritetimeContext)
}

func (s *FunctionCallContext) KwTtl() IKwTtlContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwTtlContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwTtlContext)
}

func (s *FunctionCallContext) KwToken() IKwTokenContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwTokenContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwTokenContext)
}

func (s *FunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionCallContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterFunctionCall(s)
	}
}

func (s *FunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitFunctionCall(s)
	}
}

func (p *CqlParser) FunctionCall() (localctx IFunctionCallContext) {
	localctx = NewFunctionCallContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 382, CqlParserRULE_functionCall)
	var _la int

	p.SetState(2908)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 255, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2880)
			p.Match(CqlParserOBJECT_NAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2881)
			p.Match(CqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2882)
			p.Match(CqlParserSTAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2883)
			p.Match(CqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2884)
			p.Match(CqlParserOBJECT_NAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2885)
			p.Match(CqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2887)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == CqlParserCOLON || _la == CqlParserK_FALSE || ((int64((_la-74)) & ^0x3f) == 0 && ((int64(1)<<(_la-74))&-3326748282943569919) != 0) || ((int64((_la-141)) & ^0x3f) == 0 && ((int64(1)<<(_la-141))&8971170462017323009) != 0) || ((int64((_la-205)) & ^0x3f) == 0 && ((int64(1)<<(_la-205))&29) != 0) {
			{
				p.SetState(2886)
				p.FunctionArgs()
			}

		}
		{
			p.SetState(2889)
			p.Match(CqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2890)
			p.Match(CqlParserK_UUID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2891)
			p.Match(CqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2892)
			p.Match(CqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2893)
			p.KwWritetime()
		}
		{
			p.SetState(2894)
			p.Match(CqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2895)
			p.Match(CqlParserOBJECT_NAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2896)
			p.Match(CqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2898)
			p.KwTtl()
		}
		{
			p.SetState(2899)
			p.Match(CqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2900)
			p.Match(CqlParserOBJECT_NAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2901)
			p.Match(CqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2903)
			p.KwToken()
		}
		{
			p.SetState(2904)
			p.Match(CqlParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2905)
			p.FunctionArgs()
		}
		{
			p.SetState(2906)
			p.Match(CqlParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICastCallContext is an interface to support dynamic dispatch.
type ICastCallContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwCast() IKwCastContext
	SyntaxBracketLr() ISyntaxBracketLrContext
	OBJECT_NAME() antlr.TerminalNode
	KwAs() IKwAsContext
	DataType() IDataTypeContext
	SyntaxBracketRr() ISyntaxBracketRrContext

	// IsCastCallContext differentiates from other interfaces.
	IsCastCallContext()
}

type CastCallContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCastCallContext() *CastCallContext {
	var p = new(CastCallContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_castCall
	return p
}

func InitEmptyCastCallContext(p *CastCallContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_castCall
}

func (*CastCallContext) IsCastCallContext() {}

func NewCastCallContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CastCallContext {
	var p = new(CastCallContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_castCall

	return p
}

func (s *CastCallContext) GetParser() antlr.Parser { return s.parser }

func (s *CastCallContext) KwCast() IKwCastContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwCastContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwCastContext)
}

func (s *CastCallContext) SyntaxBracketLr() ISyntaxBracketLrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxBracketLrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxBracketLrContext)
}

func (s *CastCallContext) OBJECT_NAME() antlr.TerminalNode {
	return s.GetToken(CqlParserOBJECT_NAME, 0)
}

func (s *CastCallContext) KwAs() IKwAsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwAsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwAsContext)
}

func (s *CastCallContext) DataType() IDataTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *CastCallContext) SyntaxBracketRr() ISyntaxBracketRrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxBracketRrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxBracketRrContext)
}

func (s *CastCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CastCallContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CastCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterCastCall(s)
	}
}

func (s *CastCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitCastCall(s)
	}
}

func (p *CqlParser) CastCall() (localctx ICastCallContext) {
	localctx = NewCastCallContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 384, CqlParserRULE_castCall)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2910)
		p.KwCast()
	}
	{
		p.SetState(2911)
		p.SyntaxBracketLr()
	}
	{
		p.SetState(2912)
		p.Match(CqlParserOBJECT_NAME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2913)
		p.KwAs()
	}
	{
		p.SetState(2914)
		p.DataType()
	}
	{
		p.SetState(2915)
		p.SyntaxBracketRr()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQualifiedFunctionCallContext is an interface to support dynamic dispatch.
type IQualifiedFunctionCallContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllOBJECT_NAME() []antlr.TerminalNode
	OBJECT_NAME(i int) antlr.TerminalNode
	DOT() antlr.TerminalNode
	LR_BRACKET() antlr.TerminalNode
	RR_BRACKET() antlr.TerminalNode
	FunctionArgs() IFunctionArgsContext

	// IsQualifiedFunctionCallContext differentiates from other interfaces.
	IsQualifiedFunctionCallContext()
}

type QualifiedFunctionCallContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualifiedFunctionCallContext() *QualifiedFunctionCallContext {
	var p = new(QualifiedFunctionCallContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_qualifiedFunctionCall
	return p
}

func InitEmptyQualifiedFunctionCallContext(p *QualifiedFunctionCallContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_qualifiedFunctionCall
}

func (*QualifiedFunctionCallContext) IsQualifiedFunctionCallContext() {}

func NewQualifiedFunctionCallContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QualifiedFunctionCallContext {
	var p = new(QualifiedFunctionCallContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_qualifiedFunctionCall

	return p
}

func (s *QualifiedFunctionCallContext) GetParser() antlr.Parser { return s.parser }

func (s *QualifiedFunctionCallContext) AllOBJECT_NAME() []antlr.TerminalNode {
	return s.GetTokens(CqlParserOBJECT_NAME)
}

func (s *QualifiedFunctionCallContext) OBJECT_NAME(i int) antlr.TerminalNode {
	return s.GetToken(CqlParserOBJECT_NAME, i)
}

func (s *QualifiedFunctionCallContext) DOT() antlr.TerminalNode {
	return s.GetToken(CqlParserDOT, 0)
}

func (s *QualifiedFunctionCallContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(CqlParserLR_BRACKET, 0)
}

func (s *QualifiedFunctionCallContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(CqlParserRR_BRACKET, 0)
}

func (s *QualifiedFunctionCallContext) FunctionArgs() IFunctionArgsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionArgsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionArgsContext)
}

func (s *QualifiedFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifiedFunctionCallContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QualifiedFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterQualifiedFunctionCall(s)
	}
}

func (s *QualifiedFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitQualifiedFunctionCall(s)
	}
}

func (p *CqlParser) QualifiedFunctionCall() (localctx IQualifiedFunctionCallContext) {
	localctx = NewQualifiedFunctionCallContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 386, CqlParserRULE_qualifiedFunctionCall)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2917)
		p.Match(CqlParserOBJECT_NAME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2918)
		p.Match(CqlParserDOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2919)
		p.Match(CqlParserOBJECT_NAME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2920)
		p.Match(CqlParserLR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2922)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CqlParserCOLON || _la == CqlParserK_FALSE || ((int64((_la-74)) & ^0x3f) == 0 && ((int64(1)<<(_la-74))&-3326748282943569919) != 0) || ((int64((_la-141)) & ^0x3f) == 0 && ((int64(1)<<(_la-141))&8971170462017323009) != 0) || ((int64((_la-205)) & ^0x3f) == 0 && ((int64(1)<<(_la-205))&29) != 0) {
		{
			p.SetState(2921)
			p.FunctionArgs()
		}

	}
	{
		p.SetState(2924)
		p.Match(CqlParserRR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionArgsContext is an interface to support dynamic dispatch.
type IFunctionArgsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllConstant() []IConstantContext
	Constant(i int) IConstantContext
	AllColumnRef() []IColumnRefContext
	ColumnRef(i int) IColumnRefContext
	AllFunctionCall() []IFunctionCallContext
	FunctionCall(i int) IFunctionCallContext
	AllQualifiedFunctionCall() []IQualifiedFunctionCallContext
	QualifiedFunctionCall(i int) IQualifiedFunctionCallContext
	AllSyntaxComma() []ISyntaxCommaContext
	SyntaxComma(i int) ISyntaxCommaContext

	// IsFunctionArgsContext differentiates from other interfaces.
	IsFunctionArgsContext()
}

type FunctionArgsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionArgsContext() *FunctionArgsContext {
	var p = new(FunctionArgsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_functionArgs
	return p
}

func InitEmptyFunctionArgsContext(p *FunctionArgsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_functionArgs
}

func (*FunctionArgsContext) IsFunctionArgsContext() {}

func NewFunctionArgsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionArgsContext {
	var p = new(FunctionArgsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_functionArgs

	return p
}

func (s *FunctionArgsContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionArgsContext) AllConstant() []IConstantContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IConstantContext); ok {
			len++
		}
	}

	tst := make([]IConstantContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IConstantContext); ok {
			tst[i] = t.(IConstantContext)
			i++
		}
	}

	return tst
}

func (s *FunctionArgsContext) Constant(i int) IConstantContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *FunctionArgsContext) AllColumnRef() []IColumnRefContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnRefContext); ok {
			len++
		}
	}

	tst := make([]IColumnRefContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnRefContext); ok {
			tst[i] = t.(IColumnRefContext)
			i++
		}
	}

	return tst
}

func (s *FunctionArgsContext) ColumnRef(i int) IColumnRefContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnRefContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnRefContext)
}

func (s *FunctionArgsContext) AllFunctionCall() []IFunctionCallContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFunctionCallContext); ok {
			len++
		}
	}

	tst := make([]IFunctionCallContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFunctionCallContext); ok {
			tst[i] = t.(IFunctionCallContext)
			i++
		}
	}

	return tst
}

func (s *FunctionArgsContext) FunctionCall(i int) IFunctionCallContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionCallContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionCallContext)
}

func (s *FunctionArgsContext) AllQualifiedFunctionCall() []IQualifiedFunctionCallContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQualifiedFunctionCallContext); ok {
			len++
		}
	}

	tst := make([]IQualifiedFunctionCallContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQualifiedFunctionCallContext); ok {
			tst[i] = t.(IQualifiedFunctionCallContext)
			i++
		}
	}

	return tst
}

func (s *FunctionArgsContext) QualifiedFunctionCall(i int) IQualifiedFunctionCallContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedFunctionCallContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedFunctionCallContext)
}

func (s *FunctionArgsContext) AllSyntaxComma() []ISyntaxCommaContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			len++
		}
	}

	tst := make([]ISyntaxCommaContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISyntaxCommaContext); ok {
			tst[i] = t.(ISyntaxCommaContext)
			i++
		}
	}

	return tst
}

func (s *FunctionArgsContext) SyntaxComma(i int) ISyntaxCommaContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxCommaContext)
}

func (s *FunctionArgsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionArgsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionArgsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterFunctionArgs(s)
	}
}

func (s *FunctionArgsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitFunctionArgs(s)
	}
}

func (p *CqlParser) FunctionArgs() (localctx IFunctionArgsContext) {
	localctx = NewFunctionArgsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 388, CqlParserRULE_functionArgs)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2930)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 257, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2926)
			p.Constant()
		}

	case 2:
		{
			p.SetState(2927)
			p.ColumnRef()
		}

	case 3:
		{
			p.SetState(2928)
			p.FunctionCall()
		}

	case 4:
		{
			p.SetState(2929)
			p.QualifiedFunctionCall()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(2941)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == CqlParserCOMMA {
		{
			p.SetState(2932)
			p.SyntaxComma()
		}
		p.SetState(2937)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 258, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(2933)
				p.Constant()
			}

		case 2:
			{
				p.SetState(2934)
				p.ColumnRef()
			}

		case 3:
			{
				p.SetState(2935)
				p.FunctionCall()
			}

		case 4:
			{
				p.SetState(2936)
				p.QualifiedFunctionCall()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

		p.SetState(2943)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConstantContext is an interface to support dynamic dispatch.
type IConstantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UUID() antlr.TerminalNode
	StringLiteral() IStringLiteralContext
	DecimalLiteral() IDecimalLiteralContext
	FloatLiteral() IFloatLiteralContext
	HexadecimalLiteral() IHexadecimalLiteralContext
	BooleanLiteral() IBooleanLiteralContext
	CodeBlock() ICodeBlockContext
	KwNull() IKwNullContext
	QMARK() antlr.TerminalNode
	NamedMarker() INamedMarkerContext
	DurationLiteral() IDurationLiteralContext
	KwEmpty() IKwEmptyContext

	// IsConstantContext differentiates from other interfaces.
	IsConstantContext()
}

type ConstantContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstantContext() *ConstantContext {
	var p = new(ConstantContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_constant
	return p
}

func InitEmptyConstantContext(p *ConstantContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_constant
}

func (*ConstantContext) IsConstantContext() {}

func NewConstantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstantContext {
	var p = new(ConstantContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_constant

	return p
}

func (s *ConstantContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstantContext) UUID() antlr.TerminalNode {
	return s.GetToken(CqlParserUUID, 0)
}

func (s *ConstantContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *ConstantContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *ConstantContext) FloatLiteral() IFloatLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFloatLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFloatLiteralContext)
}

func (s *ConstantContext) HexadecimalLiteral() IHexadecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHexadecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHexadecimalLiteralContext)
}

func (s *ConstantContext) BooleanLiteral() IBooleanLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanLiteralContext)
}

func (s *ConstantContext) CodeBlock() ICodeBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICodeBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICodeBlockContext)
}

func (s *ConstantContext) KwNull() IKwNullContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwNullContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwNullContext)
}

func (s *ConstantContext) QMARK() antlr.TerminalNode {
	return s.GetToken(CqlParserQMARK, 0)
}

func (s *ConstantContext) NamedMarker() INamedMarkerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamedMarkerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamedMarkerContext)
}

func (s *ConstantContext) DurationLiteral() IDurationLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDurationLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDurationLiteralContext)
}

func (s *ConstantContext) KwEmpty() IKwEmptyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwEmptyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwEmptyContext)
}

func (s *ConstantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstantContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterConstant(s)
	}
}

func (s *ConstantContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitConstant(s)
	}
}

func (p *CqlParser) Constant() (localctx IConstantContext) {
	localctx = NewConstantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 390, CqlParserRULE_constant)
	p.SetState(2956)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 260, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2944)
			p.Match(CqlParserUUID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2945)
			p.StringLiteral()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2946)
			p.DecimalLiteral()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2947)
			p.FloatLiteral()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2948)
			p.HexadecimalLiteral()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2949)
			p.BooleanLiteral()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(2950)
			p.CodeBlock()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(2951)
			p.KwNull()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(2952)
			p.Match(CqlParserQMARK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(2953)
			p.NamedMarker()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(2954)
			p.DurationLiteral()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(2955)
			p.KwEmpty()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INamedMarkerContext is an interface to support dynamic dispatch.
type INamedMarkerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COLON() antlr.TerminalNode
	OBJECT_NAME() antlr.TerminalNode

	// IsNamedMarkerContext differentiates from other interfaces.
	IsNamedMarkerContext()
}

type NamedMarkerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamedMarkerContext() *NamedMarkerContext {
	var p = new(NamedMarkerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_namedMarker
	return p
}

func InitEmptyNamedMarkerContext(p *NamedMarkerContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_namedMarker
}

func (*NamedMarkerContext) IsNamedMarkerContext() {}

func NewNamedMarkerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamedMarkerContext {
	var p = new(NamedMarkerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_namedMarker

	return p
}

func (s *NamedMarkerContext) GetParser() antlr.Parser { return s.parser }

func (s *NamedMarkerContext) COLON() antlr.TerminalNode {
	return s.GetToken(CqlParserCOLON, 0)
}

func (s *NamedMarkerContext) OBJECT_NAME() antlr.TerminalNode {
	return s.GetToken(CqlParserOBJECT_NAME, 0)
}

func (s *NamedMarkerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamedMarkerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamedMarkerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterNamedMarker(s)
	}
}

func (s *NamedMarkerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitNamedMarker(s)
	}
}

func (p *CqlParser) NamedMarker() (localctx INamedMarkerContext) {
	localctx = NewNamedMarkerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 392, CqlParserRULE_namedMarker)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2958)
		p.Match(CqlParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2959)
		p.Match(CqlParserOBJECT_NAME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDurationLiteralContext is an interface to support dynamic dispatch.
type IDurationLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DURATION_LITERAL() antlr.TerminalNode

	// IsDurationLiteralContext differentiates from other interfaces.
	IsDurationLiteralContext()
}

type DurationLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDurationLiteralContext() *DurationLiteralContext {
	var p = new(DurationLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_durationLiteral
	return p
}

func InitEmptyDurationLiteralContext(p *DurationLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_durationLiteral
}

func (*DurationLiteralContext) IsDurationLiteralContext() {}

func NewDurationLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DurationLiteralContext {
	var p = new(DurationLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_durationLiteral

	return p
}

func (s *DurationLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *DurationLiteralContext) DURATION_LITERAL() antlr.TerminalNode {
	return s.GetToken(CqlParserDURATION_LITERAL, 0)
}

func (s *DurationLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DurationLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DurationLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterDurationLiteral(s)
	}
}

func (s *DurationLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitDurationLiteral(s)
	}
}

func (p *CqlParser) DurationLiteral() (localctx IDurationLiteralContext) {
	localctx = NewDurationLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 394, CqlParserRULE_durationLiteral)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2961)
		p.Match(CqlParserDURATION_LITERAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDecimalLiteralContext is an interface to support dynamic dispatch.
type IDecimalLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DECIMAL_LITERAL() antlr.TerminalNode

	// IsDecimalLiteralContext differentiates from other interfaces.
	IsDecimalLiteralContext()
}

type DecimalLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDecimalLiteralContext() *DecimalLiteralContext {
	var p = new(DecimalLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_decimalLiteral
	return p
}

func InitEmptyDecimalLiteralContext(p *DecimalLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_decimalLiteral
}

func (*DecimalLiteralContext) IsDecimalLiteralContext() {}

func NewDecimalLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DecimalLiteralContext {
	var p = new(DecimalLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_decimalLiteral

	return p
}

func (s *DecimalLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *DecimalLiteralContext) DECIMAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(CqlParserDECIMAL_LITERAL, 0)
}

func (s *DecimalLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DecimalLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DecimalLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterDecimalLiteral(s)
	}
}

func (s *DecimalLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitDecimalLiteral(s)
	}
}

func (p *CqlParser) DecimalLiteral() (localctx IDecimalLiteralContext) {
	localctx = NewDecimalLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 396, CqlParserRULE_decimalLiteral)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2963)
		p.Match(CqlParserDECIMAL_LITERAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFloatLiteralContext is an interface to support dynamic dispatch.
type IFloatLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DECIMAL_LITERAL() antlr.TerminalNode
	FLOAT_LITERAL() antlr.TerminalNode

	// IsFloatLiteralContext differentiates from other interfaces.
	IsFloatLiteralContext()
}

type FloatLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFloatLiteralContext() *FloatLiteralContext {
	var p = new(FloatLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_floatLiteral
	return p
}

func InitEmptyFloatLiteralContext(p *FloatLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_floatLiteral
}

func (*FloatLiteralContext) IsFloatLiteralContext() {}

func NewFloatLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FloatLiteralContext {
	var p = new(FloatLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_floatLiteral

	return p
}

func (s *FloatLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *FloatLiteralContext) DECIMAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(CqlParserDECIMAL_LITERAL, 0)
}

func (s *FloatLiteralContext) FLOAT_LITERAL() antlr.TerminalNode {
	return s.GetToken(CqlParserFLOAT_LITERAL, 0)
}

func (s *FloatLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FloatLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FloatLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterFloatLiteral(s)
	}
}

func (s *FloatLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitFloatLiteral(s)
	}
}

func (p *CqlParser) FloatLiteral() (localctx IFloatLiteralContext) {
	localctx = NewFloatLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 398, CqlParserRULE_floatLiteral)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2965)
		_la = p.GetTokenStream().LA(1)

		if !(_la == CqlParserDECIMAL_LITERAL || _la == CqlParserFLOAT_LITERAL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStringLiteralContext is an interface to support dynamic dispatch.
type IStringLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STRING_LITERAL() antlr.TerminalNode

	// IsStringLiteralContext differentiates from other interfaces.
	IsStringLiteralContext()
}

type StringLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringLiteralContext() *StringLiteralContext {
	var p = new(StringLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_stringLiteral
	return p
}

func InitEmptyStringLiteralContext(p *StringLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_stringLiteral
}

func (*StringLiteralContext) IsStringLiteralContext() {}

func NewStringLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringLiteralContext {
	var p = new(StringLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_stringLiteral

	return p
}

func (s *StringLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *StringLiteralContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(CqlParserSTRING_LITERAL, 0)
}

func (s *StringLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterStringLiteral(s)
	}
}

func (s *StringLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitStringLiteral(s)
	}
}

func (p *CqlParser) StringLiteral() (localctx IStringLiteralContext) {
	localctx = NewStringLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 400, CqlParserRULE_stringLiteral)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2967)
		p.Match(CqlParserSTRING_LITERAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBooleanLiteralContext is an interface to support dynamic dispatch.
type IBooleanLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_TRUE() antlr.TerminalNode
	K_FALSE() antlr.TerminalNode

	// IsBooleanLiteralContext differentiates from other interfaces.
	IsBooleanLiteralContext()
}

type BooleanLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBooleanLiteralContext() *BooleanLiteralContext {
	var p = new(BooleanLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_booleanLiteral
	return p
}

func InitEmptyBooleanLiteralContext(p *BooleanLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_booleanLiteral
}

func (*BooleanLiteralContext) IsBooleanLiteralContext() {}

func NewBooleanLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BooleanLiteralContext {
	var p = new(BooleanLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_booleanLiteral

	return p
}

func (s *BooleanLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *BooleanLiteralContext) K_TRUE() antlr.TerminalNode {
	return s.GetToken(CqlParserK_TRUE, 0)
}

func (s *BooleanLiteralContext) K_FALSE() antlr.TerminalNode {
	return s.GetToken(CqlParserK_FALSE, 0)
}

func (s *BooleanLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BooleanLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterBooleanLiteral(s)
	}
}

func (s *BooleanLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitBooleanLiteral(s)
	}
}

func (p *CqlParser) BooleanLiteral() (localctx IBooleanLiteralContext) {
	localctx = NewBooleanLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 402, CqlParserRULE_booleanLiteral)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2969)
		_la = p.GetTokenStream().LA(1)

		if !(_la == CqlParserK_FALSE || _la == CqlParserK_TRUE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHexadecimalLiteralContext is an interface to support dynamic dispatch.
type IHexadecimalLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	HEXADECIMAL_LITERAL() antlr.TerminalNode

	// IsHexadecimalLiteralContext differentiates from other interfaces.
	IsHexadecimalLiteralContext()
}

type HexadecimalLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHexadecimalLiteralContext() *HexadecimalLiteralContext {
	var p = new(HexadecimalLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_hexadecimalLiteral
	return p
}

func InitEmptyHexadecimalLiteralContext(p *HexadecimalLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_hexadecimalLiteral
}

func (*HexadecimalLiteralContext) IsHexadecimalLiteralContext() {}

func NewHexadecimalLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HexadecimalLiteralContext {
	var p = new(HexadecimalLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_hexadecimalLiteral

	return p
}

func (s *HexadecimalLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *HexadecimalLiteralContext) HEXADECIMAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(CqlParserHEXADECIMAL_LITERAL, 0)
}

func (s *HexadecimalLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HexadecimalLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HexadecimalLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterHexadecimalLiteral(s)
	}
}

func (s *HexadecimalLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitHexadecimalLiteral(s)
	}
}

func (p *CqlParser) HexadecimalLiteral() (localctx IHexadecimalLiteralContext) {
	localctx = NewHexadecimalLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 404, CqlParserRULE_hexadecimalLiteral)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2971)
		p.Match(CqlParserHEXADECIMAL_LITERAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKeyspaceContext is an interface to support dynamic dispatch.
type IKeyspaceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OBJECT_NAME() antlr.TerminalNode
	AllDQUOTE() []antlr.TerminalNode
	DQUOTE(i int) antlr.TerminalNode

	// IsKeyspaceContext differentiates from other interfaces.
	IsKeyspaceContext()
}

type KeyspaceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeyspaceContext() *KeyspaceContext {
	var p = new(KeyspaceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_keyspace
	return p
}

func InitEmptyKeyspaceContext(p *KeyspaceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_keyspace
}

func (*KeyspaceContext) IsKeyspaceContext() {}

func NewKeyspaceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KeyspaceContext {
	var p = new(KeyspaceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_keyspace

	return p
}

func (s *KeyspaceContext) GetParser() antlr.Parser { return s.parser }

func (s *KeyspaceContext) OBJECT_NAME() antlr.TerminalNode {
	return s.GetToken(CqlParserOBJECT_NAME, 0)
}

func (s *KeyspaceContext) AllDQUOTE() []antlr.TerminalNode {
	return s.GetTokens(CqlParserDQUOTE)
}

func (s *KeyspaceContext) DQUOTE(i int) antlr.TerminalNode {
	return s.GetToken(CqlParserDQUOTE, i)
}

func (s *KeyspaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KeyspaceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KeyspaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKeyspace(s)
	}
}

func (s *KeyspaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKeyspace(s)
	}
}

func (p *CqlParser) Keyspace() (localctx IKeyspaceContext) {
	localctx = NewKeyspaceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 406, CqlParserRULE_keyspace)
	p.SetState(2977)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case CqlParserOBJECT_NAME:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2973)
			p.Match(CqlParserOBJECT_NAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case CqlParserDQUOTE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2974)
			p.Match(CqlParserDQUOTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2975)
			p.Match(CqlParserOBJECT_NAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2976)
			p.Match(CqlParserDQUOTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableContext is an interface to support dynamic dispatch.
type ITableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OBJECT_NAME() antlr.TerminalNode
	ReservedKeywordAsTable() IReservedKeywordAsTableContext
	ReservedTypeAsTable() IReservedTypeAsTableContext

	// IsTableContext differentiates from other interfaces.
	IsTableContext()
}

type TableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableContext() *TableContext {
	var p = new(TableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_table
	return p
}

func InitEmptyTableContext(p *TableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_table
}

func (*TableContext) IsTableContext() {}

func NewTableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableContext {
	var p = new(TableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_table

	return p
}

func (s *TableContext) GetParser() antlr.Parser { return s.parser }

func (s *TableContext) OBJECT_NAME() antlr.TerminalNode {
	return s.GetToken(CqlParserOBJECT_NAME, 0)
}

func (s *TableContext) ReservedKeywordAsTable() IReservedKeywordAsTableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReservedKeywordAsTableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReservedKeywordAsTableContext)
}

func (s *TableContext) ReservedTypeAsTable() IReservedTypeAsTableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReservedTypeAsTableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReservedTypeAsTableContext)
}

func (s *TableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterTable(s)
	}
}

func (s *TableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitTable(s)
	}
}

func (p *CqlParser) Table() (localctx ITableContext) {
	localctx = NewTableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 408, CqlParserRULE_table)
	p.SetState(2982)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case CqlParserOBJECT_NAME:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2979)
			p.Match(CqlParserOBJECT_NAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case CqlParserK_FUNCTIONS, CqlParserK_KEYSPACES, CqlParserK_TABLES, CqlParserK_TYPES, CqlParserK_AGGREGATES, CqlParserK_USERS, CqlParserK_COLUMNS, CqlParserK_VIEWS, CqlParserK_INDEXES:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2980)
			p.ReservedKeywordAsTable()
		}

	case CqlParserK_ONE, CqlParserK_THREE, CqlParserK_TWO, CqlParserK_BIGINT, CqlParserK_BOOLEAN, CqlParserK_DOUBLE, CqlParserK_FLOAT, CqlParserK_INT, CqlParserK_TEXT, CqlParserK_VARCHAR:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2981)
			p.ReservedTypeAsTable()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnContext is an interface to support dynamic dispatch.
type IColumnContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OBJECT_NAME() antlr.TerminalNode
	AllDQUOTE() []antlr.TerminalNode
	DQUOTE(i int) antlr.TerminalNode
	ReservedKeywordAsColumn() IReservedKeywordAsColumnContext

	// IsColumnContext differentiates from other interfaces.
	IsColumnContext()
}

type ColumnContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnContext() *ColumnContext {
	var p = new(ColumnContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_column
	return p
}

func InitEmptyColumnContext(p *ColumnContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_column
}

func (*ColumnContext) IsColumnContext() {}

func NewColumnContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnContext {
	var p = new(ColumnContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_column

	return p
}

func (s *ColumnContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnContext) OBJECT_NAME() antlr.TerminalNode {
	return s.GetToken(CqlParserOBJECT_NAME, 0)
}

func (s *ColumnContext) AllDQUOTE() []antlr.TerminalNode {
	return s.GetTokens(CqlParserDQUOTE)
}

func (s *ColumnContext) DQUOTE(i int) antlr.TerminalNode {
	return s.GetToken(CqlParserDQUOTE, i)
}

func (s *ColumnContext) ReservedKeywordAsColumn() IReservedKeywordAsColumnContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReservedKeywordAsColumnContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReservedKeywordAsColumnContext)
}

func (s *ColumnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterColumn(s)
	}
}

func (s *ColumnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitColumn(s)
	}
}

func (p *CqlParser) Column() (localctx IColumnContext) {
	localctx = NewColumnContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 410, CqlParserRULE_column)
	p.SetState(2989)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case CqlParserOBJECT_NAME:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2984)
			p.Match(CqlParserOBJECT_NAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case CqlParserDQUOTE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2985)
			p.Match(CqlParserDQUOTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2986)
			p.Match(CqlParserOBJECT_NAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2987)
			p.Match(CqlParserDQUOTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case CqlParserK_KEY, CqlParserK_PASSWORD, CqlParserK_ROLE, CqlParserK_STATIC, CqlParserK_TIMESTAMP, CqlParserK_TWO, CqlParserK_TYPE, CqlParserK_USER, CqlParserK_UUID, CqlParserK_VALUES, CqlParserK_TEXT, CqlParserK_TIME, CqlParserK_VALUE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2988)
			p.ReservedKeywordAsColumn()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReservedKeywordAsColumnContext is an interface to support dynamic dispatch.
type IReservedKeywordAsColumnContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_TIME() antlr.TerminalNode
	K_TIMESTAMP() antlr.TerminalNode
	K_UUID() antlr.TerminalNode
	K_PASSWORD() antlr.TerminalNode
	K_TEXT() antlr.TerminalNode
	K_KEY() antlr.TerminalNode
	K_VALUE() antlr.TerminalNode
	K_VALUES() antlr.TerminalNode
	K_TYPE() antlr.TerminalNode
	K_USER() antlr.TerminalNode
	K_ROLE() antlr.TerminalNode
	K_STATIC() antlr.TerminalNode
	K_TWO() antlr.TerminalNode

	// IsReservedKeywordAsColumnContext differentiates from other interfaces.
	IsReservedKeywordAsColumnContext()
}

type ReservedKeywordAsColumnContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReservedKeywordAsColumnContext() *ReservedKeywordAsColumnContext {
	var p = new(ReservedKeywordAsColumnContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_reservedKeywordAsColumn
	return p
}

func InitEmptyReservedKeywordAsColumnContext(p *ReservedKeywordAsColumnContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_reservedKeywordAsColumn
}

func (*ReservedKeywordAsColumnContext) IsReservedKeywordAsColumnContext() {}

func NewReservedKeywordAsColumnContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReservedKeywordAsColumnContext {
	var p = new(ReservedKeywordAsColumnContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_reservedKeywordAsColumn

	return p
}

func (s *ReservedKeywordAsColumnContext) GetParser() antlr.Parser { return s.parser }

func (s *ReservedKeywordAsColumnContext) K_TIME() antlr.TerminalNode {
	return s.GetToken(CqlParserK_TIME, 0)
}

func (s *ReservedKeywordAsColumnContext) K_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(CqlParserK_TIMESTAMP, 0)
}

func (s *ReservedKeywordAsColumnContext) K_UUID() antlr.TerminalNode {
	return s.GetToken(CqlParserK_UUID, 0)
}

func (s *ReservedKeywordAsColumnContext) K_PASSWORD() antlr.TerminalNode {
	return s.GetToken(CqlParserK_PASSWORD, 0)
}

func (s *ReservedKeywordAsColumnContext) K_TEXT() antlr.TerminalNode {
	return s.GetToken(CqlParserK_TEXT, 0)
}

func (s *ReservedKeywordAsColumnContext) K_KEY() antlr.TerminalNode {
	return s.GetToken(CqlParserK_KEY, 0)
}

func (s *ReservedKeywordAsColumnContext) K_VALUE() antlr.TerminalNode {
	return s.GetToken(CqlParserK_VALUE, 0)
}

func (s *ReservedKeywordAsColumnContext) K_VALUES() antlr.TerminalNode {
	return s.GetToken(CqlParserK_VALUES, 0)
}

func (s *ReservedKeywordAsColumnContext) K_TYPE() antlr.TerminalNode {
	return s.GetToken(CqlParserK_TYPE, 0)
}

func (s *ReservedKeywordAsColumnContext) K_USER() antlr.TerminalNode {
	return s.GetToken(CqlParserK_USER, 0)
}

func (s *ReservedKeywordAsColumnContext) K_ROLE() antlr.TerminalNode {
	return s.GetToken(CqlParserK_ROLE, 0)
}

func (s *ReservedKeywordAsColumnContext) K_STATIC() antlr.TerminalNode {
	return s.GetToken(CqlParserK_STATIC, 0)
}

func (s *ReservedKeywordAsColumnContext) K_TWO() antlr.TerminalNode {
	return s.GetToken(CqlParserK_TWO, 0)
}

func (s *ReservedKeywordAsColumnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReservedKeywordAsColumnContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReservedKeywordAsColumnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterReservedKeywordAsColumn(s)
	}
}

func (s *ReservedKeywordAsColumnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitReservedKeywordAsColumn(s)
	}
}

func (p *CqlParser) ReservedKeywordAsColumn() (localctx IReservedKeywordAsColumnContext) {
	localctx = NewReservedKeywordAsColumnContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 412, CqlParserRULE_reservedKeywordAsColumn)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2991)
		_la = p.GetTokenStream().LA(1)

		if !(((int64((_la-74)) & ^0x3f) == 0 && ((int64(1)<<(_la-74))&-3350392180987396095) != 0) || ((int64((_la-157)) & ^0x3f) == 0 && ((int64(1)<<(_la-157))&65541) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnRefContext is an interface to support dynamic dispatch.
type IColumnRefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OBJECT_NAME() antlr.TerminalNode
	ReservedKeywordAsColumn() IReservedKeywordAsColumnContext

	// IsColumnRefContext differentiates from other interfaces.
	IsColumnRefContext()
}

type ColumnRefContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnRefContext() *ColumnRefContext {
	var p = new(ColumnRefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_columnRef
	return p
}

func InitEmptyColumnRefContext(p *ColumnRefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_columnRef
}

func (*ColumnRefContext) IsColumnRefContext() {}

func NewColumnRefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnRefContext {
	var p = new(ColumnRefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_columnRef

	return p
}

func (s *ColumnRefContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnRefContext) OBJECT_NAME() antlr.TerminalNode {
	return s.GetToken(CqlParserOBJECT_NAME, 0)
}

func (s *ColumnRefContext) ReservedKeywordAsColumn() IReservedKeywordAsColumnContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReservedKeywordAsColumnContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReservedKeywordAsColumnContext)
}

func (s *ColumnRefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnRefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnRefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterColumnRef(s)
	}
}

func (s *ColumnRefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitColumnRef(s)
	}
}

func (p *CqlParser) ColumnRef() (localctx IColumnRefContext) {
	localctx = NewColumnRefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 414, CqlParserRULE_columnRef)
	p.SetState(2995)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case CqlParserOBJECT_NAME:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2993)
			p.Match(CqlParserOBJECT_NAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case CqlParserK_KEY, CqlParserK_PASSWORD, CqlParserK_ROLE, CqlParserK_STATIC, CqlParserK_TIMESTAMP, CqlParserK_TWO, CqlParserK_TYPE, CqlParserK_USER, CqlParserK_UUID, CqlParserK_VALUES, CqlParserK_TEXT, CqlParserK_TIME, CqlParserK_VALUE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2994)
			p.ReservedKeywordAsColumn()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReservedKeywordAsTableContext is an interface to support dynamic dispatch.
type IReservedKeywordAsTableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_KEYSPACES() antlr.TerminalNode
	K_TABLES() antlr.TerminalNode
	K_COLUMNS() antlr.TerminalNode
	K_TYPES() antlr.TerminalNode
	K_FUNCTIONS() antlr.TerminalNode
	K_AGGREGATES() antlr.TerminalNode
	K_VIEWS() antlr.TerminalNode
	K_INDEXES() antlr.TerminalNode
	K_USERS() antlr.TerminalNode

	// IsReservedKeywordAsTableContext differentiates from other interfaces.
	IsReservedKeywordAsTableContext()
}

type ReservedKeywordAsTableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReservedKeywordAsTableContext() *ReservedKeywordAsTableContext {
	var p = new(ReservedKeywordAsTableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_reservedKeywordAsTable
	return p
}

func InitEmptyReservedKeywordAsTableContext(p *ReservedKeywordAsTableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_reservedKeywordAsTable
}

func (*ReservedKeywordAsTableContext) IsReservedKeywordAsTableContext() {}

func NewReservedKeywordAsTableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReservedKeywordAsTableContext {
	var p = new(ReservedKeywordAsTableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_reservedKeywordAsTable

	return p
}

func (s *ReservedKeywordAsTableContext) GetParser() antlr.Parser { return s.parser }

func (s *ReservedKeywordAsTableContext) K_KEYSPACES() antlr.TerminalNode {
	return s.GetToken(CqlParserK_KEYSPACES, 0)
}

func (s *ReservedKeywordAsTableContext) K_TABLES() antlr.TerminalNode {
	return s.GetToken(CqlParserK_TABLES, 0)
}

func (s *ReservedKeywordAsTableContext) K_COLUMNS() antlr.TerminalNode {
	return s.GetToken(CqlParserK_COLUMNS, 0)
}

func (s *ReservedKeywordAsTableContext) K_TYPES() antlr.TerminalNode {
	return s.GetToken(CqlParserK_TYPES, 0)
}

func (s *ReservedKeywordAsTableContext) K_FUNCTIONS() antlr.TerminalNode {
	return s.GetToken(CqlParserK_FUNCTIONS, 0)
}

func (s *ReservedKeywordAsTableContext) K_AGGREGATES() antlr.TerminalNode {
	return s.GetToken(CqlParserK_AGGREGATES, 0)
}

func (s *ReservedKeywordAsTableContext) K_VIEWS() antlr.TerminalNode {
	return s.GetToken(CqlParserK_VIEWS, 0)
}

func (s *ReservedKeywordAsTableContext) K_INDEXES() antlr.TerminalNode {
	return s.GetToken(CqlParserK_INDEXES, 0)
}

func (s *ReservedKeywordAsTableContext) K_USERS() antlr.TerminalNode {
	return s.GetToken(CqlParserK_USERS, 0)
}

func (s *ReservedKeywordAsTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReservedKeywordAsTableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReservedKeywordAsTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterReservedKeywordAsTable(s)
	}
}

func (s *ReservedKeywordAsTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitReservedKeywordAsTable(s)
	}
}

func (p *CqlParser) ReservedKeywordAsTable() (localctx IReservedKeywordAsTableContext) {
	localctx = NewReservedKeywordAsTableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 416, CqlParserRULE_reservedKeywordAsTable)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2997)
		_la = p.GetTokenStream().LA(1)

		if !(_la == CqlParserK_FUNCTIONS || _la == CqlParserK_KEYSPACES || ((int64((_la-182)) & ^0x3f) == 0 && ((int64(1)<<(_la-182))&30064775175) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReservedTypeAsTableContext is an interface to support dynamic dispatch.
type IReservedTypeAsTableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_VARCHAR() antlr.TerminalNode
	K_TEXT() antlr.TerminalNode
	K_INT() antlr.TerminalNode
	K_BIGINT() antlr.TerminalNode
	K_BOOLEAN() antlr.TerminalNode
	K_FLOAT() antlr.TerminalNode
	K_DOUBLE() antlr.TerminalNode
	K_TWO() antlr.TerminalNode
	K_THREE() antlr.TerminalNode
	K_ONE() antlr.TerminalNode

	// IsReservedTypeAsTableContext differentiates from other interfaces.
	IsReservedTypeAsTableContext()
}

type ReservedTypeAsTableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReservedTypeAsTableContext() *ReservedTypeAsTableContext {
	var p = new(ReservedTypeAsTableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_reservedTypeAsTable
	return p
}

func InitEmptyReservedTypeAsTableContext(p *ReservedTypeAsTableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_reservedTypeAsTable
}

func (*ReservedTypeAsTableContext) IsReservedTypeAsTableContext() {}

func NewReservedTypeAsTableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReservedTypeAsTableContext {
	var p = new(ReservedTypeAsTableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_reservedTypeAsTable

	return p
}

func (s *ReservedTypeAsTableContext) GetParser() antlr.Parser { return s.parser }

func (s *ReservedTypeAsTableContext) K_VARCHAR() antlr.TerminalNode {
	return s.GetToken(CqlParserK_VARCHAR, 0)
}

func (s *ReservedTypeAsTableContext) K_TEXT() antlr.TerminalNode {
	return s.GetToken(CqlParserK_TEXT, 0)
}

func (s *ReservedTypeAsTableContext) K_INT() antlr.TerminalNode {
	return s.GetToken(CqlParserK_INT, 0)
}

func (s *ReservedTypeAsTableContext) K_BIGINT() antlr.TerminalNode {
	return s.GetToken(CqlParserK_BIGINT, 0)
}

func (s *ReservedTypeAsTableContext) K_BOOLEAN() antlr.TerminalNode {
	return s.GetToken(CqlParserK_BOOLEAN, 0)
}

func (s *ReservedTypeAsTableContext) K_FLOAT() antlr.TerminalNode {
	return s.GetToken(CqlParserK_FLOAT, 0)
}

func (s *ReservedTypeAsTableContext) K_DOUBLE() antlr.TerminalNode {
	return s.GetToken(CqlParserK_DOUBLE, 0)
}

func (s *ReservedTypeAsTableContext) K_TWO() antlr.TerminalNode {
	return s.GetToken(CqlParserK_TWO, 0)
}

func (s *ReservedTypeAsTableContext) K_THREE() antlr.TerminalNode {
	return s.GetToken(CqlParserK_THREE, 0)
}

func (s *ReservedTypeAsTableContext) K_ONE() antlr.TerminalNode {
	return s.GetToken(CqlParserK_ONE, 0)
}

func (s *ReservedTypeAsTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReservedTypeAsTableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReservedTypeAsTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterReservedTypeAsTable(s)
	}
}

func (s *ReservedTypeAsTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitReservedTypeAsTable(s)
	}
}

func (p *CqlParser) ReservedTypeAsTable() (localctx IReservedTypeAsTableContext) {
	localctx = NewReservedTypeAsTableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 418, CqlParserRULE_reservedTypeAsTable)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2999)
		_la = p.GetTokenStream().LA(1)

		if !(((int64((_la-94)) & ^0x3f) == 0 && ((int64(1)<<(_la-94))&-8536010109233397759) != 0) || _la == CqlParserK_VARCHAR) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDataTypeContext is an interface to support dynamic dispatch.
type IDataTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DataTypeName() IDataTypeNameContext
	DataTypeDefinition() IDataTypeDefinitionContext

	// IsDataTypeContext differentiates from other interfaces.
	IsDataTypeContext()
}

type DataTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataTypeContext() *DataTypeContext {
	var p = new(DataTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_dataType
	return p
}

func InitEmptyDataTypeContext(p *DataTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_dataType
}

func (*DataTypeContext) IsDataTypeContext() {}

func NewDataTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataTypeContext {
	var p = new(DataTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_dataType

	return p
}

func (s *DataTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *DataTypeContext) DataTypeName() IDataTypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeNameContext)
}

func (s *DataTypeContext) DataTypeDefinition() IDataTypeDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeDefinitionContext)
}

func (s *DataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterDataType(s)
	}
}

func (s *DataTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitDataType(s)
	}
}

func (p *CqlParser) DataType() (localctx IDataTypeContext) {
	localctx = NewDataTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 420, CqlParserRULE_dataType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3001)
		p.DataTypeName()
	}
	p.SetState(3003)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CqlParserOPERATOR_LT {
		{
			p.SetState(3002)
			p.DataTypeDefinition()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDataTypeNameContext is an interface to support dynamic dispatch.
type IDataTypeNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OBJECT_NAME() antlr.TerminalNode
	K_TIMESTAMP() antlr.TerminalNode
	K_SET() antlr.TerminalNode
	K_ASCII() antlr.TerminalNode
	K_BIGINT() antlr.TerminalNode
	K_BLOB() antlr.TerminalNode
	K_BOOLEAN() antlr.TerminalNode
	K_COUNTER() antlr.TerminalNode
	K_DATE() antlr.TerminalNode
	K_DECIMAL() antlr.TerminalNode
	K_DOUBLE() antlr.TerminalNode
	K_FLOAT() antlr.TerminalNode
	K_FROZEN() antlr.TerminalNode
	K_INET() antlr.TerminalNode
	K_INT() antlr.TerminalNode
	K_LIST() antlr.TerminalNode
	K_MAP() antlr.TerminalNode
	K_SMALLINT() antlr.TerminalNode
	K_TEXT() antlr.TerminalNode
	K_TIME() antlr.TerminalNode
	K_TIMEUUID() antlr.TerminalNode
	K_TINYINT() antlr.TerminalNode
	K_TUPLE() antlr.TerminalNode
	K_VARCHAR() antlr.TerminalNode
	K_VARINT() antlr.TerminalNode
	K_UUID() antlr.TerminalNode
	K_DURATION() antlr.TerminalNode
	K_VECTOR() antlr.TerminalNode

	// IsDataTypeNameContext differentiates from other interfaces.
	IsDataTypeNameContext()
}

type DataTypeNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataTypeNameContext() *DataTypeNameContext {
	var p = new(DataTypeNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_dataTypeName
	return p
}

func InitEmptyDataTypeNameContext(p *DataTypeNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_dataTypeName
}

func (*DataTypeNameContext) IsDataTypeNameContext() {}

func NewDataTypeNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataTypeNameContext {
	var p = new(DataTypeNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_dataTypeName

	return p
}

func (s *DataTypeNameContext) GetParser() antlr.Parser { return s.parser }

func (s *DataTypeNameContext) OBJECT_NAME() antlr.TerminalNode {
	return s.GetToken(CqlParserOBJECT_NAME, 0)
}

func (s *DataTypeNameContext) K_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(CqlParserK_TIMESTAMP, 0)
}

func (s *DataTypeNameContext) K_SET() antlr.TerminalNode {
	return s.GetToken(CqlParserK_SET, 0)
}

func (s *DataTypeNameContext) K_ASCII() antlr.TerminalNode {
	return s.GetToken(CqlParserK_ASCII, 0)
}

func (s *DataTypeNameContext) K_BIGINT() antlr.TerminalNode {
	return s.GetToken(CqlParserK_BIGINT, 0)
}

func (s *DataTypeNameContext) K_BLOB() antlr.TerminalNode {
	return s.GetToken(CqlParserK_BLOB, 0)
}

func (s *DataTypeNameContext) K_BOOLEAN() antlr.TerminalNode {
	return s.GetToken(CqlParserK_BOOLEAN, 0)
}

func (s *DataTypeNameContext) K_COUNTER() antlr.TerminalNode {
	return s.GetToken(CqlParserK_COUNTER, 0)
}

func (s *DataTypeNameContext) K_DATE() antlr.TerminalNode {
	return s.GetToken(CqlParserK_DATE, 0)
}

func (s *DataTypeNameContext) K_DECIMAL() antlr.TerminalNode {
	return s.GetToken(CqlParserK_DECIMAL, 0)
}

func (s *DataTypeNameContext) K_DOUBLE() antlr.TerminalNode {
	return s.GetToken(CqlParserK_DOUBLE, 0)
}

func (s *DataTypeNameContext) K_FLOAT() antlr.TerminalNode {
	return s.GetToken(CqlParserK_FLOAT, 0)
}

func (s *DataTypeNameContext) K_FROZEN() antlr.TerminalNode {
	return s.GetToken(CqlParserK_FROZEN, 0)
}

func (s *DataTypeNameContext) K_INET() antlr.TerminalNode {
	return s.GetToken(CqlParserK_INET, 0)
}

func (s *DataTypeNameContext) K_INT() antlr.TerminalNode {
	return s.GetToken(CqlParserK_INT, 0)
}

func (s *DataTypeNameContext) K_LIST() antlr.TerminalNode {
	return s.GetToken(CqlParserK_LIST, 0)
}

func (s *DataTypeNameContext) K_MAP() antlr.TerminalNode {
	return s.GetToken(CqlParserK_MAP, 0)
}

func (s *DataTypeNameContext) K_SMALLINT() antlr.TerminalNode {
	return s.GetToken(CqlParserK_SMALLINT, 0)
}

func (s *DataTypeNameContext) K_TEXT() antlr.TerminalNode {
	return s.GetToken(CqlParserK_TEXT, 0)
}

func (s *DataTypeNameContext) K_TIME() antlr.TerminalNode {
	return s.GetToken(CqlParserK_TIME, 0)
}

func (s *DataTypeNameContext) K_TIMEUUID() antlr.TerminalNode {
	return s.GetToken(CqlParserK_TIMEUUID, 0)
}

func (s *DataTypeNameContext) K_TINYINT() antlr.TerminalNode {
	return s.GetToken(CqlParserK_TINYINT, 0)
}

func (s *DataTypeNameContext) K_TUPLE() antlr.TerminalNode {
	return s.GetToken(CqlParserK_TUPLE, 0)
}

func (s *DataTypeNameContext) K_VARCHAR() antlr.TerminalNode {
	return s.GetToken(CqlParserK_VARCHAR, 0)
}

func (s *DataTypeNameContext) K_VARINT() antlr.TerminalNode {
	return s.GetToken(CqlParserK_VARINT, 0)
}

func (s *DataTypeNameContext) K_UUID() antlr.TerminalNode {
	return s.GetToken(CqlParserK_UUID, 0)
}

func (s *DataTypeNameContext) K_DURATION() antlr.TerminalNode {
	return s.GetToken(CqlParserK_DURATION, 0)
}

func (s *DataTypeNameContext) K_VECTOR() antlr.TerminalNode {
	return s.GetToken(CqlParserK_VECTOR, 0)
}

func (s *DataTypeNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataTypeNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataTypeNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterDataTypeName(s)
	}
}

func (s *DataTypeNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitDataTypeName(s)
	}
}

func (p *CqlParser) DataTypeName() (localctx IDataTypeNameContext) {
	localctx = NewDataTypeNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 422, CqlParserRULE_dataTypeName)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3005)
		_la = p.GetTokenStream().LA(1)

		if !(((int64((_la-114)) & ^0x3f) == 0 && ((int64(1)<<(_la-114))&109212290699493633) != 0) || _la == CqlParserOBJECT_NAME) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDataTypeDefinitionContext is an interface to support dynamic dispatch.
type IDataTypeDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SyntaxBracketLa() ISyntaxBracketLaContext
	AllDataTypeArg() []IDataTypeArgContext
	DataTypeArg(i int) IDataTypeArgContext
	SyntaxBracketRa() ISyntaxBracketRaContext
	AllSyntaxComma() []ISyntaxCommaContext
	SyntaxComma(i int) ISyntaxCommaContext

	// IsDataTypeDefinitionContext differentiates from other interfaces.
	IsDataTypeDefinitionContext()
}

type DataTypeDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataTypeDefinitionContext() *DataTypeDefinitionContext {
	var p = new(DataTypeDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_dataTypeDefinition
	return p
}

func InitEmptyDataTypeDefinitionContext(p *DataTypeDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_dataTypeDefinition
}

func (*DataTypeDefinitionContext) IsDataTypeDefinitionContext() {}

func NewDataTypeDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataTypeDefinitionContext {
	var p = new(DataTypeDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_dataTypeDefinition

	return p
}

func (s *DataTypeDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *DataTypeDefinitionContext) SyntaxBracketLa() ISyntaxBracketLaContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxBracketLaContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxBracketLaContext)
}

func (s *DataTypeDefinitionContext) AllDataTypeArg() []IDataTypeArgContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDataTypeArgContext); ok {
			len++
		}
	}

	tst := make([]IDataTypeArgContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDataTypeArgContext); ok {
			tst[i] = t.(IDataTypeArgContext)
			i++
		}
	}

	return tst
}

func (s *DataTypeDefinitionContext) DataTypeArg(i int) IDataTypeArgContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeArgContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeArgContext)
}

func (s *DataTypeDefinitionContext) SyntaxBracketRa() ISyntaxBracketRaContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxBracketRaContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxBracketRaContext)
}

func (s *DataTypeDefinitionContext) AllSyntaxComma() []ISyntaxCommaContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			len++
		}
	}

	tst := make([]ISyntaxCommaContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISyntaxCommaContext); ok {
			tst[i] = t.(ISyntaxCommaContext)
			i++
		}
	}

	return tst
}

func (s *DataTypeDefinitionContext) SyntaxComma(i int) ISyntaxCommaContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxCommaContext)
}

func (s *DataTypeDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataTypeDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataTypeDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterDataTypeDefinition(s)
	}
}

func (s *DataTypeDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitDataTypeDefinition(s)
	}
}

func (p *CqlParser) DataTypeDefinition() (localctx IDataTypeDefinitionContext) {
	localctx = NewDataTypeDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 424, CqlParserRULE_dataTypeDefinition)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3007)
		p.SyntaxBracketLa()
	}
	{
		p.SetState(3008)
		p.DataTypeArg()
	}
	p.SetState(3014)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == CqlParserCOMMA {
		{
			p.SetState(3009)
			p.SyntaxComma()
		}
		{
			p.SetState(3010)
			p.DataTypeArg()
		}

		p.SetState(3016)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3017)
		p.SyntaxBracketRa()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDataTypeArgContext is an interface to support dynamic dispatch.
type IDataTypeArgContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DataType() IDataTypeContext
	DecimalLiteral() IDecimalLiteralContext

	// IsDataTypeArgContext differentiates from other interfaces.
	IsDataTypeArgContext()
}

type DataTypeArgContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataTypeArgContext() *DataTypeArgContext {
	var p = new(DataTypeArgContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_dataTypeArg
	return p
}

func InitEmptyDataTypeArgContext(p *DataTypeArgContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_dataTypeArg
}

func (*DataTypeArgContext) IsDataTypeArgContext() {}

func NewDataTypeArgContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataTypeArgContext {
	var p = new(DataTypeArgContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_dataTypeArg

	return p
}

func (s *DataTypeArgContext) GetParser() antlr.Parser { return s.parser }

func (s *DataTypeArgContext) DataType() IDataTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *DataTypeArgContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *DataTypeArgContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataTypeArgContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataTypeArgContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterDataTypeArg(s)
	}
}

func (s *DataTypeArgContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitDataTypeArg(s)
	}
}

func (p *CqlParser) DataTypeArg() (localctx IDataTypeArgContext) {
	localctx = NewDataTypeArgContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 426, CqlParserRULE_dataTypeArg)
	p.SetState(3021)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case CqlParserK_SET, CqlParserK_TIMESTAMP, CqlParserK_UUID, CqlParserK_ASCII, CqlParserK_BIGINT, CqlParserK_BLOB, CqlParserK_BOOLEAN, CqlParserK_COUNTER, CqlParserK_DATE, CqlParserK_DECIMAL, CqlParserK_DOUBLE, CqlParserK_FLOAT, CqlParserK_FROZEN, CqlParserK_INET, CqlParserK_INT, CqlParserK_LIST, CqlParserK_MAP, CqlParserK_SMALLINT, CqlParserK_TEXT, CqlParserK_TIMEUUID, CqlParserK_TIME, CqlParserK_TINYINT, CqlParserK_TUPLE, CqlParserK_VARCHAR, CqlParserK_VARINT, CqlParserK_DURATION, CqlParserK_VECTOR, CqlParserOBJECT_NAME:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3019)
			p.DataType()
		}

	case CqlParserDECIMAL_LITERAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3020)
			p.DecimalLiteral()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOrderDirectionContext is an interface to support dynamic dispatch.
type IOrderDirectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwAsc() IKwAscContext
	KwDesc() IKwDescContext

	// IsOrderDirectionContext differentiates from other interfaces.
	IsOrderDirectionContext()
}

type OrderDirectionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrderDirectionContext() *OrderDirectionContext {
	var p = new(OrderDirectionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_orderDirection
	return p
}

func InitEmptyOrderDirectionContext(p *OrderDirectionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_orderDirection
}

func (*OrderDirectionContext) IsOrderDirectionContext() {}

func NewOrderDirectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OrderDirectionContext {
	var p = new(OrderDirectionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_orderDirection

	return p
}

func (s *OrderDirectionContext) GetParser() antlr.Parser { return s.parser }

func (s *OrderDirectionContext) KwAsc() IKwAscContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwAscContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwAscContext)
}

func (s *OrderDirectionContext) KwDesc() IKwDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwDescContext)
}

func (s *OrderDirectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OrderDirectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OrderDirectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterOrderDirection(s)
	}
}

func (s *OrderDirectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitOrderDirection(s)
	}
}

func (p *CqlParser) OrderDirection() (localctx IOrderDirectionContext) {
	localctx = NewOrderDirectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 428, CqlParserRULE_orderDirection)
	p.SetState(3025)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case CqlParserK_ASC:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3023)
			p.KwAsc()
		}

	case CqlParserK_DESC:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3024)
			p.KwDesc()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRoleContext is an interface to support dynamic dispatch.
type IRoleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OBJECT_NAME() antlr.TerminalNode

	// IsRoleContext differentiates from other interfaces.
	IsRoleContext()
}

type RoleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRoleContext() *RoleContext {
	var p = new(RoleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_role
	return p
}

func InitEmptyRoleContext(p *RoleContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_role
}

func (*RoleContext) IsRoleContext() {}

func NewRoleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RoleContext {
	var p = new(RoleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_role

	return p
}

func (s *RoleContext) GetParser() antlr.Parser { return s.parser }

func (s *RoleContext) OBJECT_NAME() antlr.TerminalNode {
	return s.GetToken(CqlParserOBJECT_NAME, 0)
}

func (s *RoleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RoleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RoleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterRole(s)
	}
}

func (s *RoleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitRole(s)
	}
}

func (p *CqlParser) Role() (localctx IRoleContext) {
	localctx = NewRoleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 430, CqlParserRULE_role)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3027)
		p.Match(CqlParserOBJECT_NAME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITriggerContext is an interface to support dynamic dispatch.
type ITriggerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OBJECT_NAME() antlr.TerminalNode

	// IsTriggerContext differentiates from other interfaces.
	IsTriggerContext()
}

type TriggerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTriggerContext() *TriggerContext {
	var p = new(TriggerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_trigger
	return p
}

func InitEmptyTriggerContext(p *TriggerContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_trigger
}

func (*TriggerContext) IsTriggerContext() {}

func NewTriggerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TriggerContext {
	var p = new(TriggerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_trigger

	return p
}

func (s *TriggerContext) GetParser() antlr.Parser { return s.parser }

func (s *TriggerContext) OBJECT_NAME() antlr.TerminalNode {
	return s.GetToken(CqlParserOBJECT_NAME, 0)
}

func (s *TriggerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TriggerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TriggerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterTrigger(s)
	}
}

func (s *TriggerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitTrigger(s)
	}
}

func (p *CqlParser) Trigger() (localctx ITriggerContext) {
	localctx = NewTriggerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 432, CqlParserRULE_trigger)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3029)
		p.Match(CqlParserOBJECT_NAME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITriggerClassContext is an interface to support dynamic dispatch.
type ITriggerClassContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	StringLiteral() IStringLiteralContext

	// IsTriggerClassContext differentiates from other interfaces.
	IsTriggerClassContext()
}

type TriggerClassContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTriggerClassContext() *TriggerClassContext {
	var p = new(TriggerClassContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_triggerClass
	return p
}

func InitEmptyTriggerClassContext(p *TriggerClassContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_triggerClass
}

func (*TriggerClassContext) IsTriggerClassContext() {}

func NewTriggerClassContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TriggerClassContext {
	var p = new(TriggerClassContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_triggerClass

	return p
}

func (s *TriggerClassContext) GetParser() antlr.Parser { return s.parser }

func (s *TriggerClassContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *TriggerClassContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TriggerClassContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TriggerClassContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterTriggerClass(s)
	}
}

func (s *TriggerClassContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitTriggerClass(s)
	}
}

func (p *CqlParser) TriggerClass() (localctx ITriggerClassContext) {
	localctx = NewTriggerClassContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 434, CqlParserRULE_triggerClass)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3031)
		p.StringLiteral()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMaterializedViewContext is an interface to support dynamic dispatch.
type IMaterializedViewContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OBJECT_NAME() antlr.TerminalNode

	// IsMaterializedViewContext differentiates from other interfaces.
	IsMaterializedViewContext()
}

type MaterializedViewContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMaterializedViewContext() *MaterializedViewContext {
	var p = new(MaterializedViewContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_materializedView
	return p
}

func InitEmptyMaterializedViewContext(p *MaterializedViewContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_materializedView
}

func (*MaterializedViewContext) IsMaterializedViewContext() {}

func NewMaterializedViewContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MaterializedViewContext {
	var p = new(MaterializedViewContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_materializedView

	return p
}

func (s *MaterializedViewContext) GetParser() antlr.Parser { return s.parser }

func (s *MaterializedViewContext) OBJECT_NAME() antlr.TerminalNode {
	return s.GetToken(CqlParserOBJECT_NAME, 0)
}

func (s *MaterializedViewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MaterializedViewContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MaterializedViewContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterMaterializedView(s)
	}
}

func (s *MaterializedViewContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitMaterializedView(s)
	}
}

func (p *CqlParser) MaterializedView() (localctx IMaterializedViewContext) {
	localctx = NewMaterializedViewContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 436, CqlParserRULE_materializedView)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3033)
		p.Match(CqlParserOBJECT_NAME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IType_Context is an interface to support dynamic dispatch.
type IType_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OBJECT_NAME() antlr.TerminalNode

	// IsType_Context differentiates from other interfaces.
	IsType_Context()
}

type Type_Context struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_Context() *Type_Context {
	var p = new(Type_Context)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_type_
	return p
}

func InitEmptyType_Context(p *Type_Context) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_type_
}

func (*Type_Context) IsType_Context() {}

func NewType_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_Context {
	var p = new(Type_Context)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_type_

	return p
}

func (s *Type_Context) GetParser() antlr.Parser { return s.parser }

func (s *Type_Context) OBJECT_NAME() antlr.TerminalNode {
	return s.GetToken(CqlParserOBJECT_NAME, 0)
}

func (s *Type_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Type_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterType_(s)
	}
}

func (s *Type_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitType_(s)
	}
}

func (p *CqlParser) Type_() (localctx IType_Context) {
	localctx = NewType_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 438, CqlParserRULE_type_)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3035)
		p.Match(CqlParserOBJECT_NAME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAggregateContext is an interface to support dynamic dispatch.
type IAggregateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OBJECT_NAME() antlr.TerminalNode

	// IsAggregateContext differentiates from other interfaces.
	IsAggregateContext()
}

type AggregateContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAggregateContext() *AggregateContext {
	var p = new(AggregateContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_aggregate
	return p
}

func InitEmptyAggregateContext(p *AggregateContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_aggregate
}

func (*AggregateContext) IsAggregateContext() {}

func NewAggregateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AggregateContext {
	var p = new(AggregateContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_aggregate

	return p
}

func (s *AggregateContext) GetParser() antlr.Parser { return s.parser }

func (s *AggregateContext) OBJECT_NAME() antlr.TerminalNode {
	return s.GetToken(CqlParserOBJECT_NAME, 0)
}

func (s *AggregateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AggregateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AggregateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterAggregate(s)
	}
}

func (s *AggregateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitAggregate(s)
	}
}

func (p *CqlParser) Aggregate() (localctx IAggregateContext) {
	localctx = NewAggregateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 440, CqlParserRULE_aggregate)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3037)
		p.Match(CqlParserOBJECT_NAME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunction_Context is an interface to support dynamic dispatch.
type IFunction_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OBJECT_NAME() antlr.TerminalNode

	// IsFunction_Context differentiates from other interfaces.
	IsFunction_Context()
}

type Function_Context struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_Context() *Function_Context {
	var p = new(Function_Context)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_function_
	return p
}

func InitEmptyFunction_Context(p *Function_Context) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_function_
}

func (*Function_Context) IsFunction_Context() {}

func NewFunction_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_Context {
	var p = new(Function_Context)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_function_

	return p
}

func (s *Function_Context) GetParser() antlr.Parser { return s.parser }

func (s *Function_Context) OBJECT_NAME() antlr.TerminalNode {
	return s.GetToken(CqlParserOBJECT_NAME, 0)
}

func (s *Function_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterFunction_(s)
	}
}

func (s *Function_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitFunction_(s)
	}
}

func (p *CqlParser) Function_() (localctx IFunction_Context) {
	localctx = NewFunction_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 442, CqlParserRULE_function_)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3039)
		p.Match(CqlParserOBJECT_NAME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILanguageContext is an interface to support dynamic dispatch.
type ILanguageContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OBJECT_NAME() antlr.TerminalNode

	// IsLanguageContext differentiates from other interfaces.
	IsLanguageContext()
}

type LanguageContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLanguageContext() *LanguageContext {
	var p = new(LanguageContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_language
	return p
}

func InitEmptyLanguageContext(p *LanguageContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_language
}

func (*LanguageContext) IsLanguageContext() {}

func NewLanguageContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LanguageContext {
	var p = new(LanguageContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_language

	return p
}

func (s *LanguageContext) GetParser() antlr.Parser { return s.parser }

func (s *LanguageContext) OBJECT_NAME() antlr.TerminalNode {
	return s.GetToken(CqlParserOBJECT_NAME, 0)
}

func (s *LanguageContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LanguageContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LanguageContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterLanguage(s)
	}
}

func (s *LanguageContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitLanguage(s)
	}
}

func (p *CqlParser) Language() (localctx ILanguageContext) {
	localctx = NewLanguageContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 444, CqlParserRULE_language)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3041)
		p.Match(CqlParserOBJECT_NAME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUserContext is an interface to support dynamic dispatch.
type IUserContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OBJECT_NAME() antlr.TerminalNode

	// IsUserContext differentiates from other interfaces.
	IsUserContext()
}

type UserContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUserContext() *UserContext {
	var p = new(UserContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_user
	return p
}

func InitEmptyUserContext(p *UserContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_user
}

func (*UserContext) IsUserContext() {}

func NewUserContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UserContext {
	var p = new(UserContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_user

	return p
}

func (s *UserContext) GetParser() antlr.Parser { return s.parser }

func (s *UserContext) OBJECT_NAME() antlr.TerminalNode {
	return s.GetToken(CqlParserOBJECT_NAME, 0)
}

func (s *UserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UserContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterUser(s)
	}
}

func (s *UserContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitUser(s)
	}
}

func (p *CqlParser) User() (localctx IUserContext) {
	localctx = NewUserContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 446, CqlParserRULE_user)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3043)
		p.Match(CqlParserOBJECT_NAME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPasswordContext is an interface to support dynamic dispatch.
type IPasswordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	StringLiteral() IStringLiteralContext

	// IsPasswordContext differentiates from other interfaces.
	IsPasswordContext()
}

type PasswordContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPasswordContext() *PasswordContext {
	var p = new(PasswordContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_password
	return p
}

func InitEmptyPasswordContext(p *PasswordContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_password
}

func (*PasswordContext) IsPasswordContext() {}

func NewPasswordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PasswordContext {
	var p = new(PasswordContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_password

	return p
}

func (s *PasswordContext) GetParser() antlr.Parser { return s.parser }

func (s *PasswordContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *PasswordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PasswordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PasswordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterPassword(s)
	}
}

func (s *PasswordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitPassword(s)
	}
}

func (p *CqlParser) Password() (localctx IPasswordContext) {
	localctx = NewPasswordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 448, CqlParserRULE_password)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3045)
		p.StringLiteral()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHashKeyContext is an interface to support dynamic dispatch.
type IHashKeyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OBJECT_NAME() antlr.TerminalNode

	// IsHashKeyContext differentiates from other interfaces.
	IsHashKeyContext()
}

type HashKeyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHashKeyContext() *HashKeyContext {
	var p = new(HashKeyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_hashKey
	return p
}

func InitEmptyHashKeyContext(p *HashKeyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_hashKey
}

func (*HashKeyContext) IsHashKeyContext() {}

func NewHashKeyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HashKeyContext {
	var p = new(HashKeyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_hashKey

	return p
}

func (s *HashKeyContext) GetParser() antlr.Parser { return s.parser }

func (s *HashKeyContext) OBJECT_NAME() antlr.TerminalNode {
	return s.GetToken(CqlParserOBJECT_NAME, 0)
}

func (s *HashKeyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HashKeyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HashKeyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterHashKey(s)
	}
}

func (s *HashKeyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitHashKey(s)
	}
}

func (p *CqlParser) HashKey() (localctx IHashKeyContext) {
	localctx = NewHashKeyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 450, CqlParserRULE_hashKey)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3047)
		p.Match(CqlParserOBJECT_NAME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParamContext is an interface to support dynamic dispatch.
type IParamContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ParamName() IParamNameContext
	DataType() IDataTypeContext

	// IsParamContext differentiates from other interfaces.
	IsParamContext()
}

type ParamContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParamContext() *ParamContext {
	var p = new(ParamContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_param
	return p
}

func InitEmptyParamContext(p *ParamContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_param
}

func (*ParamContext) IsParamContext() {}

func NewParamContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParamContext {
	var p = new(ParamContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_param

	return p
}

func (s *ParamContext) GetParser() antlr.Parser { return s.parser }

func (s *ParamContext) ParamName() IParamNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParamNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParamNameContext)
}

func (s *ParamContext) DataType() IDataTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *ParamContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParamContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParamContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterParam(s)
	}
}

func (s *ParamContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitParam(s)
	}
}

func (p *CqlParser) Param() (localctx IParamContext) {
	localctx = NewParamContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 452, CqlParserRULE_param)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3049)
		p.ParamName()
	}
	{
		p.SetState(3050)
		p.DataType()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParamNameContext is an interface to support dynamic dispatch.
type IParamNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OBJECT_NAME() antlr.TerminalNode
	K_INPUT() antlr.TerminalNode

	// IsParamNameContext differentiates from other interfaces.
	IsParamNameContext()
}

type ParamNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParamNameContext() *ParamNameContext {
	var p = new(ParamNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_paramName
	return p
}

func InitEmptyParamNameContext(p *ParamNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_paramName
}

func (*ParamNameContext) IsParamNameContext() {}

func NewParamNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParamNameContext {
	var p = new(ParamNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_paramName

	return p
}

func (s *ParamNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ParamNameContext) OBJECT_NAME() antlr.TerminalNode {
	return s.GetToken(CqlParserOBJECT_NAME, 0)
}

func (s *ParamNameContext) K_INPUT() antlr.TerminalNode {
	return s.GetToken(CqlParserK_INPUT, 0)
}

func (s *ParamNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParamNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParamNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterParamName(s)
	}
}

func (s *ParamNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitParamName(s)
	}
}

func (p *CqlParser) ParamName() (localctx IParamNameContext) {
	localctx = NewParamNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 454, CqlParserRULE_paramName)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3052)
		_la = p.GetTokenStream().LA(1)

		if !(_la == CqlParserK_INPUT || _la == CqlParserOBJECT_NAME) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwAddContext is an interface to support dynamic dispatch.
type IKwAddContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_ADD() antlr.TerminalNode

	// IsKwAddContext differentiates from other interfaces.
	IsKwAddContext()
}

type KwAddContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwAddContext() *KwAddContext {
	var p = new(KwAddContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwAdd
	return p
}

func InitEmptyKwAddContext(p *KwAddContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwAdd
}

func (*KwAddContext) IsKwAddContext() {}

func NewKwAddContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwAddContext {
	var p = new(KwAddContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwAdd

	return p
}

func (s *KwAddContext) GetParser() antlr.Parser { return s.parser }

func (s *KwAddContext) K_ADD() antlr.TerminalNode {
	return s.GetToken(CqlParserK_ADD, 0)
}

func (s *KwAddContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwAddContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwAddContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwAdd(s)
	}
}

func (s *KwAddContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwAdd(s)
	}
}

func (p *CqlParser) KwAdd() (localctx IKwAddContext) {
	localctx = NewKwAddContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 456, CqlParserRULE_kwAdd)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3054)
		p.Match(CqlParserK_ADD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwAggregateContext is an interface to support dynamic dispatch.
type IKwAggregateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_AGGREGATE() antlr.TerminalNode

	// IsKwAggregateContext differentiates from other interfaces.
	IsKwAggregateContext()
}

type KwAggregateContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwAggregateContext() *KwAggregateContext {
	var p = new(KwAggregateContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwAggregate
	return p
}

func InitEmptyKwAggregateContext(p *KwAggregateContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwAggregate
}

func (*KwAggregateContext) IsKwAggregateContext() {}

func NewKwAggregateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwAggregateContext {
	var p = new(KwAggregateContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwAggregate

	return p
}

func (s *KwAggregateContext) GetParser() antlr.Parser { return s.parser }

func (s *KwAggregateContext) K_AGGREGATE() antlr.TerminalNode {
	return s.GetToken(CqlParserK_AGGREGATE, 0)
}

func (s *KwAggregateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwAggregateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwAggregateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwAggregate(s)
	}
}

func (s *KwAggregateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwAggregate(s)
	}
}

func (p *CqlParser) KwAggregate() (localctx IKwAggregateContext) {
	localctx = NewKwAggregateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 458, CqlParserRULE_kwAggregate)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3056)
		p.Match(CqlParserK_AGGREGATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwAllContext is an interface to support dynamic dispatch.
type IKwAllContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_ALL() antlr.TerminalNode

	// IsKwAllContext differentiates from other interfaces.
	IsKwAllContext()
}

type KwAllContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwAllContext() *KwAllContext {
	var p = new(KwAllContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwAll
	return p
}

func InitEmptyKwAllContext(p *KwAllContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwAll
}

func (*KwAllContext) IsKwAllContext() {}

func NewKwAllContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwAllContext {
	var p = new(KwAllContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwAll

	return p
}

func (s *KwAllContext) GetParser() antlr.Parser { return s.parser }

func (s *KwAllContext) K_ALL() antlr.TerminalNode {
	return s.GetToken(CqlParserK_ALL, 0)
}

func (s *KwAllContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwAllContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwAllContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwAll(s)
	}
}

func (s *KwAllContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwAll(s)
	}
}

func (p *CqlParser) KwAll() (localctx IKwAllContext) {
	localctx = NewKwAllContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 460, CqlParserRULE_kwAll)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3058)
		p.Match(CqlParserK_ALL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwAllPermissionsContext is an interface to support dynamic dispatch.
type IKwAllPermissionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_ALL() antlr.TerminalNode
	K_PERMISSIONS() antlr.TerminalNode

	// IsKwAllPermissionsContext differentiates from other interfaces.
	IsKwAllPermissionsContext()
}

type KwAllPermissionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwAllPermissionsContext() *KwAllPermissionsContext {
	var p = new(KwAllPermissionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwAllPermissions
	return p
}

func InitEmptyKwAllPermissionsContext(p *KwAllPermissionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwAllPermissions
}

func (*KwAllPermissionsContext) IsKwAllPermissionsContext() {}

func NewKwAllPermissionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwAllPermissionsContext {
	var p = new(KwAllPermissionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwAllPermissions

	return p
}

func (s *KwAllPermissionsContext) GetParser() antlr.Parser { return s.parser }

func (s *KwAllPermissionsContext) K_ALL() antlr.TerminalNode {
	return s.GetToken(CqlParserK_ALL, 0)
}

func (s *KwAllPermissionsContext) K_PERMISSIONS() antlr.TerminalNode {
	return s.GetToken(CqlParserK_PERMISSIONS, 0)
}

func (s *KwAllPermissionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwAllPermissionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwAllPermissionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwAllPermissions(s)
	}
}

func (s *KwAllPermissionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwAllPermissions(s)
	}
}

func (p *CqlParser) KwAllPermissions() (localctx IKwAllPermissionsContext) {
	localctx = NewKwAllPermissionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 462, CqlParserRULE_kwAllPermissions)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3060)
		p.Match(CqlParserK_ALL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3061)
		p.Match(CqlParserK_PERMISSIONS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwAllowContext is an interface to support dynamic dispatch.
type IKwAllowContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_ALLOW() antlr.TerminalNode

	// IsKwAllowContext differentiates from other interfaces.
	IsKwAllowContext()
}

type KwAllowContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwAllowContext() *KwAllowContext {
	var p = new(KwAllowContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwAllow
	return p
}

func InitEmptyKwAllowContext(p *KwAllowContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwAllow
}

func (*KwAllowContext) IsKwAllowContext() {}

func NewKwAllowContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwAllowContext {
	var p = new(KwAllowContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwAllow

	return p
}

func (s *KwAllowContext) GetParser() antlr.Parser { return s.parser }

func (s *KwAllowContext) K_ALLOW() antlr.TerminalNode {
	return s.GetToken(CqlParserK_ALLOW, 0)
}

func (s *KwAllowContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwAllowContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwAllowContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwAllow(s)
	}
}

func (s *KwAllowContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwAllow(s)
	}
}

func (p *CqlParser) KwAllow() (localctx IKwAllowContext) {
	localctx = NewKwAllowContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 464, CqlParserRULE_kwAllow)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3063)
		p.Match(CqlParserK_ALLOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwAlterContext is an interface to support dynamic dispatch.
type IKwAlterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_ALTER() antlr.TerminalNode

	// IsKwAlterContext differentiates from other interfaces.
	IsKwAlterContext()
}

type KwAlterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwAlterContext() *KwAlterContext {
	var p = new(KwAlterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwAlter
	return p
}

func InitEmptyKwAlterContext(p *KwAlterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwAlter
}

func (*KwAlterContext) IsKwAlterContext() {}

func NewKwAlterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwAlterContext {
	var p = new(KwAlterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwAlter

	return p
}

func (s *KwAlterContext) GetParser() antlr.Parser { return s.parser }

func (s *KwAlterContext) K_ALTER() antlr.TerminalNode {
	return s.GetToken(CqlParserK_ALTER, 0)
}

func (s *KwAlterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwAlterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwAlterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwAlter(s)
	}
}

func (s *KwAlterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwAlter(s)
	}
}

func (p *CqlParser) KwAlter() (localctx IKwAlterContext) {
	localctx = NewKwAlterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 466, CqlParserRULE_kwAlter)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3065)
		p.Match(CqlParserK_ALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwAndContext is an interface to support dynamic dispatch.
type IKwAndContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_AND() antlr.TerminalNode

	// IsKwAndContext differentiates from other interfaces.
	IsKwAndContext()
}

type KwAndContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwAndContext() *KwAndContext {
	var p = new(KwAndContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwAnd
	return p
}

func InitEmptyKwAndContext(p *KwAndContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwAnd
}

func (*KwAndContext) IsKwAndContext() {}

func NewKwAndContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwAndContext {
	var p = new(KwAndContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwAnd

	return p
}

func (s *KwAndContext) GetParser() antlr.Parser { return s.parser }

func (s *KwAndContext) K_AND() antlr.TerminalNode {
	return s.GetToken(CqlParserK_AND, 0)
}

func (s *KwAndContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwAndContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwAndContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwAnd(s)
	}
}

func (s *KwAndContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwAnd(s)
	}
}

func (p *CqlParser) KwAnd() (localctx IKwAndContext) {
	localctx = NewKwAndContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 468, CqlParserRULE_kwAnd)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3067)
		p.Match(CqlParserK_AND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwApplyContext is an interface to support dynamic dispatch.
type IKwApplyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_APPLY() antlr.TerminalNode

	// IsKwApplyContext differentiates from other interfaces.
	IsKwApplyContext()
}

type KwApplyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwApplyContext() *KwApplyContext {
	var p = new(KwApplyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwApply
	return p
}

func InitEmptyKwApplyContext(p *KwApplyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwApply
}

func (*KwApplyContext) IsKwApplyContext() {}

func NewKwApplyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwApplyContext {
	var p = new(KwApplyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwApply

	return p
}

func (s *KwApplyContext) GetParser() antlr.Parser { return s.parser }

func (s *KwApplyContext) K_APPLY() antlr.TerminalNode {
	return s.GetToken(CqlParserK_APPLY, 0)
}

func (s *KwApplyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwApplyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwApplyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwApply(s)
	}
}

func (s *KwApplyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwApply(s)
	}
}

func (p *CqlParser) KwApply() (localctx IKwApplyContext) {
	localctx = NewKwApplyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 470, CqlParserRULE_kwApply)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3069)
		p.Match(CqlParserK_APPLY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwAsContext is an interface to support dynamic dispatch.
type IKwAsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_AS() antlr.TerminalNode

	// IsKwAsContext differentiates from other interfaces.
	IsKwAsContext()
}

type KwAsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwAsContext() *KwAsContext {
	var p = new(KwAsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwAs
	return p
}

func InitEmptyKwAsContext(p *KwAsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwAs
}

func (*KwAsContext) IsKwAsContext() {}

func NewKwAsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwAsContext {
	var p = new(KwAsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwAs

	return p
}

func (s *KwAsContext) GetParser() antlr.Parser { return s.parser }

func (s *KwAsContext) K_AS() antlr.TerminalNode {
	return s.GetToken(CqlParserK_AS, 0)
}

func (s *KwAsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwAsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwAsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwAs(s)
	}
}

func (s *KwAsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwAs(s)
	}
}

func (p *CqlParser) KwAs() (localctx IKwAsContext) {
	localctx = NewKwAsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 472, CqlParserRULE_kwAs)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3071)
		p.Match(CqlParserK_AS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwAscContext is an interface to support dynamic dispatch.
type IKwAscContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_ASC() antlr.TerminalNode

	// IsKwAscContext differentiates from other interfaces.
	IsKwAscContext()
}

type KwAscContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwAscContext() *KwAscContext {
	var p = new(KwAscContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwAsc
	return p
}

func InitEmptyKwAscContext(p *KwAscContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwAsc
}

func (*KwAscContext) IsKwAscContext() {}

func NewKwAscContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwAscContext {
	var p = new(KwAscContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwAsc

	return p
}

func (s *KwAscContext) GetParser() antlr.Parser { return s.parser }

func (s *KwAscContext) K_ASC() antlr.TerminalNode {
	return s.GetToken(CqlParserK_ASC, 0)
}

func (s *KwAscContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwAscContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwAscContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwAsc(s)
	}
}

func (s *KwAscContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwAsc(s)
	}
}

func (p *CqlParser) KwAsc() (localctx IKwAscContext) {
	localctx = NewKwAscContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 474, CqlParserRULE_kwAsc)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3073)
		p.Match(CqlParserK_ASC)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwAuthorizeContext is an interface to support dynamic dispatch.
type IKwAuthorizeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_AUTHORIZE() antlr.TerminalNode

	// IsKwAuthorizeContext differentiates from other interfaces.
	IsKwAuthorizeContext()
}

type KwAuthorizeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwAuthorizeContext() *KwAuthorizeContext {
	var p = new(KwAuthorizeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwAuthorize
	return p
}

func InitEmptyKwAuthorizeContext(p *KwAuthorizeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwAuthorize
}

func (*KwAuthorizeContext) IsKwAuthorizeContext() {}

func NewKwAuthorizeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwAuthorizeContext {
	var p = new(KwAuthorizeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwAuthorize

	return p
}

func (s *KwAuthorizeContext) GetParser() antlr.Parser { return s.parser }

func (s *KwAuthorizeContext) K_AUTHORIZE() antlr.TerminalNode {
	return s.GetToken(CqlParserK_AUTHORIZE, 0)
}

func (s *KwAuthorizeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwAuthorizeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwAuthorizeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwAuthorize(s)
	}
}

func (s *KwAuthorizeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwAuthorize(s)
	}
}

func (p *CqlParser) KwAuthorize() (localctx IKwAuthorizeContext) {
	localctx = NewKwAuthorizeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 476, CqlParserRULE_kwAuthorize)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3075)
		p.Match(CqlParserK_AUTHORIZE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwBatchContext is an interface to support dynamic dispatch.
type IKwBatchContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_BATCH() antlr.TerminalNode

	// IsKwBatchContext differentiates from other interfaces.
	IsKwBatchContext()
}

type KwBatchContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwBatchContext() *KwBatchContext {
	var p = new(KwBatchContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwBatch
	return p
}

func InitEmptyKwBatchContext(p *KwBatchContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwBatch
}

func (*KwBatchContext) IsKwBatchContext() {}

func NewKwBatchContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwBatchContext {
	var p = new(KwBatchContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwBatch

	return p
}

func (s *KwBatchContext) GetParser() antlr.Parser { return s.parser }

func (s *KwBatchContext) K_BATCH() antlr.TerminalNode {
	return s.GetToken(CqlParserK_BATCH, 0)
}

func (s *KwBatchContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwBatchContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwBatchContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwBatch(s)
	}
}

func (s *KwBatchContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwBatch(s)
	}
}

func (p *CqlParser) KwBatch() (localctx IKwBatchContext) {
	localctx = NewKwBatchContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 478, CqlParserRULE_kwBatch)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3077)
		p.Match(CqlParserK_BATCH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwBeginContext is an interface to support dynamic dispatch.
type IKwBeginContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_BEGIN() antlr.TerminalNode

	// IsKwBeginContext differentiates from other interfaces.
	IsKwBeginContext()
}

type KwBeginContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwBeginContext() *KwBeginContext {
	var p = new(KwBeginContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwBegin
	return p
}

func InitEmptyKwBeginContext(p *KwBeginContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwBegin
}

func (*KwBeginContext) IsKwBeginContext() {}

func NewKwBeginContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwBeginContext {
	var p = new(KwBeginContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwBegin

	return p
}

func (s *KwBeginContext) GetParser() antlr.Parser { return s.parser }

func (s *KwBeginContext) K_BEGIN() antlr.TerminalNode {
	return s.GetToken(CqlParserK_BEGIN, 0)
}

func (s *KwBeginContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwBeginContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwBeginContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwBegin(s)
	}
}

func (s *KwBeginContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwBegin(s)
	}
}

func (p *CqlParser) KwBegin() (localctx IKwBeginContext) {
	localctx = NewKwBeginContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 480, CqlParserRULE_kwBegin)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3079)
		p.Match(CqlParserK_BEGIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwByContext is an interface to support dynamic dispatch.
type IKwByContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_BY() antlr.TerminalNode

	// IsKwByContext differentiates from other interfaces.
	IsKwByContext()
}

type KwByContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwByContext() *KwByContext {
	var p = new(KwByContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwBy
	return p
}

func InitEmptyKwByContext(p *KwByContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwBy
}

func (*KwByContext) IsKwByContext() {}

func NewKwByContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwByContext {
	var p = new(KwByContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwBy

	return p
}

func (s *KwByContext) GetParser() antlr.Parser { return s.parser }

func (s *KwByContext) K_BY() antlr.TerminalNode {
	return s.GetToken(CqlParserK_BY, 0)
}

func (s *KwByContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwByContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwByContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwBy(s)
	}
}

func (s *KwByContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwBy(s)
	}
}

func (p *CqlParser) KwBy() (localctx IKwByContext) {
	localctx = NewKwByContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 482, CqlParserRULE_kwBy)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3081)
		p.Match(CqlParserK_BY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwCalledContext is an interface to support dynamic dispatch.
type IKwCalledContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_CALLED() antlr.TerminalNode

	// IsKwCalledContext differentiates from other interfaces.
	IsKwCalledContext()
}

type KwCalledContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwCalledContext() *KwCalledContext {
	var p = new(KwCalledContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwCalled
	return p
}

func InitEmptyKwCalledContext(p *KwCalledContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwCalled
}

func (*KwCalledContext) IsKwCalledContext() {}

func NewKwCalledContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwCalledContext {
	var p = new(KwCalledContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwCalled

	return p
}

func (s *KwCalledContext) GetParser() antlr.Parser { return s.parser }

func (s *KwCalledContext) K_CALLED() antlr.TerminalNode {
	return s.GetToken(CqlParserK_CALLED, 0)
}

func (s *KwCalledContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwCalledContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwCalledContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwCalled(s)
	}
}

func (s *KwCalledContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwCalled(s)
	}
}

func (p *CqlParser) KwCalled() (localctx IKwCalledContext) {
	localctx = NewKwCalledContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 484, CqlParserRULE_kwCalled)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3083)
		p.Match(CqlParserK_CALLED)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwClusteringContext is an interface to support dynamic dispatch.
type IKwClusteringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_CLUSTERING() antlr.TerminalNode

	// IsKwClusteringContext differentiates from other interfaces.
	IsKwClusteringContext()
}

type KwClusteringContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwClusteringContext() *KwClusteringContext {
	var p = new(KwClusteringContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwClustering
	return p
}

func InitEmptyKwClusteringContext(p *KwClusteringContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwClustering
}

func (*KwClusteringContext) IsKwClusteringContext() {}

func NewKwClusteringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwClusteringContext {
	var p = new(KwClusteringContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwClustering

	return p
}

func (s *KwClusteringContext) GetParser() antlr.Parser { return s.parser }

func (s *KwClusteringContext) K_CLUSTERING() antlr.TerminalNode {
	return s.GetToken(CqlParserK_CLUSTERING, 0)
}

func (s *KwClusteringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwClusteringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwClusteringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwClustering(s)
	}
}

func (s *KwClusteringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwClustering(s)
	}
}

func (p *CqlParser) KwClustering() (localctx IKwClusteringContext) {
	localctx = NewKwClusteringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 486, CqlParserRULE_kwClustering)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3085)
		p.Match(CqlParserK_CLUSTERING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwCompactContext is an interface to support dynamic dispatch.
type IKwCompactContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_COMPACT() antlr.TerminalNode

	// IsKwCompactContext differentiates from other interfaces.
	IsKwCompactContext()
}

type KwCompactContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwCompactContext() *KwCompactContext {
	var p = new(KwCompactContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwCompact
	return p
}

func InitEmptyKwCompactContext(p *KwCompactContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwCompact
}

func (*KwCompactContext) IsKwCompactContext() {}

func NewKwCompactContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwCompactContext {
	var p = new(KwCompactContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwCompact

	return p
}

func (s *KwCompactContext) GetParser() antlr.Parser { return s.parser }

func (s *KwCompactContext) K_COMPACT() antlr.TerminalNode {
	return s.GetToken(CqlParserK_COMPACT, 0)
}

func (s *KwCompactContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwCompactContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwCompactContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwCompact(s)
	}
}

func (s *KwCompactContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwCompact(s)
	}
}

func (p *CqlParser) KwCompact() (localctx IKwCompactContext) {
	localctx = NewKwCompactContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 488, CqlParserRULE_kwCompact)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3087)
		p.Match(CqlParserK_COMPACT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwContainsContext is an interface to support dynamic dispatch.
type IKwContainsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_CONTAINS() antlr.TerminalNode

	// IsKwContainsContext differentiates from other interfaces.
	IsKwContainsContext()
}

type KwContainsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwContainsContext() *KwContainsContext {
	var p = new(KwContainsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwContains
	return p
}

func InitEmptyKwContainsContext(p *KwContainsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwContains
}

func (*KwContainsContext) IsKwContainsContext() {}

func NewKwContainsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwContainsContext {
	var p = new(KwContainsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwContains

	return p
}

func (s *KwContainsContext) GetParser() antlr.Parser { return s.parser }

func (s *KwContainsContext) K_CONTAINS() antlr.TerminalNode {
	return s.GetToken(CqlParserK_CONTAINS, 0)
}

func (s *KwContainsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwContainsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwContainsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwContains(s)
	}
}

func (s *KwContainsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwContains(s)
	}
}

func (p *CqlParser) KwContains() (localctx IKwContainsContext) {
	localctx = NewKwContainsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 490, CqlParserRULE_kwContains)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3089)
		p.Match(CqlParserK_CONTAINS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwCreateContext is an interface to support dynamic dispatch.
type IKwCreateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_CREATE() antlr.TerminalNode

	// IsKwCreateContext differentiates from other interfaces.
	IsKwCreateContext()
}

type KwCreateContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwCreateContext() *KwCreateContext {
	var p = new(KwCreateContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwCreate
	return p
}

func InitEmptyKwCreateContext(p *KwCreateContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwCreate
}

func (*KwCreateContext) IsKwCreateContext() {}

func NewKwCreateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwCreateContext {
	var p = new(KwCreateContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwCreate

	return p
}

func (s *KwCreateContext) GetParser() antlr.Parser { return s.parser }

func (s *KwCreateContext) K_CREATE() antlr.TerminalNode {
	return s.GetToken(CqlParserK_CREATE, 0)
}

func (s *KwCreateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwCreateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwCreateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwCreate(s)
	}
}

func (s *KwCreateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwCreate(s)
	}
}

func (p *CqlParser) KwCreate() (localctx IKwCreateContext) {
	localctx = NewKwCreateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 492, CqlParserRULE_kwCreate)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3091)
		p.Match(CqlParserK_CREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwDeleteContext is an interface to support dynamic dispatch.
type IKwDeleteContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_DELETE() antlr.TerminalNode

	// IsKwDeleteContext differentiates from other interfaces.
	IsKwDeleteContext()
}

type KwDeleteContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwDeleteContext() *KwDeleteContext {
	var p = new(KwDeleteContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwDelete
	return p
}

func InitEmptyKwDeleteContext(p *KwDeleteContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwDelete
}

func (*KwDeleteContext) IsKwDeleteContext() {}

func NewKwDeleteContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwDeleteContext {
	var p = new(KwDeleteContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwDelete

	return p
}

func (s *KwDeleteContext) GetParser() antlr.Parser { return s.parser }

func (s *KwDeleteContext) K_DELETE() antlr.TerminalNode {
	return s.GetToken(CqlParserK_DELETE, 0)
}

func (s *KwDeleteContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwDeleteContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwDeleteContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwDelete(s)
	}
}

func (s *KwDeleteContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwDelete(s)
	}
}

func (p *CqlParser) KwDelete() (localctx IKwDeleteContext) {
	localctx = NewKwDeleteContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 494, CqlParserRULE_kwDelete)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3093)
		p.Match(CqlParserK_DELETE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwDescContext is an interface to support dynamic dispatch.
type IKwDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_DESC() antlr.TerminalNode

	// IsKwDescContext differentiates from other interfaces.
	IsKwDescContext()
}

type KwDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwDescContext() *KwDescContext {
	var p = new(KwDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwDesc
	return p
}

func InitEmptyKwDescContext(p *KwDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwDesc
}

func (*KwDescContext) IsKwDescContext() {}

func NewKwDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwDescContext {
	var p = new(KwDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwDesc

	return p
}

func (s *KwDescContext) GetParser() antlr.Parser { return s.parser }

func (s *KwDescContext) K_DESC() antlr.TerminalNode {
	return s.GetToken(CqlParserK_DESC, 0)
}

func (s *KwDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwDesc(s)
	}
}

func (s *KwDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwDesc(s)
	}
}

func (p *CqlParser) KwDesc() (localctx IKwDescContext) {
	localctx = NewKwDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 496, CqlParserRULE_kwDesc)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3095)
		p.Match(CqlParserK_DESC)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwDescibeContext is an interface to support dynamic dispatch.
type IKwDescibeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_DESCRIBE() antlr.TerminalNode

	// IsKwDescibeContext differentiates from other interfaces.
	IsKwDescibeContext()
}

type KwDescibeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwDescibeContext() *KwDescibeContext {
	var p = new(KwDescibeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwDescibe
	return p
}

func InitEmptyKwDescibeContext(p *KwDescibeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwDescibe
}

func (*KwDescibeContext) IsKwDescibeContext() {}

func NewKwDescibeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwDescibeContext {
	var p = new(KwDescibeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwDescibe

	return p
}

func (s *KwDescibeContext) GetParser() antlr.Parser { return s.parser }

func (s *KwDescibeContext) K_DESCRIBE() antlr.TerminalNode {
	return s.GetToken(CqlParserK_DESCRIBE, 0)
}

func (s *KwDescibeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwDescibeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwDescibeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwDescibe(s)
	}
}

func (s *KwDescibeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwDescibe(s)
	}
}

func (p *CqlParser) KwDescibe() (localctx IKwDescibeContext) {
	localctx = NewKwDescibeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 498, CqlParserRULE_kwDescibe)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3097)
		p.Match(CqlParserK_DESCRIBE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwDistinctContext is an interface to support dynamic dispatch.
type IKwDistinctContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_DISTINCT() antlr.TerminalNode

	// IsKwDistinctContext differentiates from other interfaces.
	IsKwDistinctContext()
}

type KwDistinctContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwDistinctContext() *KwDistinctContext {
	var p = new(KwDistinctContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwDistinct
	return p
}

func InitEmptyKwDistinctContext(p *KwDistinctContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwDistinct
}

func (*KwDistinctContext) IsKwDistinctContext() {}

func NewKwDistinctContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwDistinctContext {
	var p = new(KwDistinctContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwDistinct

	return p
}

func (s *KwDistinctContext) GetParser() antlr.Parser { return s.parser }

func (s *KwDistinctContext) K_DISTINCT() antlr.TerminalNode {
	return s.GetToken(CqlParserK_DISTINCT, 0)
}

func (s *KwDistinctContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwDistinctContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwDistinctContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwDistinct(s)
	}
}

func (s *KwDistinctContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwDistinct(s)
	}
}

func (p *CqlParser) KwDistinct() (localctx IKwDistinctContext) {
	localctx = NewKwDistinctContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 500, CqlParserRULE_kwDistinct)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3099)
		p.Match(CqlParserK_DISTINCT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwDropContext is an interface to support dynamic dispatch.
type IKwDropContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_DROP() antlr.TerminalNode

	// IsKwDropContext differentiates from other interfaces.
	IsKwDropContext()
}

type KwDropContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwDropContext() *KwDropContext {
	var p = new(KwDropContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwDrop
	return p
}

func InitEmptyKwDropContext(p *KwDropContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwDrop
}

func (*KwDropContext) IsKwDropContext() {}

func NewKwDropContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwDropContext {
	var p = new(KwDropContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwDrop

	return p
}

func (s *KwDropContext) GetParser() antlr.Parser { return s.parser }

func (s *KwDropContext) K_DROP() antlr.TerminalNode {
	return s.GetToken(CqlParserK_DROP, 0)
}

func (s *KwDropContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwDropContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwDropContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwDrop(s)
	}
}

func (s *KwDropContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwDrop(s)
	}
}

func (p *CqlParser) KwDrop() (localctx IKwDropContext) {
	localctx = NewKwDropContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 502, CqlParserRULE_kwDrop)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3101)
		p.Match(CqlParserK_DROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwDurableWritesContext is an interface to support dynamic dispatch.
type IKwDurableWritesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_DURABLE_WRITES() antlr.TerminalNode

	// IsKwDurableWritesContext differentiates from other interfaces.
	IsKwDurableWritesContext()
}

type KwDurableWritesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwDurableWritesContext() *KwDurableWritesContext {
	var p = new(KwDurableWritesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwDurableWrites
	return p
}

func InitEmptyKwDurableWritesContext(p *KwDurableWritesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwDurableWrites
}

func (*KwDurableWritesContext) IsKwDurableWritesContext() {}

func NewKwDurableWritesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwDurableWritesContext {
	var p = new(KwDurableWritesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwDurableWrites

	return p
}

func (s *KwDurableWritesContext) GetParser() antlr.Parser { return s.parser }

func (s *KwDurableWritesContext) K_DURABLE_WRITES() antlr.TerminalNode {
	return s.GetToken(CqlParserK_DURABLE_WRITES, 0)
}

func (s *KwDurableWritesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwDurableWritesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwDurableWritesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwDurableWrites(s)
	}
}

func (s *KwDurableWritesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwDurableWrites(s)
	}
}

func (p *CqlParser) KwDurableWrites() (localctx IKwDurableWritesContext) {
	localctx = NewKwDurableWritesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 504, CqlParserRULE_kwDurableWrites)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3103)
		p.Match(CqlParserK_DURABLE_WRITES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwEntriesContext is an interface to support dynamic dispatch.
type IKwEntriesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_ENTRIES() antlr.TerminalNode

	// IsKwEntriesContext differentiates from other interfaces.
	IsKwEntriesContext()
}

type KwEntriesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwEntriesContext() *KwEntriesContext {
	var p = new(KwEntriesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwEntries
	return p
}

func InitEmptyKwEntriesContext(p *KwEntriesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwEntries
}

func (*KwEntriesContext) IsKwEntriesContext() {}

func NewKwEntriesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwEntriesContext {
	var p = new(KwEntriesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwEntries

	return p
}

func (s *KwEntriesContext) GetParser() antlr.Parser { return s.parser }

func (s *KwEntriesContext) K_ENTRIES() antlr.TerminalNode {
	return s.GetToken(CqlParserK_ENTRIES, 0)
}

func (s *KwEntriesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwEntriesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwEntriesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwEntries(s)
	}
}

func (s *KwEntriesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwEntries(s)
	}
}

func (p *CqlParser) KwEntries() (localctx IKwEntriesContext) {
	localctx = NewKwEntriesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 506, CqlParserRULE_kwEntries)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3105)
		p.Match(CqlParserK_ENTRIES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwExecuteContext is an interface to support dynamic dispatch.
type IKwExecuteContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_EXECUTE() antlr.TerminalNode

	// IsKwExecuteContext differentiates from other interfaces.
	IsKwExecuteContext()
}

type KwExecuteContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwExecuteContext() *KwExecuteContext {
	var p = new(KwExecuteContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwExecute
	return p
}

func InitEmptyKwExecuteContext(p *KwExecuteContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwExecute
}

func (*KwExecuteContext) IsKwExecuteContext() {}

func NewKwExecuteContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwExecuteContext {
	var p = new(KwExecuteContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwExecute

	return p
}

func (s *KwExecuteContext) GetParser() antlr.Parser { return s.parser }

func (s *KwExecuteContext) K_EXECUTE() antlr.TerminalNode {
	return s.GetToken(CqlParserK_EXECUTE, 0)
}

func (s *KwExecuteContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwExecuteContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwExecuteContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwExecute(s)
	}
}

func (s *KwExecuteContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwExecute(s)
	}
}

func (p *CqlParser) KwExecute() (localctx IKwExecuteContext) {
	localctx = NewKwExecuteContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 508, CqlParserRULE_kwExecute)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3107)
		p.Match(CqlParserK_EXECUTE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwExistsContext is an interface to support dynamic dispatch.
type IKwExistsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_EXISTS() antlr.TerminalNode

	// IsKwExistsContext differentiates from other interfaces.
	IsKwExistsContext()
}

type KwExistsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwExistsContext() *KwExistsContext {
	var p = new(KwExistsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwExists
	return p
}

func InitEmptyKwExistsContext(p *KwExistsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwExists
}

func (*KwExistsContext) IsKwExistsContext() {}

func NewKwExistsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwExistsContext {
	var p = new(KwExistsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwExists

	return p
}

func (s *KwExistsContext) GetParser() antlr.Parser { return s.parser }

func (s *KwExistsContext) K_EXISTS() antlr.TerminalNode {
	return s.GetToken(CqlParserK_EXISTS, 0)
}

func (s *KwExistsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwExistsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwExistsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwExists(s)
	}
}

func (s *KwExistsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwExists(s)
	}
}

func (p *CqlParser) KwExists() (localctx IKwExistsContext) {
	localctx = NewKwExistsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 510, CqlParserRULE_kwExists)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3109)
		p.Match(CqlParserK_EXISTS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwFilteringContext is an interface to support dynamic dispatch.
type IKwFilteringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_FILTERING() antlr.TerminalNode

	// IsKwFilteringContext differentiates from other interfaces.
	IsKwFilteringContext()
}

type KwFilteringContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwFilteringContext() *KwFilteringContext {
	var p = new(KwFilteringContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwFiltering
	return p
}

func InitEmptyKwFilteringContext(p *KwFilteringContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwFiltering
}

func (*KwFilteringContext) IsKwFilteringContext() {}

func NewKwFilteringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwFilteringContext {
	var p = new(KwFilteringContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwFiltering

	return p
}

func (s *KwFilteringContext) GetParser() antlr.Parser { return s.parser }

func (s *KwFilteringContext) K_FILTERING() antlr.TerminalNode {
	return s.GetToken(CqlParserK_FILTERING, 0)
}

func (s *KwFilteringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwFilteringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwFilteringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwFiltering(s)
	}
}

func (s *KwFilteringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwFiltering(s)
	}
}

func (p *CqlParser) KwFiltering() (localctx IKwFilteringContext) {
	localctx = NewKwFilteringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 512, CqlParserRULE_kwFiltering)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3111)
		p.Match(CqlParserK_FILTERING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwFinalfuncContext is an interface to support dynamic dispatch.
type IKwFinalfuncContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_FINALFUNC() antlr.TerminalNode

	// IsKwFinalfuncContext differentiates from other interfaces.
	IsKwFinalfuncContext()
}

type KwFinalfuncContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwFinalfuncContext() *KwFinalfuncContext {
	var p = new(KwFinalfuncContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwFinalfunc
	return p
}

func InitEmptyKwFinalfuncContext(p *KwFinalfuncContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwFinalfunc
}

func (*KwFinalfuncContext) IsKwFinalfuncContext() {}

func NewKwFinalfuncContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwFinalfuncContext {
	var p = new(KwFinalfuncContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwFinalfunc

	return p
}

func (s *KwFinalfuncContext) GetParser() antlr.Parser { return s.parser }

func (s *KwFinalfuncContext) K_FINALFUNC() antlr.TerminalNode {
	return s.GetToken(CqlParserK_FINALFUNC, 0)
}

func (s *KwFinalfuncContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwFinalfuncContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwFinalfuncContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwFinalfunc(s)
	}
}

func (s *KwFinalfuncContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwFinalfunc(s)
	}
}

func (p *CqlParser) KwFinalfunc() (localctx IKwFinalfuncContext) {
	localctx = NewKwFinalfuncContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 514, CqlParserRULE_kwFinalfunc)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3113)
		p.Match(CqlParserK_FINALFUNC)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwFromContext is an interface to support dynamic dispatch.
type IKwFromContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_FROM() antlr.TerminalNode

	// IsKwFromContext differentiates from other interfaces.
	IsKwFromContext()
}

type KwFromContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwFromContext() *KwFromContext {
	var p = new(KwFromContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwFrom
	return p
}

func InitEmptyKwFromContext(p *KwFromContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwFrom
}

func (*KwFromContext) IsKwFromContext() {}

func NewKwFromContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwFromContext {
	var p = new(KwFromContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwFrom

	return p
}

func (s *KwFromContext) GetParser() antlr.Parser { return s.parser }

func (s *KwFromContext) K_FROM() antlr.TerminalNode {
	return s.GetToken(CqlParserK_FROM, 0)
}

func (s *KwFromContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwFromContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwFromContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwFrom(s)
	}
}

func (s *KwFromContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwFrom(s)
	}
}

func (p *CqlParser) KwFrom() (localctx IKwFromContext) {
	localctx = NewKwFromContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 516, CqlParserRULE_kwFrom)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3115)
		p.Match(CqlParserK_FROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwFullContext is an interface to support dynamic dispatch.
type IKwFullContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_FULL() antlr.TerminalNode

	// IsKwFullContext differentiates from other interfaces.
	IsKwFullContext()
}

type KwFullContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwFullContext() *KwFullContext {
	var p = new(KwFullContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwFull
	return p
}

func InitEmptyKwFullContext(p *KwFullContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwFull
}

func (*KwFullContext) IsKwFullContext() {}

func NewKwFullContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwFullContext {
	var p = new(KwFullContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwFull

	return p
}

func (s *KwFullContext) GetParser() antlr.Parser { return s.parser }

func (s *KwFullContext) K_FULL() antlr.TerminalNode {
	return s.GetToken(CqlParserK_FULL, 0)
}

func (s *KwFullContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwFullContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwFullContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwFull(s)
	}
}

func (s *KwFullContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwFull(s)
	}
}

func (p *CqlParser) KwFull() (localctx IKwFullContext) {
	localctx = NewKwFullContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 518, CqlParserRULE_kwFull)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3117)
		p.Match(CqlParserK_FULL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwFunctionContext is an interface to support dynamic dispatch.
type IKwFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_FUNCTION() antlr.TerminalNode

	// IsKwFunctionContext differentiates from other interfaces.
	IsKwFunctionContext()
}

type KwFunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwFunctionContext() *KwFunctionContext {
	var p = new(KwFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwFunction
	return p
}

func InitEmptyKwFunctionContext(p *KwFunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwFunction
}

func (*KwFunctionContext) IsKwFunctionContext() {}

func NewKwFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwFunctionContext {
	var p = new(KwFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwFunction

	return p
}

func (s *KwFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *KwFunctionContext) K_FUNCTION() antlr.TerminalNode {
	return s.GetToken(CqlParserK_FUNCTION, 0)
}

func (s *KwFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwFunction(s)
	}
}

func (s *KwFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwFunction(s)
	}
}

func (p *CqlParser) KwFunction() (localctx IKwFunctionContext) {
	localctx = NewKwFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 520, CqlParserRULE_kwFunction)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3119)
		p.Match(CqlParserK_FUNCTION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwFunctionsContext is an interface to support dynamic dispatch.
type IKwFunctionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_FUNCTIONS() antlr.TerminalNode

	// IsKwFunctionsContext differentiates from other interfaces.
	IsKwFunctionsContext()
}

type KwFunctionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwFunctionsContext() *KwFunctionsContext {
	var p = new(KwFunctionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwFunctions
	return p
}

func InitEmptyKwFunctionsContext(p *KwFunctionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwFunctions
}

func (*KwFunctionsContext) IsKwFunctionsContext() {}

func NewKwFunctionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwFunctionsContext {
	var p = new(KwFunctionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwFunctions

	return p
}

func (s *KwFunctionsContext) GetParser() antlr.Parser { return s.parser }

func (s *KwFunctionsContext) K_FUNCTIONS() antlr.TerminalNode {
	return s.GetToken(CqlParserK_FUNCTIONS, 0)
}

func (s *KwFunctionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwFunctionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwFunctionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwFunctions(s)
	}
}

func (s *KwFunctionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwFunctions(s)
	}
}

func (p *CqlParser) KwFunctions() (localctx IKwFunctionsContext) {
	localctx = NewKwFunctionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 522, CqlParserRULE_kwFunctions)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3121)
		p.Match(CqlParserK_FUNCTIONS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwGrantContext is an interface to support dynamic dispatch.
type IKwGrantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_GRANT() antlr.TerminalNode

	// IsKwGrantContext differentiates from other interfaces.
	IsKwGrantContext()
}

type KwGrantContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwGrantContext() *KwGrantContext {
	var p = new(KwGrantContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwGrant
	return p
}

func InitEmptyKwGrantContext(p *KwGrantContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwGrant
}

func (*KwGrantContext) IsKwGrantContext() {}

func NewKwGrantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwGrantContext {
	var p = new(KwGrantContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwGrant

	return p
}

func (s *KwGrantContext) GetParser() antlr.Parser { return s.parser }

func (s *KwGrantContext) K_GRANT() antlr.TerminalNode {
	return s.GetToken(CqlParserK_GRANT, 0)
}

func (s *KwGrantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwGrantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwGrantContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwGrant(s)
	}
}

func (s *KwGrantContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwGrant(s)
	}
}

func (p *CqlParser) KwGrant() (localctx IKwGrantContext) {
	localctx = NewKwGrantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 524, CqlParserRULE_kwGrant)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3123)
		p.Match(CqlParserK_GRANT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwIfContext is an interface to support dynamic dispatch.
type IKwIfContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_IF() antlr.TerminalNode

	// IsKwIfContext differentiates from other interfaces.
	IsKwIfContext()
}

type KwIfContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwIfContext() *KwIfContext {
	var p = new(KwIfContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwIf
	return p
}

func InitEmptyKwIfContext(p *KwIfContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwIf
}

func (*KwIfContext) IsKwIfContext() {}

func NewKwIfContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwIfContext {
	var p = new(KwIfContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwIf

	return p
}

func (s *KwIfContext) GetParser() antlr.Parser { return s.parser }

func (s *KwIfContext) K_IF() antlr.TerminalNode {
	return s.GetToken(CqlParserK_IF, 0)
}

func (s *KwIfContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwIfContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwIfContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwIf(s)
	}
}

func (s *KwIfContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwIf(s)
	}
}

func (p *CqlParser) KwIf() (localctx IKwIfContext) {
	localctx = NewKwIfContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 526, CqlParserRULE_kwIf)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3125)
		p.Match(CqlParserK_IF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwInContext is an interface to support dynamic dispatch.
type IKwInContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_IN() antlr.TerminalNode

	// IsKwInContext differentiates from other interfaces.
	IsKwInContext()
}

type KwInContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwInContext() *KwInContext {
	var p = new(KwInContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwIn
	return p
}

func InitEmptyKwInContext(p *KwInContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwIn
}

func (*KwInContext) IsKwInContext() {}

func NewKwInContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwInContext {
	var p = new(KwInContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwIn

	return p
}

func (s *KwInContext) GetParser() antlr.Parser { return s.parser }

func (s *KwInContext) K_IN() antlr.TerminalNode {
	return s.GetToken(CqlParserK_IN, 0)
}

func (s *KwInContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwInContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwInContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwIn(s)
	}
}

func (s *KwInContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwIn(s)
	}
}

func (p *CqlParser) KwIn() (localctx IKwInContext) {
	localctx = NewKwInContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 528, CqlParserRULE_kwIn)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3127)
		p.Match(CqlParserK_IN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwIndexContext is an interface to support dynamic dispatch.
type IKwIndexContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_INDEX() antlr.TerminalNode

	// IsKwIndexContext differentiates from other interfaces.
	IsKwIndexContext()
}

type KwIndexContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwIndexContext() *KwIndexContext {
	var p = new(KwIndexContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwIndex
	return p
}

func InitEmptyKwIndexContext(p *KwIndexContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwIndex
}

func (*KwIndexContext) IsKwIndexContext() {}

func NewKwIndexContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwIndexContext {
	var p = new(KwIndexContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwIndex

	return p
}

func (s *KwIndexContext) GetParser() antlr.Parser { return s.parser }

func (s *KwIndexContext) K_INDEX() antlr.TerminalNode {
	return s.GetToken(CqlParserK_INDEX, 0)
}

func (s *KwIndexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwIndexContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwIndexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwIndex(s)
	}
}

func (s *KwIndexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwIndex(s)
	}
}

func (p *CqlParser) KwIndex() (localctx IKwIndexContext) {
	localctx = NewKwIndexContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 530, CqlParserRULE_kwIndex)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3129)
		p.Match(CqlParserK_INDEX)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwInitcondContext is an interface to support dynamic dispatch.
type IKwInitcondContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_INITCOND() antlr.TerminalNode

	// IsKwInitcondContext differentiates from other interfaces.
	IsKwInitcondContext()
}

type KwInitcondContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwInitcondContext() *KwInitcondContext {
	var p = new(KwInitcondContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwInitcond
	return p
}

func InitEmptyKwInitcondContext(p *KwInitcondContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwInitcond
}

func (*KwInitcondContext) IsKwInitcondContext() {}

func NewKwInitcondContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwInitcondContext {
	var p = new(KwInitcondContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwInitcond

	return p
}

func (s *KwInitcondContext) GetParser() antlr.Parser { return s.parser }

func (s *KwInitcondContext) K_INITCOND() antlr.TerminalNode {
	return s.GetToken(CqlParserK_INITCOND, 0)
}

func (s *KwInitcondContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwInitcondContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwInitcondContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwInitcond(s)
	}
}

func (s *KwInitcondContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwInitcond(s)
	}
}

func (p *CqlParser) KwInitcond() (localctx IKwInitcondContext) {
	localctx = NewKwInitcondContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 532, CqlParserRULE_kwInitcond)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3131)
		p.Match(CqlParserK_INITCOND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwInputContext is an interface to support dynamic dispatch.
type IKwInputContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_INPUT() antlr.TerminalNode

	// IsKwInputContext differentiates from other interfaces.
	IsKwInputContext()
}

type KwInputContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwInputContext() *KwInputContext {
	var p = new(KwInputContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwInput
	return p
}

func InitEmptyKwInputContext(p *KwInputContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwInput
}

func (*KwInputContext) IsKwInputContext() {}

func NewKwInputContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwInputContext {
	var p = new(KwInputContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwInput

	return p
}

func (s *KwInputContext) GetParser() antlr.Parser { return s.parser }

func (s *KwInputContext) K_INPUT() antlr.TerminalNode {
	return s.GetToken(CqlParserK_INPUT, 0)
}

func (s *KwInputContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwInputContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwInputContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwInput(s)
	}
}

func (s *KwInputContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwInput(s)
	}
}

func (p *CqlParser) KwInput() (localctx IKwInputContext) {
	localctx = NewKwInputContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 534, CqlParserRULE_kwInput)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3133)
		p.Match(CqlParserK_INPUT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwInsertContext is an interface to support dynamic dispatch.
type IKwInsertContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_INSERT() antlr.TerminalNode

	// IsKwInsertContext differentiates from other interfaces.
	IsKwInsertContext()
}

type KwInsertContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwInsertContext() *KwInsertContext {
	var p = new(KwInsertContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwInsert
	return p
}

func InitEmptyKwInsertContext(p *KwInsertContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwInsert
}

func (*KwInsertContext) IsKwInsertContext() {}

func NewKwInsertContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwInsertContext {
	var p = new(KwInsertContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwInsert

	return p
}

func (s *KwInsertContext) GetParser() antlr.Parser { return s.parser }

func (s *KwInsertContext) K_INSERT() antlr.TerminalNode {
	return s.GetToken(CqlParserK_INSERT, 0)
}

func (s *KwInsertContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwInsertContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwInsertContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwInsert(s)
	}
}

func (s *KwInsertContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwInsert(s)
	}
}

func (p *CqlParser) KwInsert() (localctx IKwInsertContext) {
	localctx = NewKwInsertContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 536, CqlParserRULE_kwInsert)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3135)
		p.Match(CqlParserK_INSERT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwIntoContext is an interface to support dynamic dispatch.
type IKwIntoContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_INTO() antlr.TerminalNode

	// IsKwIntoContext differentiates from other interfaces.
	IsKwIntoContext()
}

type KwIntoContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwIntoContext() *KwIntoContext {
	var p = new(KwIntoContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwInto
	return p
}

func InitEmptyKwIntoContext(p *KwIntoContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwInto
}

func (*KwIntoContext) IsKwIntoContext() {}

func NewKwIntoContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwIntoContext {
	var p = new(KwIntoContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwInto

	return p
}

func (s *KwIntoContext) GetParser() antlr.Parser { return s.parser }

func (s *KwIntoContext) K_INTO() antlr.TerminalNode {
	return s.GetToken(CqlParserK_INTO, 0)
}

func (s *KwIntoContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwIntoContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwIntoContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwInto(s)
	}
}

func (s *KwIntoContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwInto(s)
	}
}

func (p *CqlParser) KwInto() (localctx IKwIntoContext) {
	localctx = NewKwIntoContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 538, CqlParserRULE_kwInto)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3137)
		p.Match(CqlParserK_INTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwIsContext is an interface to support dynamic dispatch.
type IKwIsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_IS() antlr.TerminalNode

	// IsKwIsContext differentiates from other interfaces.
	IsKwIsContext()
}

type KwIsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwIsContext() *KwIsContext {
	var p = new(KwIsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwIs
	return p
}

func InitEmptyKwIsContext(p *KwIsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwIs
}

func (*KwIsContext) IsKwIsContext() {}

func NewKwIsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwIsContext {
	var p = new(KwIsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwIs

	return p
}

func (s *KwIsContext) GetParser() antlr.Parser { return s.parser }

func (s *KwIsContext) K_IS() antlr.TerminalNode {
	return s.GetToken(CqlParserK_IS, 0)
}

func (s *KwIsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwIsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwIsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwIs(s)
	}
}

func (s *KwIsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwIs(s)
	}
}

func (p *CqlParser) KwIs() (localctx IKwIsContext) {
	localctx = NewKwIsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 540, CqlParserRULE_kwIs)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3139)
		p.Match(CqlParserK_IS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwJsonContext is an interface to support dynamic dispatch.
type IKwJsonContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_JSON() antlr.TerminalNode

	// IsKwJsonContext differentiates from other interfaces.
	IsKwJsonContext()
}

type KwJsonContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwJsonContext() *KwJsonContext {
	var p = new(KwJsonContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwJson
	return p
}

func InitEmptyKwJsonContext(p *KwJsonContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwJson
}

func (*KwJsonContext) IsKwJsonContext() {}

func NewKwJsonContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwJsonContext {
	var p = new(KwJsonContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwJson

	return p
}

func (s *KwJsonContext) GetParser() antlr.Parser { return s.parser }

func (s *KwJsonContext) K_JSON() antlr.TerminalNode {
	return s.GetToken(CqlParserK_JSON, 0)
}

func (s *KwJsonContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwJsonContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwJsonContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwJson(s)
	}
}

func (s *KwJsonContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwJson(s)
	}
}

func (p *CqlParser) KwJson() (localctx IKwJsonContext) {
	localctx = NewKwJsonContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 542, CqlParserRULE_kwJson)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3141)
		p.Match(CqlParserK_JSON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwKeyContext is an interface to support dynamic dispatch.
type IKwKeyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_KEY() antlr.TerminalNode

	// IsKwKeyContext differentiates from other interfaces.
	IsKwKeyContext()
}

type KwKeyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwKeyContext() *KwKeyContext {
	var p = new(KwKeyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwKey
	return p
}

func InitEmptyKwKeyContext(p *KwKeyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwKey
}

func (*KwKeyContext) IsKwKeyContext() {}

func NewKwKeyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwKeyContext {
	var p = new(KwKeyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwKey

	return p
}

func (s *KwKeyContext) GetParser() antlr.Parser { return s.parser }

func (s *KwKeyContext) K_KEY() antlr.TerminalNode {
	return s.GetToken(CqlParserK_KEY, 0)
}

func (s *KwKeyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwKeyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwKeyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwKey(s)
	}
}

func (s *KwKeyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwKey(s)
	}
}

func (p *CqlParser) KwKey() (localctx IKwKeyContext) {
	localctx = NewKwKeyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 544, CqlParserRULE_kwKey)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3143)
		p.Match(CqlParserK_KEY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwKeysContext is an interface to support dynamic dispatch.
type IKwKeysContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_KEYS() antlr.TerminalNode

	// IsKwKeysContext differentiates from other interfaces.
	IsKwKeysContext()
}

type KwKeysContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwKeysContext() *KwKeysContext {
	var p = new(KwKeysContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwKeys
	return p
}

func InitEmptyKwKeysContext(p *KwKeysContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwKeys
}

func (*KwKeysContext) IsKwKeysContext() {}

func NewKwKeysContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwKeysContext {
	var p = new(KwKeysContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwKeys

	return p
}

func (s *KwKeysContext) GetParser() antlr.Parser { return s.parser }

func (s *KwKeysContext) K_KEYS() antlr.TerminalNode {
	return s.GetToken(CqlParserK_KEYS, 0)
}

func (s *KwKeysContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwKeysContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwKeysContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwKeys(s)
	}
}

func (s *KwKeysContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwKeys(s)
	}
}

func (p *CqlParser) KwKeys() (localctx IKwKeysContext) {
	localctx = NewKwKeysContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 546, CqlParserRULE_kwKeys)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3145)
		p.Match(CqlParserK_KEYS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwKeyspaceContext is an interface to support dynamic dispatch.
type IKwKeyspaceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_KEYSPACE() antlr.TerminalNode

	// IsKwKeyspaceContext differentiates from other interfaces.
	IsKwKeyspaceContext()
}

type KwKeyspaceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwKeyspaceContext() *KwKeyspaceContext {
	var p = new(KwKeyspaceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwKeyspace
	return p
}

func InitEmptyKwKeyspaceContext(p *KwKeyspaceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwKeyspace
}

func (*KwKeyspaceContext) IsKwKeyspaceContext() {}

func NewKwKeyspaceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwKeyspaceContext {
	var p = new(KwKeyspaceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwKeyspace

	return p
}

func (s *KwKeyspaceContext) GetParser() antlr.Parser { return s.parser }

func (s *KwKeyspaceContext) K_KEYSPACE() antlr.TerminalNode {
	return s.GetToken(CqlParserK_KEYSPACE, 0)
}

func (s *KwKeyspaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwKeyspaceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwKeyspaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwKeyspace(s)
	}
}

func (s *KwKeyspaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwKeyspace(s)
	}
}

func (p *CqlParser) KwKeyspace() (localctx IKwKeyspaceContext) {
	localctx = NewKwKeyspaceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 548, CqlParserRULE_kwKeyspace)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3147)
		p.Match(CqlParserK_KEYSPACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwKeyspacesContext is an interface to support dynamic dispatch.
type IKwKeyspacesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_KEYSPACES() antlr.TerminalNode

	// IsKwKeyspacesContext differentiates from other interfaces.
	IsKwKeyspacesContext()
}

type KwKeyspacesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwKeyspacesContext() *KwKeyspacesContext {
	var p = new(KwKeyspacesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwKeyspaces
	return p
}

func InitEmptyKwKeyspacesContext(p *KwKeyspacesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwKeyspaces
}

func (*KwKeyspacesContext) IsKwKeyspacesContext() {}

func NewKwKeyspacesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwKeyspacesContext {
	var p = new(KwKeyspacesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwKeyspaces

	return p
}

func (s *KwKeyspacesContext) GetParser() antlr.Parser { return s.parser }

func (s *KwKeyspacesContext) K_KEYSPACES() antlr.TerminalNode {
	return s.GetToken(CqlParserK_KEYSPACES, 0)
}

func (s *KwKeyspacesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwKeyspacesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwKeyspacesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwKeyspaces(s)
	}
}

func (s *KwKeyspacesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwKeyspaces(s)
	}
}

func (p *CqlParser) KwKeyspaces() (localctx IKwKeyspacesContext) {
	localctx = NewKwKeyspacesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 550, CqlParserRULE_kwKeyspaces)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3149)
		p.Match(CqlParserK_KEYSPACES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwLanguageContext is an interface to support dynamic dispatch.
type IKwLanguageContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_LANGUAGE() antlr.TerminalNode

	// IsKwLanguageContext differentiates from other interfaces.
	IsKwLanguageContext()
}

type KwLanguageContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwLanguageContext() *KwLanguageContext {
	var p = new(KwLanguageContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwLanguage
	return p
}

func InitEmptyKwLanguageContext(p *KwLanguageContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwLanguage
}

func (*KwLanguageContext) IsKwLanguageContext() {}

func NewKwLanguageContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwLanguageContext {
	var p = new(KwLanguageContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwLanguage

	return p
}

func (s *KwLanguageContext) GetParser() antlr.Parser { return s.parser }

func (s *KwLanguageContext) K_LANGUAGE() antlr.TerminalNode {
	return s.GetToken(CqlParserK_LANGUAGE, 0)
}

func (s *KwLanguageContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwLanguageContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwLanguageContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwLanguage(s)
	}
}

func (s *KwLanguageContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwLanguage(s)
	}
}

func (p *CqlParser) KwLanguage() (localctx IKwLanguageContext) {
	localctx = NewKwLanguageContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 552, CqlParserRULE_kwLanguage)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3151)
		p.Match(CqlParserK_LANGUAGE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwLimitContext is an interface to support dynamic dispatch.
type IKwLimitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_LIMIT() antlr.TerminalNode

	// IsKwLimitContext differentiates from other interfaces.
	IsKwLimitContext()
}

type KwLimitContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwLimitContext() *KwLimitContext {
	var p = new(KwLimitContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwLimit
	return p
}

func InitEmptyKwLimitContext(p *KwLimitContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwLimit
}

func (*KwLimitContext) IsKwLimitContext() {}

func NewKwLimitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwLimitContext {
	var p = new(KwLimitContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwLimit

	return p
}

func (s *KwLimitContext) GetParser() antlr.Parser { return s.parser }

func (s *KwLimitContext) K_LIMIT() antlr.TerminalNode {
	return s.GetToken(CqlParserK_LIMIT, 0)
}

func (s *KwLimitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwLimitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwLimitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwLimit(s)
	}
}

func (s *KwLimitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwLimit(s)
	}
}

func (p *CqlParser) KwLimit() (localctx IKwLimitContext) {
	localctx = NewKwLimitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 554, CqlParserRULE_kwLimit)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3153)
		p.Match(CqlParserK_LIMIT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwListContext is an interface to support dynamic dispatch.
type IKwListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_LIST() antlr.TerminalNode

	// IsKwListContext differentiates from other interfaces.
	IsKwListContext()
}

type KwListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwListContext() *KwListContext {
	var p = new(KwListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwList
	return p
}

func InitEmptyKwListContext(p *KwListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwList
}

func (*KwListContext) IsKwListContext() {}

func NewKwListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwListContext {
	var p = new(KwListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwList

	return p
}

func (s *KwListContext) GetParser() antlr.Parser { return s.parser }

func (s *KwListContext) K_LIST() antlr.TerminalNode {
	return s.GetToken(CqlParserK_LIST, 0)
}

func (s *KwListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwList(s)
	}
}

func (s *KwListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwList(s)
	}
}

func (p *CqlParser) KwList() (localctx IKwListContext) {
	localctx = NewKwListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 556, CqlParserRULE_kwList)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3155)
		p.Match(CqlParserK_LIST)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwLoggedContext is an interface to support dynamic dispatch.
type IKwLoggedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_LOGGED() antlr.TerminalNode

	// IsKwLoggedContext differentiates from other interfaces.
	IsKwLoggedContext()
}

type KwLoggedContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwLoggedContext() *KwLoggedContext {
	var p = new(KwLoggedContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwLogged
	return p
}

func InitEmptyKwLoggedContext(p *KwLoggedContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwLogged
}

func (*KwLoggedContext) IsKwLoggedContext() {}

func NewKwLoggedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwLoggedContext {
	var p = new(KwLoggedContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwLogged

	return p
}

func (s *KwLoggedContext) GetParser() antlr.Parser { return s.parser }

func (s *KwLoggedContext) K_LOGGED() antlr.TerminalNode {
	return s.GetToken(CqlParserK_LOGGED, 0)
}

func (s *KwLoggedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwLoggedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwLoggedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwLogged(s)
	}
}

func (s *KwLoggedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwLogged(s)
	}
}

func (p *CqlParser) KwLogged() (localctx IKwLoggedContext) {
	localctx = NewKwLoggedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 558, CqlParserRULE_kwLogged)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3157)
		p.Match(CqlParserK_LOGGED)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwLoginContext is an interface to support dynamic dispatch.
type IKwLoginContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_LOGIN() antlr.TerminalNode

	// IsKwLoginContext differentiates from other interfaces.
	IsKwLoginContext()
}

type KwLoginContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwLoginContext() *KwLoginContext {
	var p = new(KwLoginContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwLogin
	return p
}

func InitEmptyKwLoginContext(p *KwLoginContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwLogin
}

func (*KwLoginContext) IsKwLoginContext() {}

func NewKwLoginContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwLoginContext {
	var p = new(KwLoginContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwLogin

	return p
}

func (s *KwLoginContext) GetParser() antlr.Parser { return s.parser }

func (s *KwLoginContext) K_LOGIN() antlr.TerminalNode {
	return s.GetToken(CqlParserK_LOGIN, 0)
}

func (s *KwLoginContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwLoginContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwLoginContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwLogin(s)
	}
}

func (s *KwLoginContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwLogin(s)
	}
}

func (p *CqlParser) KwLogin() (localctx IKwLoginContext) {
	localctx = NewKwLoginContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 560, CqlParserRULE_kwLogin)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3159)
		p.Match(CqlParserK_LOGIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwMaterializedContext is an interface to support dynamic dispatch.
type IKwMaterializedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_MATERIALIZED() antlr.TerminalNode

	// IsKwMaterializedContext differentiates from other interfaces.
	IsKwMaterializedContext()
}

type KwMaterializedContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwMaterializedContext() *KwMaterializedContext {
	var p = new(KwMaterializedContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwMaterialized
	return p
}

func InitEmptyKwMaterializedContext(p *KwMaterializedContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwMaterialized
}

func (*KwMaterializedContext) IsKwMaterializedContext() {}

func NewKwMaterializedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwMaterializedContext {
	var p = new(KwMaterializedContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwMaterialized

	return p
}

func (s *KwMaterializedContext) GetParser() antlr.Parser { return s.parser }

func (s *KwMaterializedContext) K_MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(CqlParserK_MATERIALIZED, 0)
}

func (s *KwMaterializedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwMaterializedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwMaterializedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwMaterialized(s)
	}
}

func (s *KwMaterializedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwMaterialized(s)
	}
}

func (p *CqlParser) KwMaterialized() (localctx IKwMaterializedContext) {
	localctx = NewKwMaterializedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 562, CqlParserRULE_kwMaterialized)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3161)
		p.Match(CqlParserK_MATERIALIZED)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwModifyContext is an interface to support dynamic dispatch.
type IKwModifyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_MODIFY() antlr.TerminalNode

	// IsKwModifyContext differentiates from other interfaces.
	IsKwModifyContext()
}

type KwModifyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwModifyContext() *KwModifyContext {
	var p = new(KwModifyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwModify
	return p
}

func InitEmptyKwModifyContext(p *KwModifyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwModify
}

func (*KwModifyContext) IsKwModifyContext() {}

func NewKwModifyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwModifyContext {
	var p = new(KwModifyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwModify

	return p
}

func (s *KwModifyContext) GetParser() antlr.Parser { return s.parser }

func (s *KwModifyContext) K_MODIFY() antlr.TerminalNode {
	return s.GetToken(CqlParserK_MODIFY, 0)
}

func (s *KwModifyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwModifyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwModifyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwModify(s)
	}
}

func (s *KwModifyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwModify(s)
	}
}

func (p *CqlParser) KwModify() (localctx IKwModifyContext) {
	localctx = NewKwModifyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 564, CqlParserRULE_kwModify)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3163)
		p.Match(CqlParserK_MODIFY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwNosuperuserContext is an interface to support dynamic dispatch.
type IKwNosuperuserContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_NOSUPERUSER() antlr.TerminalNode

	// IsKwNosuperuserContext differentiates from other interfaces.
	IsKwNosuperuserContext()
}

type KwNosuperuserContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwNosuperuserContext() *KwNosuperuserContext {
	var p = new(KwNosuperuserContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwNosuperuser
	return p
}

func InitEmptyKwNosuperuserContext(p *KwNosuperuserContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwNosuperuser
}

func (*KwNosuperuserContext) IsKwNosuperuserContext() {}

func NewKwNosuperuserContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwNosuperuserContext {
	var p = new(KwNosuperuserContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwNosuperuser

	return p
}

func (s *KwNosuperuserContext) GetParser() antlr.Parser { return s.parser }

func (s *KwNosuperuserContext) K_NOSUPERUSER() antlr.TerminalNode {
	return s.GetToken(CqlParserK_NOSUPERUSER, 0)
}

func (s *KwNosuperuserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwNosuperuserContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwNosuperuserContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwNosuperuser(s)
	}
}

func (s *KwNosuperuserContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwNosuperuser(s)
	}
}

func (p *CqlParser) KwNosuperuser() (localctx IKwNosuperuserContext) {
	localctx = NewKwNosuperuserContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 566, CqlParserRULE_kwNosuperuser)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3165)
		p.Match(CqlParserK_NOSUPERUSER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwNorecursiveContext is an interface to support dynamic dispatch.
type IKwNorecursiveContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_NORECURSIVE() antlr.TerminalNode

	// IsKwNorecursiveContext differentiates from other interfaces.
	IsKwNorecursiveContext()
}

type KwNorecursiveContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwNorecursiveContext() *KwNorecursiveContext {
	var p = new(KwNorecursiveContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwNorecursive
	return p
}

func InitEmptyKwNorecursiveContext(p *KwNorecursiveContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwNorecursive
}

func (*KwNorecursiveContext) IsKwNorecursiveContext() {}

func NewKwNorecursiveContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwNorecursiveContext {
	var p = new(KwNorecursiveContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwNorecursive

	return p
}

func (s *KwNorecursiveContext) GetParser() antlr.Parser { return s.parser }

func (s *KwNorecursiveContext) K_NORECURSIVE() antlr.TerminalNode {
	return s.GetToken(CqlParserK_NORECURSIVE, 0)
}

func (s *KwNorecursiveContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwNorecursiveContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwNorecursiveContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwNorecursive(s)
	}
}

func (s *KwNorecursiveContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwNorecursive(s)
	}
}

func (p *CqlParser) KwNorecursive() (localctx IKwNorecursiveContext) {
	localctx = NewKwNorecursiveContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 568, CqlParserRULE_kwNorecursive)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3167)
		p.Match(CqlParserK_NORECURSIVE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwNotContext is an interface to support dynamic dispatch.
type IKwNotContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_NOT() antlr.TerminalNode

	// IsKwNotContext differentiates from other interfaces.
	IsKwNotContext()
}

type KwNotContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwNotContext() *KwNotContext {
	var p = new(KwNotContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwNot
	return p
}

func InitEmptyKwNotContext(p *KwNotContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwNot
}

func (*KwNotContext) IsKwNotContext() {}

func NewKwNotContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwNotContext {
	var p = new(KwNotContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwNot

	return p
}

func (s *KwNotContext) GetParser() antlr.Parser { return s.parser }

func (s *KwNotContext) K_NOT() antlr.TerminalNode {
	return s.GetToken(CqlParserK_NOT, 0)
}

func (s *KwNotContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwNotContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwNotContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwNot(s)
	}
}

func (s *KwNotContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwNot(s)
	}
}

func (p *CqlParser) KwNot() (localctx IKwNotContext) {
	localctx = NewKwNotContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 570, CqlParserRULE_kwNot)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3169)
		p.Match(CqlParserK_NOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwNullContext is an interface to support dynamic dispatch.
type IKwNullContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_NULL() antlr.TerminalNode

	// IsKwNullContext differentiates from other interfaces.
	IsKwNullContext()
}

type KwNullContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwNullContext() *KwNullContext {
	var p = new(KwNullContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwNull
	return p
}

func InitEmptyKwNullContext(p *KwNullContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwNull
}

func (*KwNullContext) IsKwNullContext() {}

func NewKwNullContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwNullContext {
	var p = new(KwNullContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwNull

	return p
}

func (s *KwNullContext) GetParser() antlr.Parser { return s.parser }

func (s *KwNullContext) K_NULL() antlr.TerminalNode {
	return s.GetToken(CqlParserK_NULL, 0)
}

func (s *KwNullContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwNullContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwNullContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwNull(s)
	}
}

func (s *KwNullContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwNull(s)
	}
}

func (p *CqlParser) KwNull() (localctx IKwNullContext) {
	localctx = NewKwNullContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 572, CqlParserRULE_kwNull)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3171)
		p.Match(CqlParserK_NULL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwOfContext is an interface to support dynamic dispatch.
type IKwOfContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_OF() antlr.TerminalNode

	// IsKwOfContext differentiates from other interfaces.
	IsKwOfContext()
}

type KwOfContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwOfContext() *KwOfContext {
	var p = new(KwOfContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwOf
	return p
}

func InitEmptyKwOfContext(p *KwOfContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwOf
}

func (*KwOfContext) IsKwOfContext() {}

func NewKwOfContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwOfContext {
	var p = new(KwOfContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwOf

	return p
}

func (s *KwOfContext) GetParser() antlr.Parser { return s.parser }

func (s *KwOfContext) K_OF() antlr.TerminalNode {
	return s.GetToken(CqlParserK_OF, 0)
}

func (s *KwOfContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwOfContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwOfContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwOf(s)
	}
}

func (s *KwOfContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwOf(s)
	}
}

func (p *CqlParser) KwOf() (localctx IKwOfContext) {
	localctx = NewKwOfContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 574, CqlParserRULE_kwOf)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3173)
		p.Match(CqlParserK_OF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwOnContext is an interface to support dynamic dispatch.
type IKwOnContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_ON() antlr.TerminalNode

	// IsKwOnContext differentiates from other interfaces.
	IsKwOnContext()
}

type KwOnContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwOnContext() *KwOnContext {
	var p = new(KwOnContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwOn
	return p
}

func InitEmptyKwOnContext(p *KwOnContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwOn
}

func (*KwOnContext) IsKwOnContext() {}

func NewKwOnContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwOnContext {
	var p = new(KwOnContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwOn

	return p
}

func (s *KwOnContext) GetParser() antlr.Parser { return s.parser }

func (s *KwOnContext) K_ON() antlr.TerminalNode {
	return s.GetToken(CqlParserK_ON, 0)
}

func (s *KwOnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwOnContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwOnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwOn(s)
	}
}

func (s *KwOnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwOn(s)
	}
}

func (p *CqlParser) KwOn() (localctx IKwOnContext) {
	localctx = NewKwOnContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 576, CqlParserRULE_kwOn)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3175)
		p.Match(CqlParserK_ON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwOptionsContext is an interface to support dynamic dispatch.
type IKwOptionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_OPTIONS() antlr.TerminalNode

	// IsKwOptionsContext differentiates from other interfaces.
	IsKwOptionsContext()
}

type KwOptionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwOptionsContext() *KwOptionsContext {
	var p = new(KwOptionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwOptions
	return p
}

func InitEmptyKwOptionsContext(p *KwOptionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwOptions
}

func (*KwOptionsContext) IsKwOptionsContext() {}

func NewKwOptionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwOptionsContext {
	var p = new(KwOptionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwOptions

	return p
}

func (s *KwOptionsContext) GetParser() antlr.Parser { return s.parser }

func (s *KwOptionsContext) K_OPTIONS() antlr.TerminalNode {
	return s.GetToken(CqlParserK_OPTIONS, 0)
}

func (s *KwOptionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwOptionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwOptionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwOptions(s)
	}
}

func (s *KwOptionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwOptions(s)
	}
}

func (p *CqlParser) KwOptions() (localctx IKwOptionsContext) {
	localctx = NewKwOptionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 578, CqlParserRULE_kwOptions)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3177)
		p.Match(CqlParserK_OPTIONS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwOrContext is an interface to support dynamic dispatch.
type IKwOrContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_OR() antlr.TerminalNode

	// IsKwOrContext differentiates from other interfaces.
	IsKwOrContext()
}

type KwOrContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwOrContext() *KwOrContext {
	var p = new(KwOrContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwOr
	return p
}

func InitEmptyKwOrContext(p *KwOrContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwOr
}

func (*KwOrContext) IsKwOrContext() {}

func NewKwOrContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwOrContext {
	var p = new(KwOrContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwOr

	return p
}

func (s *KwOrContext) GetParser() antlr.Parser { return s.parser }

func (s *KwOrContext) K_OR() antlr.TerminalNode {
	return s.GetToken(CqlParserK_OR, 0)
}

func (s *KwOrContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwOrContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwOrContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwOr(s)
	}
}

func (s *KwOrContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwOr(s)
	}
}

func (p *CqlParser) KwOr() (localctx IKwOrContext) {
	localctx = NewKwOrContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 580, CqlParserRULE_kwOr)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3179)
		p.Match(CqlParserK_OR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwOrderContext is an interface to support dynamic dispatch.
type IKwOrderContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_ORDER() antlr.TerminalNode

	// IsKwOrderContext differentiates from other interfaces.
	IsKwOrderContext()
}

type KwOrderContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwOrderContext() *KwOrderContext {
	var p = new(KwOrderContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwOrder
	return p
}

func InitEmptyKwOrderContext(p *KwOrderContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwOrder
}

func (*KwOrderContext) IsKwOrderContext() {}

func NewKwOrderContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwOrderContext {
	var p = new(KwOrderContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwOrder

	return p
}

func (s *KwOrderContext) GetParser() antlr.Parser { return s.parser }

func (s *KwOrderContext) K_ORDER() antlr.TerminalNode {
	return s.GetToken(CqlParserK_ORDER, 0)
}

func (s *KwOrderContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwOrderContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwOrderContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwOrder(s)
	}
}

func (s *KwOrderContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwOrder(s)
	}
}

func (p *CqlParser) KwOrder() (localctx IKwOrderContext) {
	localctx = NewKwOrderContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 582, CqlParserRULE_kwOrder)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3181)
		p.Match(CqlParserK_ORDER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwPasswordContext is an interface to support dynamic dispatch.
type IKwPasswordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_PASSWORD() antlr.TerminalNode

	// IsKwPasswordContext differentiates from other interfaces.
	IsKwPasswordContext()
}

type KwPasswordContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwPasswordContext() *KwPasswordContext {
	var p = new(KwPasswordContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwPassword
	return p
}

func InitEmptyKwPasswordContext(p *KwPasswordContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwPassword
}

func (*KwPasswordContext) IsKwPasswordContext() {}

func NewKwPasswordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwPasswordContext {
	var p = new(KwPasswordContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwPassword

	return p
}

func (s *KwPasswordContext) GetParser() antlr.Parser { return s.parser }

func (s *KwPasswordContext) K_PASSWORD() antlr.TerminalNode {
	return s.GetToken(CqlParserK_PASSWORD, 0)
}

func (s *KwPasswordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwPasswordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwPasswordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwPassword(s)
	}
}

func (s *KwPasswordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwPassword(s)
	}
}

func (p *CqlParser) KwPassword() (localctx IKwPasswordContext) {
	localctx = NewKwPasswordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 584, CqlParserRULE_kwPassword)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3183)
		p.Match(CqlParserK_PASSWORD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwPrimaryContext is an interface to support dynamic dispatch.
type IKwPrimaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_PRIMARY() antlr.TerminalNode

	// IsKwPrimaryContext differentiates from other interfaces.
	IsKwPrimaryContext()
}

type KwPrimaryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwPrimaryContext() *KwPrimaryContext {
	var p = new(KwPrimaryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwPrimary
	return p
}

func InitEmptyKwPrimaryContext(p *KwPrimaryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwPrimary
}

func (*KwPrimaryContext) IsKwPrimaryContext() {}

func NewKwPrimaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwPrimaryContext {
	var p = new(KwPrimaryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwPrimary

	return p
}

func (s *KwPrimaryContext) GetParser() antlr.Parser { return s.parser }

func (s *KwPrimaryContext) K_PRIMARY() antlr.TerminalNode {
	return s.GetToken(CqlParserK_PRIMARY, 0)
}

func (s *KwPrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwPrimaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwPrimaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwPrimary(s)
	}
}

func (s *KwPrimaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwPrimary(s)
	}
}

func (p *CqlParser) KwPrimary() (localctx IKwPrimaryContext) {
	localctx = NewKwPrimaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 586, CqlParserRULE_kwPrimary)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3185)
		p.Match(CqlParserK_PRIMARY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwRenameContext is an interface to support dynamic dispatch.
type IKwRenameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_RENAME() antlr.TerminalNode

	// IsKwRenameContext differentiates from other interfaces.
	IsKwRenameContext()
}

type KwRenameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwRenameContext() *KwRenameContext {
	var p = new(KwRenameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwRename
	return p
}

func InitEmptyKwRenameContext(p *KwRenameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwRename
}

func (*KwRenameContext) IsKwRenameContext() {}

func NewKwRenameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwRenameContext {
	var p = new(KwRenameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwRename

	return p
}

func (s *KwRenameContext) GetParser() antlr.Parser { return s.parser }

func (s *KwRenameContext) K_RENAME() antlr.TerminalNode {
	return s.GetToken(CqlParserK_RENAME, 0)
}

func (s *KwRenameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwRenameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwRenameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwRename(s)
	}
}

func (s *KwRenameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwRename(s)
	}
}

func (p *CqlParser) KwRename() (localctx IKwRenameContext) {
	localctx = NewKwRenameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 588, CqlParserRULE_kwRename)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3187)
		p.Match(CqlParserK_RENAME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwReplaceContext is an interface to support dynamic dispatch.
type IKwReplaceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_REPLACE() antlr.TerminalNode

	// IsKwReplaceContext differentiates from other interfaces.
	IsKwReplaceContext()
}

type KwReplaceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwReplaceContext() *KwReplaceContext {
	var p = new(KwReplaceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwReplace
	return p
}

func InitEmptyKwReplaceContext(p *KwReplaceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwReplace
}

func (*KwReplaceContext) IsKwReplaceContext() {}

func NewKwReplaceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwReplaceContext {
	var p = new(KwReplaceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwReplace

	return p
}

func (s *KwReplaceContext) GetParser() antlr.Parser { return s.parser }

func (s *KwReplaceContext) K_REPLACE() antlr.TerminalNode {
	return s.GetToken(CqlParserK_REPLACE, 0)
}

func (s *KwReplaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwReplaceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwReplaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwReplace(s)
	}
}

func (s *KwReplaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwReplace(s)
	}
}

func (p *CqlParser) KwReplace() (localctx IKwReplaceContext) {
	localctx = NewKwReplaceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 590, CqlParserRULE_kwReplace)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3189)
		p.Match(CqlParserK_REPLACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwReplicationContext is an interface to support dynamic dispatch.
type IKwReplicationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_REPLICATION() antlr.TerminalNode

	// IsKwReplicationContext differentiates from other interfaces.
	IsKwReplicationContext()
}

type KwReplicationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwReplicationContext() *KwReplicationContext {
	var p = new(KwReplicationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwReplication
	return p
}

func InitEmptyKwReplicationContext(p *KwReplicationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwReplication
}

func (*KwReplicationContext) IsKwReplicationContext() {}

func NewKwReplicationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwReplicationContext {
	var p = new(KwReplicationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwReplication

	return p
}

func (s *KwReplicationContext) GetParser() antlr.Parser { return s.parser }

func (s *KwReplicationContext) K_REPLICATION() antlr.TerminalNode {
	return s.GetToken(CqlParserK_REPLICATION, 0)
}

func (s *KwReplicationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwReplicationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwReplicationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwReplication(s)
	}
}

func (s *KwReplicationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwReplication(s)
	}
}

func (p *CqlParser) KwReplication() (localctx IKwReplicationContext) {
	localctx = NewKwReplicationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 592, CqlParserRULE_kwReplication)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3191)
		p.Match(CqlParserK_REPLICATION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwReturnsContext is an interface to support dynamic dispatch.
type IKwReturnsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_RETURNS() antlr.TerminalNode

	// IsKwReturnsContext differentiates from other interfaces.
	IsKwReturnsContext()
}

type KwReturnsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwReturnsContext() *KwReturnsContext {
	var p = new(KwReturnsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwReturns
	return p
}

func InitEmptyKwReturnsContext(p *KwReturnsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwReturns
}

func (*KwReturnsContext) IsKwReturnsContext() {}

func NewKwReturnsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwReturnsContext {
	var p = new(KwReturnsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwReturns

	return p
}

func (s *KwReturnsContext) GetParser() antlr.Parser { return s.parser }

func (s *KwReturnsContext) K_RETURNS() antlr.TerminalNode {
	return s.GetToken(CqlParserK_RETURNS, 0)
}

func (s *KwReturnsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwReturnsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwReturnsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwReturns(s)
	}
}

func (s *KwReturnsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwReturns(s)
	}
}

func (p *CqlParser) KwReturns() (localctx IKwReturnsContext) {
	localctx = NewKwReturnsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 594, CqlParserRULE_kwReturns)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3193)
		p.Match(CqlParserK_RETURNS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwRoleContext is an interface to support dynamic dispatch.
type IKwRoleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_ROLE() antlr.TerminalNode

	// IsKwRoleContext differentiates from other interfaces.
	IsKwRoleContext()
}

type KwRoleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwRoleContext() *KwRoleContext {
	var p = new(KwRoleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwRole
	return p
}

func InitEmptyKwRoleContext(p *KwRoleContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwRole
}

func (*KwRoleContext) IsKwRoleContext() {}

func NewKwRoleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwRoleContext {
	var p = new(KwRoleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwRole

	return p
}

func (s *KwRoleContext) GetParser() antlr.Parser { return s.parser }

func (s *KwRoleContext) K_ROLE() antlr.TerminalNode {
	return s.GetToken(CqlParserK_ROLE, 0)
}

func (s *KwRoleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwRoleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwRoleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwRole(s)
	}
}

func (s *KwRoleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwRole(s)
	}
}

func (p *CqlParser) KwRole() (localctx IKwRoleContext) {
	localctx = NewKwRoleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 596, CqlParserRULE_kwRole)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3195)
		p.Match(CqlParserK_ROLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwRolesContext is an interface to support dynamic dispatch.
type IKwRolesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_ROLES() antlr.TerminalNode

	// IsKwRolesContext differentiates from other interfaces.
	IsKwRolesContext()
}

type KwRolesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwRolesContext() *KwRolesContext {
	var p = new(KwRolesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwRoles
	return p
}

func InitEmptyKwRolesContext(p *KwRolesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwRoles
}

func (*KwRolesContext) IsKwRolesContext() {}

func NewKwRolesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwRolesContext {
	var p = new(KwRolesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwRoles

	return p
}

func (s *KwRolesContext) GetParser() antlr.Parser { return s.parser }

func (s *KwRolesContext) K_ROLES() antlr.TerminalNode {
	return s.GetToken(CqlParserK_ROLES, 0)
}

func (s *KwRolesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwRolesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwRolesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwRoles(s)
	}
}

func (s *KwRolesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwRoles(s)
	}
}

func (p *CqlParser) KwRoles() (localctx IKwRolesContext) {
	localctx = NewKwRolesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 598, CqlParserRULE_kwRoles)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3197)
		p.Match(CqlParserK_ROLES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwSelectContext is an interface to support dynamic dispatch.
type IKwSelectContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_SELECT() antlr.TerminalNode

	// IsKwSelectContext differentiates from other interfaces.
	IsKwSelectContext()
}

type KwSelectContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwSelectContext() *KwSelectContext {
	var p = new(KwSelectContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwSelect
	return p
}

func InitEmptyKwSelectContext(p *KwSelectContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwSelect
}

func (*KwSelectContext) IsKwSelectContext() {}

func NewKwSelectContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwSelectContext {
	var p = new(KwSelectContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwSelect

	return p
}

func (s *KwSelectContext) GetParser() antlr.Parser { return s.parser }

func (s *KwSelectContext) K_SELECT() antlr.TerminalNode {
	return s.GetToken(CqlParserK_SELECT, 0)
}

func (s *KwSelectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwSelectContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwSelectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwSelect(s)
	}
}

func (s *KwSelectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwSelect(s)
	}
}

func (p *CqlParser) KwSelect() (localctx IKwSelectContext) {
	localctx = NewKwSelectContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 600, CqlParserRULE_kwSelect)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3199)
		p.Match(CqlParserK_SELECT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwSetContext is an interface to support dynamic dispatch.
type IKwSetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_SET() antlr.TerminalNode

	// IsKwSetContext differentiates from other interfaces.
	IsKwSetContext()
}

type KwSetContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwSetContext() *KwSetContext {
	var p = new(KwSetContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwSet
	return p
}

func InitEmptyKwSetContext(p *KwSetContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwSet
}

func (*KwSetContext) IsKwSetContext() {}

func NewKwSetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwSetContext {
	var p = new(KwSetContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwSet

	return p
}

func (s *KwSetContext) GetParser() antlr.Parser { return s.parser }

func (s *KwSetContext) K_SET() antlr.TerminalNode {
	return s.GetToken(CqlParserK_SET, 0)
}

func (s *KwSetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwSetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwSetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwSet(s)
	}
}

func (s *KwSetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwSet(s)
	}
}

func (p *CqlParser) KwSet() (localctx IKwSetContext) {
	localctx = NewKwSetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 602, CqlParserRULE_kwSet)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3201)
		p.Match(CqlParserK_SET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwSfuncContext is an interface to support dynamic dispatch.
type IKwSfuncContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_SFUNC() antlr.TerminalNode

	// IsKwSfuncContext differentiates from other interfaces.
	IsKwSfuncContext()
}

type KwSfuncContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwSfuncContext() *KwSfuncContext {
	var p = new(KwSfuncContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwSfunc
	return p
}

func InitEmptyKwSfuncContext(p *KwSfuncContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwSfunc
}

func (*KwSfuncContext) IsKwSfuncContext() {}

func NewKwSfuncContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwSfuncContext {
	var p = new(KwSfuncContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwSfunc

	return p
}

func (s *KwSfuncContext) GetParser() antlr.Parser { return s.parser }

func (s *KwSfuncContext) K_SFUNC() antlr.TerminalNode {
	return s.GetToken(CqlParserK_SFUNC, 0)
}

func (s *KwSfuncContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwSfuncContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwSfuncContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwSfunc(s)
	}
}

func (s *KwSfuncContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwSfunc(s)
	}
}

func (p *CqlParser) KwSfunc() (localctx IKwSfuncContext) {
	localctx = NewKwSfuncContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 604, CqlParserRULE_kwSfunc)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3203)
		p.Match(CqlParserK_SFUNC)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwStorageContext is an interface to support dynamic dispatch.
type IKwStorageContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_STORAGE() antlr.TerminalNode

	// IsKwStorageContext differentiates from other interfaces.
	IsKwStorageContext()
}

type KwStorageContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwStorageContext() *KwStorageContext {
	var p = new(KwStorageContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwStorage
	return p
}

func InitEmptyKwStorageContext(p *KwStorageContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwStorage
}

func (*KwStorageContext) IsKwStorageContext() {}

func NewKwStorageContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwStorageContext {
	var p = new(KwStorageContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwStorage

	return p
}

func (s *KwStorageContext) GetParser() antlr.Parser { return s.parser }

func (s *KwStorageContext) K_STORAGE() antlr.TerminalNode {
	return s.GetToken(CqlParserK_STORAGE, 0)
}

func (s *KwStorageContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwStorageContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwStorageContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwStorage(s)
	}
}

func (s *KwStorageContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwStorage(s)
	}
}

func (p *CqlParser) KwStorage() (localctx IKwStorageContext) {
	localctx = NewKwStorageContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 606, CqlParserRULE_kwStorage)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3205)
		p.Match(CqlParserK_STORAGE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwStypeContext is an interface to support dynamic dispatch.
type IKwStypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_STYPE() antlr.TerminalNode

	// IsKwStypeContext differentiates from other interfaces.
	IsKwStypeContext()
}

type KwStypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwStypeContext() *KwStypeContext {
	var p = new(KwStypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwStype
	return p
}

func InitEmptyKwStypeContext(p *KwStypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwStype
}

func (*KwStypeContext) IsKwStypeContext() {}

func NewKwStypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwStypeContext {
	var p = new(KwStypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwStype

	return p
}

func (s *KwStypeContext) GetParser() antlr.Parser { return s.parser }

func (s *KwStypeContext) K_STYPE() antlr.TerminalNode {
	return s.GetToken(CqlParserK_STYPE, 0)
}

func (s *KwStypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwStypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwStypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwStype(s)
	}
}

func (s *KwStypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwStype(s)
	}
}

func (p *CqlParser) KwStype() (localctx IKwStypeContext) {
	localctx = NewKwStypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 608, CqlParserRULE_kwStype)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3207)
		p.Match(CqlParserK_STYPE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwSuperuserContext is an interface to support dynamic dispatch.
type IKwSuperuserContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_SUPERUSER() antlr.TerminalNode

	// IsKwSuperuserContext differentiates from other interfaces.
	IsKwSuperuserContext()
}

type KwSuperuserContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwSuperuserContext() *KwSuperuserContext {
	var p = new(KwSuperuserContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwSuperuser
	return p
}

func InitEmptyKwSuperuserContext(p *KwSuperuserContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwSuperuser
}

func (*KwSuperuserContext) IsKwSuperuserContext() {}

func NewKwSuperuserContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwSuperuserContext {
	var p = new(KwSuperuserContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwSuperuser

	return p
}

func (s *KwSuperuserContext) GetParser() antlr.Parser { return s.parser }

func (s *KwSuperuserContext) K_SUPERUSER() antlr.TerminalNode {
	return s.GetToken(CqlParserK_SUPERUSER, 0)
}

func (s *KwSuperuserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwSuperuserContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwSuperuserContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwSuperuser(s)
	}
}

func (s *KwSuperuserContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwSuperuser(s)
	}
}

func (p *CqlParser) KwSuperuser() (localctx IKwSuperuserContext) {
	localctx = NewKwSuperuserContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 610, CqlParserRULE_kwSuperuser)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3209)
		p.Match(CqlParserK_SUPERUSER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwTableContext is an interface to support dynamic dispatch.
type IKwTableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_TABLE() antlr.TerminalNode

	// IsKwTableContext differentiates from other interfaces.
	IsKwTableContext()
}

type KwTableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwTableContext() *KwTableContext {
	var p = new(KwTableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwTable
	return p
}

func InitEmptyKwTableContext(p *KwTableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwTable
}

func (*KwTableContext) IsKwTableContext() {}

func NewKwTableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwTableContext {
	var p = new(KwTableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwTable

	return p
}

func (s *KwTableContext) GetParser() antlr.Parser { return s.parser }

func (s *KwTableContext) K_TABLE() antlr.TerminalNode {
	return s.GetToken(CqlParserK_TABLE, 0)
}

func (s *KwTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwTableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwTable(s)
	}
}

func (s *KwTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwTable(s)
	}
}

func (p *CqlParser) KwTable() (localctx IKwTableContext) {
	localctx = NewKwTableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 612, CqlParserRULE_kwTable)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3211)
		p.Match(CqlParserK_TABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwTimestampContext is an interface to support dynamic dispatch.
type IKwTimestampContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_TIMESTAMP() antlr.TerminalNode

	// IsKwTimestampContext differentiates from other interfaces.
	IsKwTimestampContext()
}

type KwTimestampContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwTimestampContext() *KwTimestampContext {
	var p = new(KwTimestampContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwTimestamp
	return p
}

func InitEmptyKwTimestampContext(p *KwTimestampContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwTimestamp
}

func (*KwTimestampContext) IsKwTimestampContext() {}

func NewKwTimestampContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwTimestampContext {
	var p = new(KwTimestampContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwTimestamp

	return p
}

func (s *KwTimestampContext) GetParser() antlr.Parser { return s.parser }

func (s *KwTimestampContext) K_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(CqlParserK_TIMESTAMP, 0)
}

func (s *KwTimestampContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwTimestampContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwTimestampContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwTimestamp(s)
	}
}

func (s *KwTimestampContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwTimestamp(s)
	}
}

func (p *CqlParser) KwTimestamp() (localctx IKwTimestampContext) {
	localctx = NewKwTimestampContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 614, CqlParserRULE_kwTimestamp)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3213)
		p.Match(CqlParserK_TIMESTAMP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwToContext is an interface to support dynamic dispatch.
type IKwToContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_TO() antlr.TerminalNode

	// IsKwToContext differentiates from other interfaces.
	IsKwToContext()
}

type KwToContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwToContext() *KwToContext {
	var p = new(KwToContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwTo
	return p
}

func InitEmptyKwToContext(p *KwToContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwTo
}

func (*KwToContext) IsKwToContext() {}

func NewKwToContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwToContext {
	var p = new(KwToContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwTo

	return p
}

func (s *KwToContext) GetParser() antlr.Parser { return s.parser }

func (s *KwToContext) K_TO() antlr.TerminalNode {
	return s.GetToken(CqlParserK_TO, 0)
}

func (s *KwToContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwToContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwToContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwTo(s)
	}
}

func (s *KwToContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwTo(s)
	}
}

func (p *CqlParser) KwTo() (localctx IKwToContext) {
	localctx = NewKwToContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 616, CqlParserRULE_kwTo)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3215)
		p.Match(CqlParserK_TO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwTriggerContext is an interface to support dynamic dispatch.
type IKwTriggerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_TRIGGER() antlr.TerminalNode

	// IsKwTriggerContext differentiates from other interfaces.
	IsKwTriggerContext()
}

type KwTriggerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwTriggerContext() *KwTriggerContext {
	var p = new(KwTriggerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwTrigger
	return p
}

func InitEmptyKwTriggerContext(p *KwTriggerContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwTrigger
}

func (*KwTriggerContext) IsKwTriggerContext() {}

func NewKwTriggerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwTriggerContext {
	var p = new(KwTriggerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwTrigger

	return p
}

func (s *KwTriggerContext) GetParser() antlr.Parser { return s.parser }

func (s *KwTriggerContext) K_TRIGGER() antlr.TerminalNode {
	return s.GetToken(CqlParserK_TRIGGER, 0)
}

func (s *KwTriggerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwTriggerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwTriggerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwTrigger(s)
	}
}

func (s *KwTriggerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwTrigger(s)
	}
}

func (p *CqlParser) KwTrigger() (localctx IKwTriggerContext) {
	localctx = NewKwTriggerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 618, CqlParserRULE_kwTrigger)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3217)
		p.Match(CqlParserK_TRIGGER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwTruncateContext is an interface to support dynamic dispatch.
type IKwTruncateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_TRUNCATE() antlr.TerminalNode

	// IsKwTruncateContext differentiates from other interfaces.
	IsKwTruncateContext()
}

type KwTruncateContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwTruncateContext() *KwTruncateContext {
	var p = new(KwTruncateContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwTruncate
	return p
}

func InitEmptyKwTruncateContext(p *KwTruncateContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwTruncate
}

func (*KwTruncateContext) IsKwTruncateContext() {}

func NewKwTruncateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwTruncateContext {
	var p = new(KwTruncateContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwTruncate

	return p
}

func (s *KwTruncateContext) GetParser() antlr.Parser { return s.parser }

func (s *KwTruncateContext) K_TRUNCATE() antlr.TerminalNode {
	return s.GetToken(CqlParserK_TRUNCATE, 0)
}

func (s *KwTruncateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwTruncateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwTruncateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwTruncate(s)
	}
}

func (s *KwTruncateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwTruncate(s)
	}
}

func (p *CqlParser) KwTruncate() (localctx IKwTruncateContext) {
	localctx = NewKwTruncateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 620, CqlParserRULE_kwTruncate)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3219)
		p.Match(CqlParserK_TRUNCATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwTtlContext is an interface to support dynamic dispatch.
type IKwTtlContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_TTL() antlr.TerminalNode

	// IsKwTtlContext differentiates from other interfaces.
	IsKwTtlContext()
}

type KwTtlContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwTtlContext() *KwTtlContext {
	var p = new(KwTtlContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwTtl
	return p
}

func InitEmptyKwTtlContext(p *KwTtlContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwTtl
}

func (*KwTtlContext) IsKwTtlContext() {}

func NewKwTtlContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwTtlContext {
	var p = new(KwTtlContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwTtl

	return p
}

func (s *KwTtlContext) GetParser() antlr.Parser { return s.parser }

func (s *KwTtlContext) K_TTL() antlr.TerminalNode {
	return s.GetToken(CqlParserK_TTL, 0)
}

func (s *KwTtlContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwTtlContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwTtlContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwTtl(s)
	}
}

func (s *KwTtlContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwTtl(s)
	}
}

func (p *CqlParser) KwTtl() (localctx IKwTtlContext) {
	localctx = NewKwTtlContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 622, CqlParserRULE_kwTtl)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3221)
		p.Match(CqlParserK_TTL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwTypeContext is an interface to support dynamic dispatch.
type IKwTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_TYPE() antlr.TerminalNode

	// IsKwTypeContext differentiates from other interfaces.
	IsKwTypeContext()
}

type KwTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwTypeContext() *KwTypeContext {
	var p = new(KwTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwType
	return p
}

func InitEmptyKwTypeContext(p *KwTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwType
}

func (*KwTypeContext) IsKwTypeContext() {}

func NewKwTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwTypeContext {
	var p = new(KwTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwType

	return p
}

func (s *KwTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *KwTypeContext) K_TYPE() antlr.TerminalNode {
	return s.GetToken(CqlParserK_TYPE, 0)
}

func (s *KwTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwType(s)
	}
}

func (s *KwTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwType(s)
	}
}

func (p *CqlParser) KwType() (localctx IKwTypeContext) {
	localctx = NewKwTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 624, CqlParserRULE_kwType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3223)
		p.Match(CqlParserK_TYPE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwUnloggedContext is an interface to support dynamic dispatch.
type IKwUnloggedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_UNLOGGED() antlr.TerminalNode

	// IsKwUnloggedContext differentiates from other interfaces.
	IsKwUnloggedContext()
}

type KwUnloggedContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwUnloggedContext() *KwUnloggedContext {
	var p = new(KwUnloggedContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwUnlogged
	return p
}

func InitEmptyKwUnloggedContext(p *KwUnloggedContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwUnlogged
}

func (*KwUnloggedContext) IsKwUnloggedContext() {}

func NewKwUnloggedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwUnloggedContext {
	var p = new(KwUnloggedContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwUnlogged

	return p
}

func (s *KwUnloggedContext) GetParser() antlr.Parser { return s.parser }

func (s *KwUnloggedContext) K_UNLOGGED() antlr.TerminalNode {
	return s.GetToken(CqlParserK_UNLOGGED, 0)
}

func (s *KwUnloggedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwUnloggedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwUnloggedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwUnlogged(s)
	}
}

func (s *KwUnloggedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwUnlogged(s)
	}
}

func (p *CqlParser) KwUnlogged() (localctx IKwUnloggedContext) {
	localctx = NewKwUnloggedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 626, CqlParserRULE_kwUnlogged)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3225)
		p.Match(CqlParserK_UNLOGGED)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwUpdateContext is an interface to support dynamic dispatch.
type IKwUpdateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_UPDATE() antlr.TerminalNode

	// IsKwUpdateContext differentiates from other interfaces.
	IsKwUpdateContext()
}

type KwUpdateContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwUpdateContext() *KwUpdateContext {
	var p = new(KwUpdateContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwUpdate
	return p
}

func InitEmptyKwUpdateContext(p *KwUpdateContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwUpdate
}

func (*KwUpdateContext) IsKwUpdateContext() {}

func NewKwUpdateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwUpdateContext {
	var p = new(KwUpdateContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwUpdate

	return p
}

func (s *KwUpdateContext) GetParser() antlr.Parser { return s.parser }

func (s *KwUpdateContext) K_UPDATE() antlr.TerminalNode {
	return s.GetToken(CqlParserK_UPDATE, 0)
}

func (s *KwUpdateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwUpdateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwUpdateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwUpdate(s)
	}
}

func (s *KwUpdateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwUpdate(s)
	}
}

func (p *CqlParser) KwUpdate() (localctx IKwUpdateContext) {
	localctx = NewKwUpdateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 628, CqlParserRULE_kwUpdate)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3227)
		p.Match(CqlParserK_UPDATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwUseContext is an interface to support dynamic dispatch.
type IKwUseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_USE() antlr.TerminalNode

	// IsKwUseContext differentiates from other interfaces.
	IsKwUseContext()
}

type KwUseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwUseContext() *KwUseContext {
	var p = new(KwUseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwUse
	return p
}

func InitEmptyKwUseContext(p *KwUseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwUse
}

func (*KwUseContext) IsKwUseContext() {}

func NewKwUseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwUseContext {
	var p = new(KwUseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwUse

	return p
}

func (s *KwUseContext) GetParser() antlr.Parser { return s.parser }

func (s *KwUseContext) K_USE() antlr.TerminalNode {
	return s.GetToken(CqlParserK_USE, 0)
}

func (s *KwUseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwUseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwUseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwUse(s)
	}
}

func (s *KwUseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwUse(s)
	}
}

func (p *CqlParser) KwUse() (localctx IKwUseContext) {
	localctx = NewKwUseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 630, CqlParserRULE_kwUse)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3229)
		p.Match(CqlParserK_USE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwUserContext is an interface to support dynamic dispatch.
type IKwUserContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_USER() antlr.TerminalNode

	// IsKwUserContext differentiates from other interfaces.
	IsKwUserContext()
}

type KwUserContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwUserContext() *KwUserContext {
	var p = new(KwUserContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwUser
	return p
}

func InitEmptyKwUserContext(p *KwUserContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwUser
}

func (*KwUserContext) IsKwUserContext() {}

func NewKwUserContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwUserContext {
	var p = new(KwUserContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwUser

	return p
}

func (s *KwUserContext) GetParser() antlr.Parser { return s.parser }

func (s *KwUserContext) K_USER() antlr.TerminalNode {
	return s.GetToken(CqlParserK_USER, 0)
}

func (s *KwUserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwUserContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwUserContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwUser(s)
	}
}

func (s *KwUserContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwUser(s)
	}
}

func (p *CqlParser) KwUser() (localctx IKwUserContext) {
	localctx = NewKwUserContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 632, CqlParserRULE_kwUser)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3231)
		p.Match(CqlParserK_USER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwUsingContext is an interface to support dynamic dispatch.
type IKwUsingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_USING() antlr.TerminalNode

	// IsKwUsingContext differentiates from other interfaces.
	IsKwUsingContext()
}

type KwUsingContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwUsingContext() *KwUsingContext {
	var p = new(KwUsingContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwUsing
	return p
}

func InitEmptyKwUsingContext(p *KwUsingContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwUsing
}

func (*KwUsingContext) IsKwUsingContext() {}

func NewKwUsingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwUsingContext {
	var p = new(KwUsingContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwUsing

	return p
}

func (s *KwUsingContext) GetParser() antlr.Parser { return s.parser }

func (s *KwUsingContext) K_USING() antlr.TerminalNode {
	return s.GetToken(CqlParserK_USING, 0)
}

func (s *KwUsingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwUsingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwUsingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwUsing(s)
	}
}

func (s *KwUsingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwUsing(s)
	}
}

func (p *CqlParser) KwUsing() (localctx IKwUsingContext) {
	localctx = NewKwUsingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 634, CqlParserRULE_kwUsing)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3233)
		p.Match(CqlParserK_USING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwValuesContext is an interface to support dynamic dispatch.
type IKwValuesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_VALUES() antlr.TerminalNode

	// IsKwValuesContext differentiates from other interfaces.
	IsKwValuesContext()
}

type KwValuesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwValuesContext() *KwValuesContext {
	var p = new(KwValuesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwValues
	return p
}

func InitEmptyKwValuesContext(p *KwValuesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwValues
}

func (*KwValuesContext) IsKwValuesContext() {}

func NewKwValuesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwValuesContext {
	var p = new(KwValuesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwValues

	return p
}

func (s *KwValuesContext) GetParser() antlr.Parser { return s.parser }

func (s *KwValuesContext) K_VALUES() antlr.TerminalNode {
	return s.GetToken(CqlParserK_VALUES, 0)
}

func (s *KwValuesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwValuesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwValuesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwValues(s)
	}
}

func (s *KwValuesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwValues(s)
	}
}

func (p *CqlParser) KwValues() (localctx IKwValuesContext) {
	localctx = NewKwValuesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 636, CqlParserRULE_kwValues)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3235)
		p.Match(CqlParserK_VALUES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwViewContext is an interface to support dynamic dispatch.
type IKwViewContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_VIEW() antlr.TerminalNode

	// IsKwViewContext differentiates from other interfaces.
	IsKwViewContext()
}

type KwViewContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwViewContext() *KwViewContext {
	var p = new(KwViewContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwView
	return p
}

func InitEmptyKwViewContext(p *KwViewContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwView
}

func (*KwViewContext) IsKwViewContext() {}

func NewKwViewContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwViewContext {
	var p = new(KwViewContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwView

	return p
}

func (s *KwViewContext) GetParser() antlr.Parser { return s.parser }

func (s *KwViewContext) K_VIEW() antlr.TerminalNode {
	return s.GetToken(CqlParserK_VIEW, 0)
}

func (s *KwViewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwViewContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwViewContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwView(s)
	}
}

func (s *KwViewContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwView(s)
	}
}

func (p *CqlParser) KwView() (localctx IKwViewContext) {
	localctx = NewKwViewContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 638, CqlParserRULE_kwView)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3237)
		p.Match(CqlParserK_VIEW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwWhereContext is an interface to support dynamic dispatch.
type IKwWhereContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_WHERE() antlr.TerminalNode

	// IsKwWhereContext differentiates from other interfaces.
	IsKwWhereContext()
}

type KwWhereContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwWhereContext() *KwWhereContext {
	var p = new(KwWhereContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwWhere
	return p
}

func InitEmptyKwWhereContext(p *KwWhereContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwWhere
}

func (*KwWhereContext) IsKwWhereContext() {}

func NewKwWhereContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwWhereContext {
	var p = new(KwWhereContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwWhere

	return p
}

func (s *KwWhereContext) GetParser() antlr.Parser { return s.parser }

func (s *KwWhereContext) K_WHERE() antlr.TerminalNode {
	return s.GetToken(CqlParserK_WHERE, 0)
}

func (s *KwWhereContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwWhereContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwWhereContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwWhere(s)
	}
}

func (s *KwWhereContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwWhere(s)
	}
}

func (p *CqlParser) KwWhere() (localctx IKwWhereContext) {
	localctx = NewKwWhereContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 640, CqlParserRULE_kwWhere)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3239)
		p.Match(CqlParserK_WHERE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwWithContext is an interface to support dynamic dispatch.
type IKwWithContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_WITH() antlr.TerminalNode

	// IsKwWithContext differentiates from other interfaces.
	IsKwWithContext()
}

type KwWithContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwWithContext() *KwWithContext {
	var p = new(KwWithContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwWith
	return p
}

func InitEmptyKwWithContext(p *KwWithContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwWith
}

func (*KwWithContext) IsKwWithContext() {}

func NewKwWithContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwWithContext {
	var p = new(KwWithContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwWith

	return p
}

func (s *KwWithContext) GetParser() antlr.Parser { return s.parser }

func (s *KwWithContext) K_WITH() antlr.TerminalNode {
	return s.GetToken(CqlParserK_WITH, 0)
}

func (s *KwWithContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwWithContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwWithContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwWith(s)
	}
}

func (s *KwWithContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwWith(s)
	}
}

func (p *CqlParser) KwWith() (localctx IKwWithContext) {
	localctx = NewKwWithContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 642, CqlParserRULE_kwWith)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3241)
		p.Match(CqlParserK_WITH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwRevokeContext is an interface to support dynamic dispatch.
type IKwRevokeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_REVOKE() antlr.TerminalNode

	// IsKwRevokeContext differentiates from other interfaces.
	IsKwRevokeContext()
}

type KwRevokeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwRevokeContext() *KwRevokeContext {
	var p = new(KwRevokeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwRevoke
	return p
}

func InitEmptyKwRevokeContext(p *KwRevokeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwRevoke
}

func (*KwRevokeContext) IsKwRevokeContext() {}

func NewKwRevokeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwRevokeContext {
	var p = new(KwRevokeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwRevoke

	return p
}

func (s *KwRevokeContext) GetParser() antlr.Parser { return s.parser }

func (s *KwRevokeContext) K_REVOKE() antlr.TerminalNode {
	return s.GetToken(CqlParserK_REVOKE, 0)
}

func (s *KwRevokeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwRevokeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwRevokeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwRevoke(s)
	}
}

func (s *KwRevokeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwRevoke(s)
	}
}

func (p *CqlParser) KwRevoke() (localctx IKwRevokeContext) {
	localctx = NewKwRevokeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 644, CqlParserRULE_kwRevoke)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3243)
		p.Match(CqlParserK_REVOKE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISyntaxBracketLrContext is an interface to support dynamic dispatch.
type ISyntaxBracketLrContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LR_BRACKET() antlr.TerminalNode

	// IsSyntaxBracketLrContext differentiates from other interfaces.
	IsSyntaxBracketLrContext()
}

type SyntaxBracketLrContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySyntaxBracketLrContext() *SyntaxBracketLrContext {
	var p = new(SyntaxBracketLrContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_syntaxBracketLr
	return p
}

func InitEmptySyntaxBracketLrContext(p *SyntaxBracketLrContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_syntaxBracketLr
}

func (*SyntaxBracketLrContext) IsSyntaxBracketLrContext() {}

func NewSyntaxBracketLrContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SyntaxBracketLrContext {
	var p = new(SyntaxBracketLrContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_syntaxBracketLr

	return p
}

func (s *SyntaxBracketLrContext) GetParser() antlr.Parser { return s.parser }

func (s *SyntaxBracketLrContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(CqlParserLR_BRACKET, 0)
}

func (s *SyntaxBracketLrContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SyntaxBracketLrContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SyntaxBracketLrContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterSyntaxBracketLr(s)
	}
}

func (s *SyntaxBracketLrContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitSyntaxBracketLr(s)
	}
}

func (p *CqlParser) SyntaxBracketLr() (localctx ISyntaxBracketLrContext) {
	localctx = NewSyntaxBracketLrContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 646, CqlParserRULE_syntaxBracketLr)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3245)
		p.Match(CqlParserLR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISyntaxBracketRrContext is an interface to support dynamic dispatch.
type ISyntaxBracketRrContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RR_BRACKET() antlr.TerminalNode

	// IsSyntaxBracketRrContext differentiates from other interfaces.
	IsSyntaxBracketRrContext()
}

type SyntaxBracketRrContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySyntaxBracketRrContext() *SyntaxBracketRrContext {
	var p = new(SyntaxBracketRrContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_syntaxBracketRr
	return p
}

func InitEmptySyntaxBracketRrContext(p *SyntaxBracketRrContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_syntaxBracketRr
}

func (*SyntaxBracketRrContext) IsSyntaxBracketRrContext() {}

func NewSyntaxBracketRrContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SyntaxBracketRrContext {
	var p = new(SyntaxBracketRrContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_syntaxBracketRr

	return p
}

func (s *SyntaxBracketRrContext) GetParser() antlr.Parser { return s.parser }

func (s *SyntaxBracketRrContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(CqlParserRR_BRACKET, 0)
}

func (s *SyntaxBracketRrContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SyntaxBracketRrContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SyntaxBracketRrContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterSyntaxBracketRr(s)
	}
}

func (s *SyntaxBracketRrContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitSyntaxBracketRr(s)
	}
}

func (p *CqlParser) SyntaxBracketRr() (localctx ISyntaxBracketRrContext) {
	localctx = NewSyntaxBracketRrContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 648, CqlParserRULE_syntaxBracketRr)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3247)
		p.Match(CqlParserRR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISyntaxBracketLcContext is an interface to support dynamic dispatch.
type ISyntaxBracketLcContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LC_BRACKET() antlr.TerminalNode

	// IsSyntaxBracketLcContext differentiates from other interfaces.
	IsSyntaxBracketLcContext()
}

type SyntaxBracketLcContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySyntaxBracketLcContext() *SyntaxBracketLcContext {
	var p = new(SyntaxBracketLcContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_syntaxBracketLc
	return p
}

func InitEmptySyntaxBracketLcContext(p *SyntaxBracketLcContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_syntaxBracketLc
}

func (*SyntaxBracketLcContext) IsSyntaxBracketLcContext() {}

func NewSyntaxBracketLcContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SyntaxBracketLcContext {
	var p = new(SyntaxBracketLcContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_syntaxBracketLc

	return p
}

func (s *SyntaxBracketLcContext) GetParser() antlr.Parser { return s.parser }

func (s *SyntaxBracketLcContext) LC_BRACKET() antlr.TerminalNode {
	return s.GetToken(CqlParserLC_BRACKET, 0)
}

func (s *SyntaxBracketLcContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SyntaxBracketLcContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SyntaxBracketLcContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterSyntaxBracketLc(s)
	}
}

func (s *SyntaxBracketLcContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitSyntaxBracketLc(s)
	}
}

func (p *CqlParser) SyntaxBracketLc() (localctx ISyntaxBracketLcContext) {
	localctx = NewSyntaxBracketLcContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 650, CqlParserRULE_syntaxBracketLc)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3249)
		p.Match(CqlParserLC_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISyntaxBracketRcContext is an interface to support dynamic dispatch.
type ISyntaxBracketRcContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RC_BRACKET() antlr.TerminalNode

	// IsSyntaxBracketRcContext differentiates from other interfaces.
	IsSyntaxBracketRcContext()
}

type SyntaxBracketRcContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySyntaxBracketRcContext() *SyntaxBracketRcContext {
	var p = new(SyntaxBracketRcContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_syntaxBracketRc
	return p
}

func InitEmptySyntaxBracketRcContext(p *SyntaxBracketRcContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_syntaxBracketRc
}

func (*SyntaxBracketRcContext) IsSyntaxBracketRcContext() {}

func NewSyntaxBracketRcContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SyntaxBracketRcContext {
	var p = new(SyntaxBracketRcContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_syntaxBracketRc

	return p
}

func (s *SyntaxBracketRcContext) GetParser() antlr.Parser { return s.parser }

func (s *SyntaxBracketRcContext) RC_BRACKET() antlr.TerminalNode {
	return s.GetToken(CqlParserRC_BRACKET, 0)
}

func (s *SyntaxBracketRcContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SyntaxBracketRcContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SyntaxBracketRcContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterSyntaxBracketRc(s)
	}
}

func (s *SyntaxBracketRcContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitSyntaxBracketRc(s)
	}
}

func (p *CqlParser) SyntaxBracketRc() (localctx ISyntaxBracketRcContext) {
	localctx = NewSyntaxBracketRcContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 652, CqlParserRULE_syntaxBracketRc)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3251)
		p.Match(CqlParserRC_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISyntaxBracketLaContext is an interface to support dynamic dispatch.
type ISyntaxBracketLaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OPERATOR_LT() antlr.TerminalNode

	// IsSyntaxBracketLaContext differentiates from other interfaces.
	IsSyntaxBracketLaContext()
}

type SyntaxBracketLaContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySyntaxBracketLaContext() *SyntaxBracketLaContext {
	var p = new(SyntaxBracketLaContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_syntaxBracketLa
	return p
}

func InitEmptySyntaxBracketLaContext(p *SyntaxBracketLaContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_syntaxBracketLa
}

func (*SyntaxBracketLaContext) IsSyntaxBracketLaContext() {}

func NewSyntaxBracketLaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SyntaxBracketLaContext {
	var p = new(SyntaxBracketLaContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_syntaxBracketLa

	return p
}

func (s *SyntaxBracketLaContext) GetParser() antlr.Parser { return s.parser }

func (s *SyntaxBracketLaContext) OPERATOR_LT() antlr.TerminalNode {
	return s.GetToken(CqlParserOPERATOR_LT, 0)
}

func (s *SyntaxBracketLaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SyntaxBracketLaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SyntaxBracketLaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterSyntaxBracketLa(s)
	}
}

func (s *SyntaxBracketLaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitSyntaxBracketLa(s)
	}
}

func (p *CqlParser) SyntaxBracketLa() (localctx ISyntaxBracketLaContext) {
	localctx = NewSyntaxBracketLaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 654, CqlParserRULE_syntaxBracketLa)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3253)
		p.Match(CqlParserOPERATOR_LT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISyntaxBracketRaContext is an interface to support dynamic dispatch.
type ISyntaxBracketRaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OPERATOR_GT() antlr.TerminalNode

	// IsSyntaxBracketRaContext differentiates from other interfaces.
	IsSyntaxBracketRaContext()
}

type SyntaxBracketRaContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySyntaxBracketRaContext() *SyntaxBracketRaContext {
	var p = new(SyntaxBracketRaContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_syntaxBracketRa
	return p
}

func InitEmptySyntaxBracketRaContext(p *SyntaxBracketRaContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_syntaxBracketRa
}

func (*SyntaxBracketRaContext) IsSyntaxBracketRaContext() {}

func NewSyntaxBracketRaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SyntaxBracketRaContext {
	var p = new(SyntaxBracketRaContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_syntaxBracketRa

	return p
}

func (s *SyntaxBracketRaContext) GetParser() antlr.Parser { return s.parser }

func (s *SyntaxBracketRaContext) OPERATOR_GT() antlr.TerminalNode {
	return s.GetToken(CqlParserOPERATOR_GT, 0)
}

func (s *SyntaxBracketRaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SyntaxBracketRaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SyntaxBracketRaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterSyntaxBracketRa(s)
	}
}

func (s *SyntaxBracketRaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitSyntaxBracketRa(s)
	}
}

func (p *CqlParser) SyntaxBracketRa() (localctx ISyntaxBracketRaContext) {
	localctx = NewSyntaxBracketRaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 656, CqlParserRULE_syntaxBracketRa)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3255)
		p.Match(CqlParserOPERATOR_GT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISyntaxBracketLsContext is an interface to support dynamic dispatch.
type ISyntaxBracketLsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LS_BRACKET() antlr.TerminalNode

	// IsSyntaxBracketLsContext differentiates from other interfaces.
	IsSyntaxBracketLsContext()
}

type SyntaxBracketLsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySyntaxBracketLsContext() *SyntaxBracketLsContext {
	var p = new(SyntaxBracketLsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_syntaxBracketLs
	return p
}

func InitEmptySyntaxBracketLsContext(p *SyntaxBracketLsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_syntaxBracketLs
}

func (*SyntaxBracketLsContext) IsSyntaxBracketLsContext() {}

func NewSyntaxBracketLsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SyntaxBracketLsContext {
	var p = new(SyntaxBracketLsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_syntaxBracketLs

	return p
}

func (s *SyntaxBracketLsContext) GetParser() antlr.Parser { return s.parser }

func (s *SyntaxBracketLsContext) LS_BRACKET() antlr.TerminalNode {
	return s.GetToken(CqlParserLS_BRACKET, 0)
}

func (s *SyntaxBracketLsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SyntaxBracketLsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SyntaxBracketLsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterSyntaxBracketLs(s)
	}
}

func (s *SyntaxBracketLsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitSyntaxBracketLs(s)
	}
}

func (p *CqlParser) SyntaxBracketLs() (localctx ISyntaxBracketLsContext) {
	localctx = NewSyntaxBracketLsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 658, CqlParserRULE_syntaxBracketLs)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3257)
		p.Match(CqlParserLS_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISyntaxBracketRsContext is an interface to support dynamic dispatch.
type ISyntaxBracketRsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RS_BRACKET() antlr.TerminalNode

	// IsSyntaxBracketRsContext differentiates from other interfaces.
	IsSyntaxBracketRsContext()
}

type SyntaxBracketRsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySyntaxBracketRsContext() *SyntaxBracketRsContext {
	var p = new(SyntaxBracketRsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_syntaxBracketRs
	return p
}

func InitEmptySyntaxBracketRsContext(p *SyntaxBracketRsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_syntaxBracketRs
}

func (*SyntaxBracketRsContext) IsSyntaxBracketRsContext() {}

func NewSyntaxBracketRsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SyntaxBracketRsContext {
	var p = new(SyntaxBracketRsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_syntaxBracketRs

	return p
}

func (s *SyntaxBracketRsContext) GetParser() antlr.Parser { return s.parser }

func (s *SyntaxBracketRsContext) RS_BRACKET() antlr.TerminalNode {
	return s.GetToken(CqlParserRS_BRACKET, 0)
}

func (s *SyntaxBracketRsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SyntaxBracketRsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SyntaxBracketRsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterSyntaxBracketRs(s)
	}
}

func (s *SyntaxBracketRsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitSyntaxBracketRs(s)
	}
}

func (p *CqlParser) SyntaxBracketRs() (localctx ISyntaxBracketRsContext) {
	localctx = NewSyntaxBracketRsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 660, CqlParserRULE_syntaxBracketRs)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3259)
		p.Match(CqlParserRS_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISyntaxCommaContext is an interface to support dynamic dispatch.
type ISyntaxCommaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COMMA() antlr.TerminalNode

	// IsSyntaxCommaContext differentiates from other interfaces.
	IsSyntaxCommaContext()
}

type SyntaxCommaContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySyntaxCommaContext() *SyntaxCommaContext {
	var p = new(SyntaxCommaContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_syntaxComma
	return p
}

func InitEmptySyntaxCommaContext(p *SyntaxCommaContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_syntaxComma
}

func (*SyntaxCommaContext) IsSyntaxCommaContext() {}

func NewSyntaxCommaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SyntaxCommaContext {
	var p = new(SyntaxCommaContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_syntaxComma

	return p
}

func (s *SyntaxCommaContext) GetParser() antlr.Parser { return s.parser }

func (s *SyntaxCommaContext) COMMA() antlr.TerminalNode {
	return s.GetToken(CqlParserCOMMA, 0)
}

func (s *SyntaxCommaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SyntaxCommaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SyntaxCommaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterSyntaxComma(s)
	}
}

func (s *SyntaxCommaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitSyntaxComma(s)
	}
}

func (p *CqlParser) SyntaxComma() (localctx ISyntaxCommaContext) {
	localctx = NewSyntaxCommaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 662, CqlParserRULE_syntaxComma)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3261)
		p.Match(CqlParserCOMMA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISyntaxColonContext is an interface to support dynamic dispatch.
type ISyntaxColonContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COLON() antlr.TerminalNode

	// IsSyntaxColonContext differentiates from other interfaces.
	IsSyntaxColonContext()
}

type SyntaxColonContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySyntaxColonContext() *SyntaxColonContext {
	var p = new(SyntaxColonContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_syntaxColon
	return p
}

func InitEmptySyntaxColonContext(p *SyntaxColonContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_syntaxColon
}

func (*SyntaxColonContext) IsSyntaxColonContext() {}

func NewSyntaxColonContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SyntaxColonContext {
	var p = new(SyntaxColonContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_syntaxColon

	return p
}

func (s *SyntaxColonContext) GetParser() antlr.Parser { return s.parser }

func (s *SyntaxColonContext) COLON() antlr.TerminalNode {
	return s.GetToken(CqlParserCOLON, 0)
}

func (s *SyntaxColonContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SyntaxColonContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SyntaxColonContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterSyntaxColon(s)
	}
}

func (s *SyntaxColonContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitSyntaxColon(s)
	}
}

func (p *CqlParser) SyntaxColon() (localctx ISyntaxColonContext) {
	localctx = NewSyntaxColonContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 664, CqlParserRULE_syntaxColon)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3263)
		p.Match(CqlParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwBypassContext is an interface to support dynamic dispatch.
type IKwBypassContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_BYPASS() antlr.TerminalNode

	// IsKwBypassContext differentiates from other interfaces.
	IsKwBypassContext()
}

type KwBypassContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwBypassContext() *KwBypassContext {
	var p = new(KwBypassContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwBypass
	return p
}

func InitEmptyKwBypassContext(p *KwBypassContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwBypass
}

func (*KwBypassContext) IsKwBypassContext() {}

func NewKwBypassContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwBypassContext {
	var p = new(KwBypassContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwBypass

	return p
}

func (s *KwBypassContext) GetParser() antlr.Parser { return s.parser }

func (s *KwBypassContext) K_BYPASS() antlr.TerminalNode {
	return s.GetToken(CqlParserK_BYPASS, 0)
}

func (s *KwBypassContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwBypassContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwBypassContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwBypass(s)
	}
}

func (s *KwBypassContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwBypass(s)
	}
}

func (p *CqlParser) KwBypass() (localctx IKwBypassContext) {
	localctx = NewKwBypassContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 666, CqlParserRULE_kwBypass)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3265)
		p.Match(CqlParserK_BYPASS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwCacheContext is an interface to support dynamic dispatch.
type IKwCacheContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_CACHE() antlr.TerminalNode

	// IsKwCacheContext differentiates from other interfaces.
	IsKwCacheContext()
}

type KwCacheContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwCacheContext() *KwCacheContext {
	var p = new(KwCacheContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwCache
	return p
}

func InitEmptyKwCacheContext(p *KwCacheContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwCache
}

func (*KwCacheContext) IsKwCacheContext() {}

func NewKwCacheContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwCacheContext {
	var p = new(KwCacheContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwCache

	return p
}

func (s *KwCacheContext) GetParser() antlr.Parser { return s.parser }

func (s *KwCacheContext) K_CACHE() antlr.TerminalNode {
	return s.GetToken(CqlParserK_CACHE, 0)
}

func (s *KwCacheContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwCacheContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwCacheContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwCache(s)
	}
}

func (s *KwCacheContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwCache(s)
	}
}

func (p *CqlParser) KwCache() (localctx IKwCacheContext) {
	localctx = NewKwCacheContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 668, CqlParserRULE_kwCache)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3267)
		p.Match(CqlParserK_CACHE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwTimeoutContext is an interface to support dynamic dispatch.
type IKwTimeoutContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_TIMEOUT() antlr.TerminalNode

	// IsKwTimeoutContext differentiates from other interfaces.
	IsKwTimeoutContext()
}

type KwTimeoutContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwTimeoutContext() *KwTimeoutContext {
	var p = new(KwTimeoutContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwTimeout
	return p
}

func InitEmptyKwTimeoutContext(p *KwTimeoutContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwTimeout
}

func (*KwTimeoutContext) IsKwTimeoutContext() {}

func NewKwTimeoutContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwTimeoutContext {
	var p = new(KwTimeoutContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwTimeout

	return p
}

func (s *KwTimeoutContext) GetParser() antlr.Parser { return s.parser }

func (s *KwTimeoutContext) K_TIMEOUT() antlr.TerminalNode {
	return s.GetToken(CqlParserK_TIMEOUT, 0)
}

func (s *KwTimeoutContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwTimeoutContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwTimeoutContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwTimeout(s)
	}
}

func (s *KwTimeoutContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwTimeout(s)
	}
}

func (p *CqlParser) KwTimeout() (localctx IKwTimeoutContext) {
	localctx = NewKwTimeoutContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 670, CqlParserRULE_kwTimeout)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3269)
		p.Match(CqlParserK_TIMEOUT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwPruneContext is an interface to support dynamic dispatch.
type IKwPruneContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_PRUNE() antlr.TerminalNode

	// IsKwPruneContext differentiates from other interfaces.
	IsKwPruneContext()
}

type KwPruneContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwPruneContext() *KwPruneContext {
	var p = new(KwPruneContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwPrune
	return p
}

func InitEmptyKwPruneContext(p *KwPruneContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwPrune
}

func (*KwPruneContext) IsKwPruneContext() {}

func NewKwPruneContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwPruneContext {
	var p = new(KwPruneContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwPrune

	return p
}

func (s *KwPruneContext) GetParser() antlr.Parser { return s.parser }

func (s *KwPruneContext) K_PRUNE() antlr.TerminalNode {
	return s.GetToken(CqlParserK_PRUNE, 0)
}

func (s *KwPruneContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwPruneContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwPruneContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwPrune(s)
	}
}

func (s *KwPruneContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwPrune(s)
	}
}

func (p *CqlParser) KwPrune() (localctx IKwPruneContext) {
	localctx = NewKwPruneContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 672, CqlParserRULE_kwPrune)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3271)
		p.Match(CqlParserK_PRUNE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwPerContext is an interface to support dynamic dispatch.
type IKwPerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_PER() antlr.TerminalNode

	// IsKwPerContext differentiates from other interfaces.
	IsKwPerContext()
}

type KwPerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwPerContext() *KwPerContext {
	var p = new(KwPerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwPer
	return p
}

func InitEmptyKwPerContext(p *KwPerContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwPer
}

func (*KwPerContext) IsKwPerContext() {}

func NewKwPerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwPerContext {
	var p = new(KwPerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwPer

	return p
}

func (s *KwPerContext) GetParser() antlr.Parser { return s.parser }

func (s *KwPerContext) K_PER() antlr.TerminalNode {
	return s.GetToken(CqlParserK_PER, 0)
}

func (s *KwPerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwPerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwPerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwPer(s)
	}
}

func (s *KwPerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwPer(s)
	}
}

func (p *CqlParser) KwPer() (localctx IKwPerContext) {
	localctx = NewKwPerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 674, CqlParserRULE_kwPer)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3273)
		p.Match(CqlParserK_PER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwPartitionContext is an interface to support dynamic dispatch.
type IKwPartitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_PARTITION() antlr.TerminalNode

	// IsKwPartitionContext differentiates from other interfaces.
	IsKwPartitionContext()
}

type KwPartitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwPartitionContext() *KwPartitionContext {
	var p = new(KwPartitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwPartition
	return p
}

func InitEmptyKwPartitionContext(p *KwPartitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwPartition
}

func (*KwPartitionContext) IsKwPartitionContext() {}

func NewKwPartitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwPartitionContext {
	var p = new(KwPartitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwPartition

	return p
}

func (s *KwPartitionContext) GetParser() antlr.Parser { return s.parser }

func (s *KwPartitionContext) K_PARTITION() antlr.TerminalNode {
	return s.GetToken(CqlParserK_PARTITION, 0)
}

func (s *KwPartitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwPartitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwPartitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwPartition(s)
	}
}

func (s *KwPartitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwPartition(s)
	}
}

func (p *CqlParser) KwPartition() (localctx IKwPartitionContext) {
	localctx = NewKwPartitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 676, CqlParserRULE_kwPartition)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3275)
		p.Match(CqlParserK_PARTITION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwGroupContext is an interface to support dynamic dispatch.
type IKwGroupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_GROUP() antlr.TerminalNode

	// IsKwGroupContext differentiates from other interfaces.
	IsKwGroupContext()
}

type KwGroupContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwGroupContext() *KwGroupContext {
	var p = new(KwGroupContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwGroup
	return p
}

func InitEmptyKwGroupContext(p *KwGroupContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwGroup
}

func (*KwGroupContext) IsKwGroupContext() {}

func NewKwGroupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwGroupContext {
	var p = new(KwGroupContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwGroup

	return p
}

func (s *KwGroupContext) GetParser() antlr.Parser { return s.parser }

func (s *KwGroupContext) K_GROUP() antlr.TerminalNode {
	return s.GetToken(CqlParserK_GROUP, 0)
}

func (s *KwGroupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwGroupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwGroupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwGroup(s)
	}
}

func (s *KwGroupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwGroup(s)
	}
}

func (p *CqlParser) KwGroup() (localctx IKwGroupContext) {
	localctx = NewKwGroupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 678, CqlParserRULE_kwGroup)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3277)
		p.Match(CqlParserK_GROUP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwStaticContext is an interface to support dynamic dispatch.
type IKwStaticContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_STATIC() antlr.TerminalNode

	// IsKwStaticContext differentiates from other interfaces.
	IsKwStaticContext()
}

type KwStaticContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwStaticContext() *KwStaticContext {
	var p = new(KwStaticContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwStatic
	return p
}

func InitEmptyKwStaticContext(p *KwStaticContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwStatic
}

func (*KwStaticContext) IsKwStaticContext() {}

func NewKwStaticContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwStaticContext {
	var p = new(KwStaticContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwStatic

	return p
}

func (s *KwStaticContext) GetParser() antlr.Parser { return s.parser }

func (s *KwStaticContext) K_STATIC() antlr.TerminalNode {
	return s.GetToken(CqlParserK_STATIC, 0)
}

func (s *KwStaticContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwStaticContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwStaticContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwStatic(s)
	}
}

func (s *KwStaticContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwStatic(s)
	}
}

func (p *CqlParser) KwStatic() (localctx IKwStaticContext) {
	localctx = NewKwStaticContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 680, CqlParserRULE_kwStatic)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3279)
		p.Match(CqlParserK_STATIC)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwCastContext is an interface to support dynamic dispatch.
type IKwCastContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_CAST() antlr.TerminalNode

	// IsKwCastContext differentiates from other interfaces.
	IsKwCastContext()
}

type KwCastContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwCastContext() *KwCastContext {
	var p = new(KwCastContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwCast
	return p
}

func InitEmptyKwCastContext(p *KwCastContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwCast
}

func (*KwCastContext) IsKwCastContext() {}

func NewKwCastContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwCastContext {
	var p = new(KwCastContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwCast

	return p
}

func (s *KwCastContext) GetParser() antlr.Parser { return s.parser }

func (s *KwCastContext) K_CAST() antlr.TerminalNode {
	return s.GetToken(CqlParserK_CAST, 0)
}

func (s *KwCastContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwCastContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwCastContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwCast(s)
	}
}

func (s *KwCastContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwCast(s)
	}
}

func (p *CqlParser) KwCast() (localctx IKwCastContext) {
	localctx = NewKwCastContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 682, CqlParserRULE_kwCast)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3281)
		p.Match(CqlParserK_CAST)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwLikeContext is an interface to support dynamic dispatch.
type IKwLikeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_LIKE() antlr.TerminalNode

	// IsKwLikeContext differentiates from other interfaces.
	IsKwLikeContext()
}

type KwLikeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwLikeContext() *KwLikeContext {
	var p = new(KwLikeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwLike
	return p
}

func InitEmptyKwLikeContext(p *KwLikeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwLike
}

func (*KwLikeContext) IsKwLikeContext() {}

func NewKwLikeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwLikeContext {
	var p = new(KwLikeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwLike

	return p
}

func (s *KwLikeContext) GetParser() antlr.Parser { return s.parser }

func (s *KwLikeContext) K_LIKE() antlr.TerminalNode {
	return s.GetToken(CqlParserK_LIKE, 0)
}

func (s *KwLikeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwLikeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwLikeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwLike(s)
	}
}

func (s *KwLikeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwLike(s)
	}
}

func (p *CqlParser) KwLike() (localctx IKwLikeContext) {
	localctx = NewKwLikeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 684, CqlParserRULE_kwLike)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3283)
		p.Match(CqlParserK_LIKE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwWritetimeContext is an interface to support dynamic dispatch.
type IKwWritetimeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_WRITETIME() antlr.TerminalNode

	// IsKwWritetimeContext differentiates from other interfaces.
	IsKwWritetimeContext()
}

type KwWritetimeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwWritetimeContext() *KwWritetimeContext {
	var p = new(KwWritetimeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwWritetime
	return p
}

func InitEmptyKwWritetimeContext(p *KwWritetimeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwWritetime
}

func (*KwWritetimeContext) IsKwWritetimeContext() {}

func NewKwWritetimeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwWritetimeContext {
	var p = new(KwWritetimeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwWritetime

	return p
}

func (s *KwWritetimeContext) GetParser() antlr.Parser { return s.parser }

func (s *KwWritetimeContext) K_WRITETIME() antlr.TerminalNode {
	return s.GetToken(CqlParserK_WRITETIME, 0)
}

func (s *KwWritetimeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwWritetimeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwWritetimeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwWritetime(s)
	}
}

func (s *KwWritetimeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwWritetime(s)
	}
}

func (p *CqlParser) KwWritetime() (localctx IKwWritetimeContext) {
	localctx = NewKwWritetimeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 686, CqlParserRULE_kwWritetime)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3285)
		p.Match(CqlParserK_WRITETIME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwTokenContext is an interface to support dynamic dispatch.
type IKwTokenContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_TOKEN() antlr.TerminalNode

	// IsKwTokenContext differentiates from other interfaces.
	IsKwTokenContext()
}

type KwTokenContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwTokenContext() *KwTokenContext {
	var p = new(KwTokenContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwToken
	return p
}

func InitEmptyKwTokenContext(p *KwTokenContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwToken
}

func (*KwTokenContext) IsKwTokenContext() {}

func NewKwTokenContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwTokenContext {
	var p = new(KwTokenContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwToken

	return p
}

func (s *KwTokenContext) GetParser() antlr.Parser { return s.parser }

func (s *KwTokenContext) K_TOKEN() antlr.TerminalNode {
	return s.GetToken(CqlParserK_TOKEN, 0)
}

func (s *KwTokenContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwTokenContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwTokenContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwToken(s)
	}
}

func (s *KwTokenContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwToken(s)
	}
}

func (p *CqlParser) KwToken() (localctx IKwTokenContext) {
	localctx = NewKwTokenContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 688, CqlParserRULE_kwToken)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3287)
		p.Match(CqlParserK_TOKEN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwTabletsContext is an interface to support dynamic dispatch.
type IKwTabletsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_TABLETS() antlr.TerminalNode

	// IsKwTabletsContext differentiates from other interfaces.
	IsKwTabletsContext()
}

type KwTabletsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwTabletsContext() *KwTabletsContext {
	var p = new(KwTabletsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwTablets
	return p
}

func InitEmptyKwTabletsContext(p *KwTabletsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwTablets
}

func (*KwTabletsContext) IsKwTabletsContext() {}

func NewKwTabletsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwTabletsContext {
	var p = new(KwTabletsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwTablets

	return p
}

func (s *KwTabletsContext) GetParser() antlr.Parser { return s.parser }

func (s *KwTabletsContext) K_TABLETS() antlr.TerminalNode {
	return s.GetToken(CqlParserK_TABLETS, 0)
}

func (s *KwTabletsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwTabletsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwTabletsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwTablets(s)
	}
}

func (s *KwTabletsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwTablets(s)
	}
}

func (p *CqlParser) KwTablets() (localctx IKwTabletsContext) {
	localctx = NewKwTabletsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 690, CqlParserRULE_kwTablets)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3289)
		p.Match(CqlParserK_TABLETS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwDefaultContext is an interface to support dynamic dispatch.
type IKwDefaultContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_DEFAULT() antlr.TerminalNode

	// IsKwDefaultContext differentiates from other interfaces.
	IsKwDefaultContext()
}

type KwDefaultContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwDefaultContext() *KwDefaultContext {
	var p = new(KwDefaultContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwDefault
	return p
}

func InitEmptyKwDefaultContext(p *KwDefaultContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwDefault
}

func (*KwDefaultContext) IsKwDefaultContext() {}

func NewKwDefaultContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwDefaultContext {
	var p = new(KwDefaultContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwDefault

	return p
}

func (s *KwDefaultContext) GetParser() antlr.Parser { return s.parser }

func (s *KwDefaultContext) K_DEFAULT() antlr.TerminalNode {
	return s.GetToken(CqlParserK_DEFAULT, 0)
}

func (s *KwDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwDefaultContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwDefault(s)
	}
}

func (s *KwDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwDefault(s)
	}
}

func (p *CqlParser) KwDefault() (localctx IKwDefaultContext) {
	localctx = NewKwDefaultContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 692, CqlParserRULE_kwDefault)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3291)
		p.Match(CqlParserK_DEFAULT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwUnsetContext is an interface to support dynamic dispatch.
type IKwUnsetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_UNSET() antlr.TerminalNode

	// IsKwUnsetContext differentiates from other interfaces.
	IsKwUnsetContext()
}

type KwUnsetContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwUnsetContext() *KwUnsetContext {
	var p = new(KwUnsetContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwUnset
	return p
}

func InitEmptyKwUnsetContext(p *KwUnsetContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwUnset
}

func (*KwUnsetContext) IsKwUnsetContext() {}

func NewKwUnsetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwUnsetContext {
	var p = new(KwUnsetContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwUnset

	return p
}

func (s *KwUnsetContext) GetParser() antlr.Parser { return s.parser }

func (s *KwUnsetContext) K_UNSET() antlr.TerminalNode {
	return s.GetToken(CqlParserK_UNSET, 0)
}

func (s *KwUnsetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwUnsetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwUnsetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwUnset(s)
	}
}

func (s *KwUnsetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwUnset(s)
	}
}

func (p *CqlParser) KwUnset() (localctx IKwUnsetContext) {
	localctx = NewKwUnsetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 694, CqlParserRULE_kwUnset)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3293)
		p.Match(CqlParserK_UNSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwCounterContext is an interface to support dynamic dispatch.
type IKwCounterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_COUNTER() antlr.TerminalNode

	// IsKwCounterContext differentiates from other interfaces.
	IsKwCounterContext()
}

type KwCounterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwCounterContext() *KwCounterContext {
	var p = new(KwCounterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwCounter
	return p
}

func InitEmptyKwCounterContext(p *KwCounterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwCounter
}

func (*KwCounterContext) IsKwCounterContext() {}

func NewKwCounterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwCounterContext {
	var p = new(KwCounterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwCounter

	return p
}

func (s *KwCounterContext) GetParser() antlr.Parser { return s.parser }

func (s *KwCounterContext) K_COUNTER() antlr.TerminalNode {
	return s.GetToken(CqlParserK_COUNTER, 0)
}

func (s *KwCounterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwCounterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwCounterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwCounter(s)
	}
}

func (s *KwCounterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwCounter(s)
	}
}

func (p *CqlParser) KwCounter() (localctx IKwCounterContext) {
	localctx = NewKwCounterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 696, CqlParserRULE_kwCounter)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3295)
		p.Match(CqlParserK_COUNTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwDescribeContext is an interface to support dynamic dispatch.
type IKwDescribeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_DESCRIBE() antlr.TerminalNode

	// IsKwDescribeContext differentiates from other interfaces.
	IsKwDescribeContext()
}

type KwDescribeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwDescribeContext() *KwDescribeContext {
	var p = new(KwDescribeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwDescribe
	return p
}

func InitEmptyKwDescribeContext(p *KwDescribeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwDescribe
}

func (*KwDescribeContext) IsKwDescribeContext() {}

func NewKwDescribeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwDescribeContext {
	var p = new(KwDescribeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwDescribe

	return p
}

func (s *KwDescribeContext) GetParser() antlr.Parser { return s.parser }

func (s *KwDescribeContext) K_DESCRIBE() antlr.TerminalNode {
	return s.GetToken(CqlParserK_DESCRIBE, 0)
}

func (s *KwDescribeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwDescribeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwDescribeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwDescribe(s)
	}
}

func (s *KwDescribeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwDescribe(s)
	}
}

func (p *CqlParser) KwDescribe() (localctx IKwDescribeContext) {
	localctx = NewKwDescribeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 698, CqlParserRULE_kwDescribe)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3297)
		p.Match(CqlParserK_DESCRIBE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwClusterContext is an interface to support dynamic dispatch.
type IKwClusterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_CLUSTER() antlr.TerminalNode

	// IsKwClusterContext differentiates from other interfaces.
	IsKwClusterContext()
}

type KwClusterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwClusterContext() *KwClusterContext {
	var p = new(KwClusterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwCluster
	return p
}

func InitEmptyKwClusterContext(p *KwClusterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwCluster
}

func (*KwClusterContext) IsKwClusterContext() {}

func NewKwClusterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwClusterContext {
	var p = new(KwClusterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwCluster

	return p
}

func (s *KwClusterContext) GetParser() antlr.Parser { return s.parser }

func (s *KwClusterContext) K_CLUSTER() antlr.TerminalNode {
	return s.GetToken(CqlParserK_CLUSTER, 0)
}

func (s *KwClusterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwClusterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwClusterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwCluster(s)
	}
}

func (s *KwClusterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwCluster(s)
	}
}

func (p *CqlParser) KwCluster() (localctx IKwClusterContext) {
	localctx = NewKwClusterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 700, CqlParserRULE_kwCluster)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3299)
		p.Match(CqlParserK_CLUSTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwOnlyContext is an interface to support dynamic dispatch.
type IKwOnlyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_ONLY() antlr.TerminalNode

	// IsKwOnlyContext differentiates from other interfaces.
	IsKwOnlyContext()
}

type KwOnlyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwOnlyContext() *KwOnlyContext {
	var p = new(KwOnlyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwOnly
	return p
}

func InitEmptyKwOnlyContext(p *KwOnlyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwOnly
}

func (*KwOnlyContext) IsKwOnlyContext() {}

func NewKwOnlyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwOnlyContext {
	var p = new(KwOnlyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwOnly

	return p
}

func (s *KwOnlyContext) GetParser() antlr.Parser { return s.parser }

func (s *KwOnlyContext) K_ONLY() antlr.TerminalNode {
	return s.GetToken(CqlParserK_ONLY, 0)
}

func (s *KwOnlyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwOnlyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwOnlyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwOnly(s)
	}
}

func (s *KwOnlyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwOnly(s)
	}
}

func (p *CqlParser) KwOnly() (localctx IKwOnlyContext) {
	localctx = NewKwOnlyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 702, CqlParserRULE_kwOnly)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3301)
		p.Match(CqlParserK_ONLY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwInternalsContext is an interface to support dynamic dispatch.
type IKwInternalsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_INTERNALS() antlr.TerminalNode

	// IsKwInternalsContext differentiates from other interfaces.
	IsKwInternalsContext()
}

type KwInternalsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwInternalsContext() *KwInternalsContext {
	var p = new(KwInternalsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwInternals
	return p
}

func InitEmptyKwInternalsContext(p *KwInternalsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwInternals
}

func (*KwInternalsContext) IsKwInternalsContext() {}

func NewKwInternalsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwInternalsContext {
	var p = new(KwInternalsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwInternals

	return p
}

func (s *KwInternalsContext) GetParser() antlr.Parser { return s.parser }

func (s *KwInternalsContext) K_INTERNALS() antlr.TerminalNode {
	return s.GetToken(CqlParserK_INTERNALS, 0)
}

func (s *KwInternalsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwInternalsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwInternalsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwInternals(s)
	}
}

func (s *KwInternalsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwInternals(s)
	}
}

func (p *CqlParser) KwInternals() (localctx IKwInternalsContext) {
	localctx = NewKwInternalsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 704, CqlParserRULE_kwInternals)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3303)
		p.Match(CqlParserK_INTERNALS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwPasswordsContext is an interface to support dynamic dispatch.
type IKwPasswordsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_PASSWORDS() antlr.TerminalNode

	// IsKwPasswordsContext differentiates from other interfaces.
	IsKwPasswordsContext()
}

type KwPasswordsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwPasswordsContext() *KwPasswordsContext {
	var p = new(KwPasswordsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwPasswords
	return p
}

func InitEmptyKwPasswordsContext(p *KwPasswordsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwPasswords
}

func (*KwPasswordsContext) IsKwPasswordsContext() {}

func NewKwPasswordsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwPasswordsContext {
	var p = new(KwPasswordsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwPasswords

	return p
}

func (s *KwPasswordsContext) GetParser() antlr.Parser { return s.parser }

func (s *KwPasswordsContext) K_PASSWORDS() antlr.TerminalNode {
	return s.GetToken(CqlParserK_PASSWORDS, 0)
}

func (s *KwPasswordsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwPasswordsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwPasswordsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwPasswords(s)
	}
}

func (s *KwPasswordsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwPasswords(s)
	}
}

func (p *CqlParser) KwPasswords() (localctx IKwPasswordsContext) {
	localctx = NewKwPasswordsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 706, CqlParserRULE_kwPasswords)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3305)
		p.Match(CqlParserK_PASSWORDS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwSchemaContext is an interface to support dynamic dispatch.
type IKwSchemaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_SCHEMA() antlr.TerminalNode

	// IsKwSchemaContext differentiates from other interfaces.
	IsKwSchemaContext()
}

type KwSchemaContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwSchemaContext() *KwSchemaContext {
	var p = new(KwSchemaContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwSchema
	return p
}

func InitEmptyKwSchemaContext(p *KwSchemaContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwSchema
}

func (*KwSchemaContext) IsKwSchemaContext() {}

func NewKwSchemaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwSchemaContext {
	var p = new(KwSchemaContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwSchema

	return p
}

func (s *KwSchemaContext) GetParser() antlr.Parser { return s.parser }

func (s *KwSchemaContext) K_SCHEMA() antlr.TerminalNode {
	return s.GetToken(CqlParserK_SCHEMA, 0)
}

func (s *KwSchemaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwSchemaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwSchemaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwSchema(s)
	}
}

func (s *KwSchemaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwSchema(s)
	}
}

func (p *CqlParser) KwSchema() (localctx IKwSchemaContext) {
	localctx = NewKwSchemaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 708, CqlParserRULE_kwSchema)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3307)
		p.Match(CqlParserK_SCHEMA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwTablesContext is an interface to support dynamic dispatch.
type IKwTablesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_TABLES() antlr.TerminalNode

	// IsKwTablesContext differentiates from other interfaces.
	IsKwTablesContext()
}

type KwTablesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwTablesContext() *KwTablesContext {
	var p = new(KwTablesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwTables
	return p
}

func InitEmptyKwTablesContext(p *KwTablesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwTables
}

func (*KwTablesContext) IsKwTablesContext() {}

func NewKwTablesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwTablesContext {
	var p = new(KwTablesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwTables

	return p
}

func (s *KwTablesContext) GetParser() antlr.Parser { return s.parser }

func (s *KwTablesContext) K_TABLES() antlr.TerminalNode {
	return s.GetToken(CqlParserK_TABLES, 0)
}

func (s *KwTablesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwTablesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwTablesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwTables(s)
	}
}

func (s *KwTablesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwTables(s)
	}
}

func (p *CqlParser) KwTables() (localctx IKwTablesContext) {
	localctx = NewKwTablesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 710, CqlParserRULE_kwTables)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3309)
		p.Match(CqlParserK_TABLES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwTypesContext is an interface to support dynamic dispatch.
type IKwTypesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_TYPES() antlr.TerminalNode

	// IsKwTypesContext differentiates from other interfaces.
	IsKwTypesContext()
}

type KwTypesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwTypesContext() *KwTypesContext {
	var p = new(KwTypesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwTypes
	return p
}

func InitEmptyKwTypesContext(p *KwTypesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwTypes
}

func (*KwTypesContext) IsKwTypesContext() {}

func NewKwTypesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwTypesContext {
	var p = new(KwTypesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwTypes

	return p
}

func (s *KwTypesContext) GetParser() antlr.Parser { return s.parser }

func (s *KwTypesContext) K_TYPES() antlr.TerminalNode {
	return s.GetToken(CqlParserK_TYPES, 0)
}

func (s *KwTypesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwTypesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwTypesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwTypes(s)
	}
}

func (s *KwTypesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwTypes(s)
	}
}

func (p *CqlParser) KwTypes() (localctx IKwTypesContext) {
	localctx = NewKwTypesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 712, CqlParserRULE_kwTypes)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3311)
		p.Match(CqlParserK_TYPES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwAggregatesContext is an interface to support dynamic dispatch.
type IKwAggregatesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_AGGREGATES() antlr.TerminalNode

	// IsKwAggregatesContext differentiates from other interfaces.
	IsKwAggregatesContext()
}

type KwAggregatesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwAggregatesContext() *KwAggregatesContext {
	var p = new(KwAggregatesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwAggregates
	return p
}

func InitEmptyKwAggregatesContext(p *KwAggregatesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwAggregates
}

func (*KwAggregatesContext) IsKwAggregatesContext() {}

func NewKwAggregatesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwAggregatesContext {
	var p = new(KwAggregatesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwAggregates

	return p
}

func (s *KwAggregatesContext) GetParser() antlr.Parser { return s.parser }

func (s *KwAggregatesContext) K_AGGREGATES() antlr.TerminalNode {
	return s.GetToken(CqlParserK_AGGREGATES, 0)
}

func (s *KwAggregatesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwAggregatesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwAggregatesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwAggregates(s)
	}
}

func (s *KwAggregatesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwAggregates(s)
	}
}

func (p *CqlParser) KwAggregates() (localctx IKwAggregatesContext) {
	localctx = NewKwAggregatesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 714, CqlParserRULE_kwAggregates)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3313)
		p.Match(CqlParserK_AGGREGATES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwColumnfamilyContext is an interface to support dynamic dispatch.
type IKwColumnfamilyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_COLUMNFAMILY() antlr.TerminalNode

	// IsKwColumnfamilyContext differentiates from other interfaces.
	IsKwColumnfamilyContext()
}

type KwColumnfamilyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwColumnfamilyContext() *KwColumnfamilyContext {
	var p = new(KwColumnfamilyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwColumnfamily
	return p
}

func InitEmptyKwColumnfamilyContext(p *KwColumnfamilyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwColumnfamily
}

func (*KwColumnfamilyContext) IsKwColumnfamilyContext() {}

func NewKwColumnfamilyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwColumnfamilyContext {
	var p = new(KwColumnfamilyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwColumnfamily

	return p
}

func (s *KwColumnfamilyContext) GetParser() antlr.Parser { return s.parser }

func (s *KwColumnfamilyContext) K_COLUMNFAMILY() antlr.TerminalNode {
	return s.GetToken(CqlParserK_COLUMNFAMILY, 0)
}

func (s *KwColumnfamilyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwColumnfamilyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwColumnfamilyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwColumnfamily(s)
	}
}

func (s *KwColumnfamilyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwColumnfamily(s)
	}
}

func (p *CqlParser) KwColumnfamily() (localctx IKwColumnfamilyContext) {
	localctx = NewKwColumnfamilyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 716, CqlParserRULE_kwColumnfamily)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3315)
		p.Match(CqlParserK_COLUMNFAMILY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwServiceContext is an interface to support dynamic dispatch.
type IKwServiceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_SERVICE() antlr.TerminalNode

	// IsKwServiceContext differentiates from other interfaces.
	IsKwServiceContext()
}

type KwServiceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwServiceContext() *KwServiceContext {
	var p = new(KwServiceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwService
	return p
}

func InitEmptyKwServiceContext(p *KwServiceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwService
}

func (*KwServiceContext) IsKwServiceContext() {}

func NewKwServiceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwServiceContext {
	var p = new(KwServiceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwService

	return p
}

func (s *KwServiceContext) GetParser() antlr.Parser { return s.parser }

func (s *KwServiceContext) K_SERVICE() antlr.TerminalNode {
	return s.GetToken(CqlParserK_SERVICE, 0)
}

func (s *KwServiceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwServiceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwServiceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwService(s)
	}
}

func (s *KwServiceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwService(s)
	}
}

func (p *CqlParser) KwService() (localctx IKwServiceContext) {
	localctx = NewKwServiceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 718, CqlParserRULE_kwService)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3317)
		p.Match(CqlParserK_SERVICE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwLevelContext is an interface to support dynamic dispatch.
type IKwLevelContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_LEVEL() antlr.TerminalNode

	// IsKwLevelContext differentiates from other interfaces.
	IsKwLevelContext()
}

type KwLevelContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwLevelContext() *KwLevelContext {
	var p = new(KwLevelContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwLevel
	return p
}

func InitEmptyKwLevelContext(p *KwLevelContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwLevel
}

func (*KwLevelContext) IsKwLevelContext() {}

func NewKwLevelContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwLevelContext {
	var p = new(KwLevelContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwLevel

	return p
}

func (s *KwLevelContext) GetParser() antlr.Parser { return s.parser }

func (s *KwLevelContext) K_LEVEL() antlr.TerminalNode {
	return s.GetToken(CqlParserK_LEVEL, 0)
}

func (s *KwLevelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwLevelContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwLevelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwLevel(s)
	}
}

func (s *KwLevelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwLevel(s)
	}
}

func (p *CqlParser) KwLevel() (localctx IKwLevelContext) {
	localctx = NewKwLevelContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 720, CqlParserRULE_kwLevel)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3319)
		p.Match(CqlParserK_LEVEL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwLevelsContext is an interface to support dynamic dispatch.
type IKwLevelsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_LEVELS() antlr.TerminalNode

	// IsKwLevelsContext differentiates from other interfaces.
	IsKwLevelsContext()
}

type KwLevelsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwLevelsContext() *KwLevelsContext {
	var p = new(KwLevelsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwLevels
	return p
}

func InitEmptyKwLevelsContext(p *KwLevelsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwLevels
}

func (*KwLevelsContext) IsKwLevelsContext() {}

func NewKwLevelsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwLevelsContext {
	var p = new(KwLevelsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwLevels

	return p
}

func (s *KwLevelsContext) GetParser() antlr.Parser { return s.parser }

func (s *KwLevelsContext) K_LEVELS() antlr.TerminalNode {
	return s.GetToken(CqlParserK_LEVELS, 0)
}

func (s *KwLevelsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwLevelsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwLevelsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwLevels(s)
	}
}

func (s *KwLevelsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwLevels(s)
	}
}

func (p *CqlParser) KwLevels() (localctx IKwLevelsContext) {
	localctx = NewKwLevelsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 722, CqlParserRULE_kwLevels)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3321)
		p.Match(CqlParserK_LEVELS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwAttachContext is an interface to support dynamic dispatch.
type IKwAttachContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_ATTACH() antlr.TerminalNode

	// IsKwAttachContext differentiates from other interfaces.
	IsKwAttachContext()
}

type KwAttachContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwAttachContext() *KwAttachContext {
	var p = new(KwAttachContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwAttach
	return p
}

func InitEmptyKwAttachContext(p *KwAttachContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwAttach
}

func (*KwAttachContext) IsKwAttachContext() {}

func NewKwAttachContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwAttachContext {
	var p = new(KwAttachContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwAttach

	return p
}

func (s *KwAttachContext) GetParser() antlr.Parser { return s.parser }

func (s *KwAttachContext) K_ATTACH() antlr.TerminalNode {
	return s.GetToken(CqlParserK_ATTACH, 0)
}

func (s *KwAttachContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwAttachContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwAttachContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwAttach(s)
	}
}

func (s *KwAttachContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwAttach(s)
	}
}

func (p *CqlParser) KwAttach() (localctx IKwAttachContext) {
	localctx = NewKwAttachContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 724, CqlParserRULE_kwAttach)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3323)
		p.Match(CqlParserK_ATTACH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwDetachContext is an interface to support dynamic dispatch.
type IKwDetachContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_DETACH() antlr.TerminalNode

	// IsKwDetachContext differentiates from other interfaces.
	IsKwDetachContext()
}

type KwDetachContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwDetachContext() *KwDetachContext {
	var p = new(KwDetachContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwDetach
	return p
}

func InitEmptyKwDetachContext(p *KwDetachContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwDetach
}

func (*KwDetachContext) IsKwDetachContext() {}

func NewKwDetachContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwDetachContext {
	var p = new(KwDetachContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwDetach

	return p
}

func (s *KwDetachContext) GetParser() antlr.Parser { return s.parser }

func (s *KwDetachContext) K_DETACH() antlr.TerminalNode {
	return s.GetToken(CqlParserK_DETACH, 0)
}

func (s *KwDetachContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwDetachContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwDetachContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwDetach(s)
	}
}

func (s *KwDetachContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwDetach(s)
	}
}

func (p *CqlParser) KwDetach() (localctx IKwDetachContext) {
	localctx = NewKwDetachContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 726, CqlParserRULE_kwDetach)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3325)
		p.Match(CqlParserK_DETACH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwAttachedContext is an interface to support dynamic dispatch.
type IKwAttachedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_ATTACHED() antlr.TerminalNode

	// IsKwAttachedContext differentiates from other interfaces.
	IsKwAttachedContext()
}

type KwAttachedContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwAttachedContext() *KwAttachedContext {
	var p = new(KwAttachedContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwAttached
	return p
}

func InitEmptyKwAttachedContext(p *KwAttachedContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwAttached
}

func (*KwAttachedContext) IsKwAttachedContext() {}

func NewKwAttachedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwAttachedContext {
	var p = new(KwAttachedContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwAttached

	return p
}

func (s *KwAttachedContext) GetParser() antlr.Parser { return s.parser }

func (s *KwAttachedContext) K_ATTACHED() antlr.TerminalNode {
	return s.GetToken(CqlParserK_ATTACHED, 0)
}

func (s *KwAttachedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwAttachedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwAttachedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwAttached(s)
	}
}

func (s *KwAttachedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwAttached(s)
	}
}

func (p *CqlParser) KwAttached() (localctx IKwAttachedContext) {
	localctx = NewKwAttachedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 728, CqlParserRULE_kwAttached)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3327)
		p.Match(CqlParserK_ATTACHED)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwEffectiveContext is an interface to support dynamic dispatch.
type IKwEffectiveContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_EFFECTIVE() antlr.TerminalNode

	// IsKwEffectiveContext differentiates from other interfaces.
	IsKwEffectiveContext()
}

type KwEffectiveContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwEffectiveContext() *KwEffectiveContext {
	var p = new(KwEffectiveContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwEffective
	return p
}

func InitEmptyKwEffectiveContext(p *KwEffectiveContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwEffective
}

func (*KwEffectiveContext) IsKwEffectiveContext() {}

func NewKwEffectiveContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwEffectiveContext {
	var p = new(KwEffectiveContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwEffective

	return p
}

func (s *KwEffectiveContext) GetParser() antlr.Parser { return s.parser }

func (s *KwEffectiveContext) K_EFFECTIVE() antlr.TerminalNode {
	return s.GetToken(CqlParserK_EFFECTIVE, 0)
}

func (s *KwEffectiveContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwEffectiveContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwEffectiveContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwEffective(s)
	}
}

func (s *KwEffectiveContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwEffective(s)
	}
}

func (p *CqlParser) KwEffective() (localctx IKwEffectiveContext) {
	localctx = NewKwEffectiveContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 730, CqlParserRULE_kwEffective)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3329)
		p.Match(CqlParserK_EFFECTIVE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwCustomContext is an interface to support dynamic dispatch.
type IKwCustomContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_CUSTOM() antlr.TerminalNode

	// IsKwCustomContext differentiates from other interfaces.
	IsKwCustomContext()
}

type KwCustomContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwCustomContext() *KwCustomContext {
	var p = new(KwCustomContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwCustom
	return p
}

func InitEmptyKwCustomContext(p *KwCustomContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwCustom
}

func (*KwCustomContext) IsKwCustomContext() {}

func NewKwCustomContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwCustomContext {
	var p = new(KwCustomContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwCustom

	return p
}

func (s *KwCustomContext) GetParser() antlr.Parser { return s.parser }

func (s *KwCustomContext) K_CUSTOM() antlr.TerminalNode {
	return s.GetToken(CqlParserK_CUSTOM, 0)
}

func (s *KwCustomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwCustomContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwCustomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwCustom(s)
	}
}

func (s *KwCustomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwCustom(s)
	}
}

func (p *CqlParser) KwCustom() (localctx IKwCustomContext) {
	localctx = NewKwCustomContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 732, CqlParserRULE_kwCustom)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3331)
		p.Match(CqlParserK_CUSTOM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwAnnContext is an interface to support dynamic dispatch.
type IKwAnnContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_ANN() antlr.TerminalNode

	// IsKwAnnContext differentiates from other interfaces.
	IsKwAnnContext()
}

type KwAnnContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwAnnContext() *KwAnnContext {
	var p = new(KwAnnContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwAnn
	return p
}

func InitEmptyKwAnnContext(p *KwAnnContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwAnn
}

func (*KwAnnContext) IsKwAnnContext() {}

func NewKwAnnContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwAnnContext {
	var p = new(KwAnnContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwAnn

	return p
}

func (s *KwAnnContext) GetParser() antlr.Parser { return s.parser }

func (s *KwAnnContext) K_ANN() antlr.TerminalNode {
	return s.GetToken(CqlParserK_ANN, 0)
}

func (s *KwAnnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwAnnContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwAnnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwAnn(s)
	}
}

func (s *KwAnnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwAnn(s)
	}
}

func (p *CqlParser) KwAnn() (localctx IKwAnnContext) {
	localctx = NewKwAnnContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 734, CqlParserRULE_kwAnn)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3333)
		p.Match(CqlParserK_ANN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwReducefuncContext is an interface to support dynamic dispatch.
type IKwReducefuncContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_REDUCEFUNC() antlr.TerminalNode

	// IsKwReducefuncContext differentiates from other interfaces.
	IsKwReducefuncContext()
}

type KwReducefuncContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwReducefuncContext() *KwReducefuncContext {
	var p = new(KwReducefuncContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwReducefunc
	return p
}

func InitEmptyKwReducefuncContext(p *KwReducefuncContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwReducefunc
}

func (*KwReducefuncContext) IsKwReducefuncContext() {}

func NewKwReducefuncContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwReducefuncContext {
	var p = new(KwReducefuncContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwReducefunc

	return p
}

func (s *KwReducefuncContext) GetParser() antlr.Parser { return s.parser }

func (s *KwReducefuncContext) K_REDUCEFUNC() antlr.TerminalNode {
	return s.GetToken(CqlParserK_REDUCEFUNC, 0)
}

func (s *KwReducefuncContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwReducefuncContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwReducefuncContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwReducefunc(s)
	}
}

func (s *KwReducefuncContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwReducefunc(s)
	}
}

func (p *CqlParser) KwReducefunc() (localctx IKwReducefuncContext) {
	localctx = NewKwReducefuncContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 736, CqlParserRULE_kwReducefunc)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3335)
		p.Match(CqlParserK_REDUCEFUNC)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwNologinContext is an interface to support dynamic dispatch.
type IKwNologinContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_NOLOGIN() antlr.TerminalNode

	// IsKwNologinContext differentiates from other interfaces.
	IsKwNologinContext()
}

type KwNologinContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwNologinContext() *KwNologinContext {
	var p = new(KwNologinContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwNologin
	return p
}

func InitEmptyKwNologinContext(p *KwNologinContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwNologin
}

func (*KwNologinContext) IsKwNologinContext() {}

func NewKwNologinContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwNologinContext {
	var p = new(KwNologinContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwNologin

	return p
}

func (s *KwNologinContext) GetParser() antlr.Parser { return s.parser }

func (s *KwNologinContext) K_NOLOGIN() antlr.TerminalNode {
	return s.GetToken(CqlParserK_NOLOGIN, 0)
}

func (s *KwNologinContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwNologinContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwNologinContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwNologin(s)
	}
}

func (s *KwNologinContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwNologin(s)
	}
}

func (p *CqlParser) KwNologin() (localctx IKwNologinContext) {
	localctx = NewKwNologinContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 738, CqlParserRULE_kwNologin)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3337)
		p.Match(CqlParserK_NOLOGIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwUsersContext is an interface to support dynamic dispatch.
type IKwUsersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_USERS() antlr.TerminalNode

	// IsKwUsersContext differentiates from other interfaces.
	IsKwUsersContext()
}

type KwUsersContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwUsersContext() *KwUsersContext {
	var p = new(KwUsersContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwUsers
	return p
}

func InitEmptyKwUsersContext(p *KwUsersContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwUsers
}

func (*KwUsersContext) IsKwUsersContext() {}

func NewKwUsersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwUsersContext {
	var p = new(KwUsersContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwUsers

	return p
}

func (s *KwUsersContext) GetParser() antlr.Parser { return s.parser }

func (s *KwUsersContext) K_USERS() antlr.TerminalNode {
	return s.GetToken(CqlParserK_USERS, 0)
}

func (s *KwUsersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwUsersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwUsersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwUsers(s)
	}
}

func (s *KwUsersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwUsers(s)
	}
}

func (p *CqlParser) KwUsers() (localctx IKwUsersContext) {
	localctx = NewKwUsersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 740, CqlParserRULE_kwUsers)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3339)
		p.Match(CqlParserK_USERS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwHashedContext is an interface to support dynamic dispatch.
type IKwHashedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_HASHED() antlr.TerminalNode

	// IsKwHashedContext differentiates from other interfaces.
	IsKwHashedContext()
}

type KwHashedContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwHashedContext() *KwHashedContext {
	var p = new(KwHashedContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwHashed
	return p
}

func InitEmptyKwHashedContext(p *KwHashedContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwHashed
}

func (*KwHashedContext) IsKwHashedContext() {}

func NewKwHashedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwHashedContext {
	var p = new(KwHashedContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwHashed

	return p
}

func (s *KwHashedContext) GetParser() antlr.Parser { return s.parser }

func (s *KwHashedContext) K_HASHED() antlr.TerminalNode {
	return s.GetToken(CqlParserK_HASHED, 0)
}

func (s *KwHashedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwHashedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwHashedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwHashed(s)
	}
}

func (s *KwHashedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwHashed(s)
	}
}

func (p *CqlParser) KwHashed() (localctx IKwHashedContext) {
	localctx = NewKwHashedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 742, CqlParserRULE_kwHashed)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3341)
		p.Match(CqlParserK_HASHED)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwEmptyContext is an interface to support dynamic dispatch.
type IKwEmptyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_EMPTY() antlr.TerminalNode

	// IsKwEmptyContext differentiates from other interfaces.
	IsKwEmptyContext()
}

type KwEmptyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwEmptyContext() *KwEmptyContext {
	var p = new(KwEmptyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwEmpty
	return p
}

func InitEmptyKwEmptyContext(p *KwEmptyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwEmpty
}

func (*KwEmptyContext) IsKwEmptyContext() {}

func NewKwEmptyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwEmptyContext {
	var p = new(KwEmptyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwEmpty

	return p
}

func (s *KwEmptyContext) GetParser() antlr.Parser { return s.parser }

func (s *KwEmptyContext) K_EMPTY() antlr.TerminalNode {
	return s.GetToken(CqlParserK_EMPTY, 0)
}

func (s *KwEmptyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwEmptyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwEmptyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwEmpty(s)
	}
}

func (s *KwEmptyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwEmpty(s)
	}
}

func (p *CqlParser) KwEmpty() (localctx IKwEmptyContext) {
	localctx = NewKwEmptyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 744, CqlParserRULE_kwEmpty)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3343)
		p.Match(CqlParserK_EMPTY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwConcurrencyContext is an interface to support dynamic dispatch.
type IKwConcurrencyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_CONCURRENCY() antlr.TerminalNode

	// IsKwConcurrencyContext differentiates from other interfaces.
	IsKwConcurrencyContext()
}

type KwConcurrencyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwConcurrencyContext() *KwConcurrencyContext {
	var p = new(KwConcurrencyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwConcurrency
	return p
}

func InitEmptyKwConcurrencyContext(p *KwConcurrencyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwConcurrency
}

func (*KwConcurrencyContext) IsKwConcurrencyContext() {}

func NewKwConcurrencyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwConcurrencyContext {
	var p = new(KwConcurrencyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwConcurrency

	return p
}

func (s *KwConcurrencyContext) GetParser() antlr.Parser { return s.parser }

func (s *KwConcurrencyContext) K_CONCURRENCY() antlr.TerminalNode {
	return s.GetToken(CqlParserK_CONCURRENCY, 0)
}

func (s *KwConcurrencyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwConcurrencyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwConcurrencyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwConcurrency(s)
	}
}

func (s *KwConcurrencyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwConcurrency(s)
	}
}

func (p *CqlParser) KwConcurrency() (localctx IKwConcurrencyContext) {
	localctx = NewKwConcurrencyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 746, CqlParserRULE_kwConcurrency)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3345)
		p.Match(CqlParserK_CONCURRENCY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwVectorSearchIndexingContext is an interface to support dynamic dispatch.
type IKwVectorSearchIndexingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_VECTOR_SEARCH_INDEXING() antlr.TerminalNode

	// IsKwVectorSearchIndexingContext differentiates from other interfaces.
	IsKwVectorSearchIndexingContext()
}

type KwVectorSearchIndexingContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwVectorSearchIndexingContext() *KwVectorSearchIndexingContext {
	var p = new(KwVectorSearchIndexingContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwVectorSearchIndexing
	return p
}

func InitEmptyKwVectorSearchIndexingContext(p *KwVectorSearchIndexingContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_kwVectorSearchIndexing
}

func (*KwVectorSearchIndexingContext) IsKwVectorSearchIndexingContext() {}

func NewKwVectorSearchIndexingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwVectorSearchIndexingContext {
	var p = new(KwVectorSearchIndexingContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_kwVectorSearchIndexing

	return p
}

func (s *KwVectorSearchIndexingContext) GetParser() antlr.Parser { return s.parser }

func (s *KwVectorSearchIndexingContext) K_VECTOR_SEARCH_INDEXING() antlr.TerminalNode {
	return s.GetToken(CqlParserK_VECTOR_SEARCH_INDEXING, 0)
}

func (s *KwVectorSearchIndexingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwVectorSearchIndexingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwVectorSearchIndexingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.EnterKwVectorSearchIndexing(s)
	}
}

func (s *KwVectorSearchIndexingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CqlParserListener); ok {
		listenerT.ExitKwVectorSearchIndexing(s)
	}
}

func (p *CqlParser) KwVectorSearchIndexing() (localctx IKwVectorSearchIndexingContext) {
	localctx = NewKwVectorSearchIndexingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 748, CqlParserRULE_kwVectorSearchIndexing)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3347)
		p.Match(CqlParserK_VECTOR_SEARCH_INDEXING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}
